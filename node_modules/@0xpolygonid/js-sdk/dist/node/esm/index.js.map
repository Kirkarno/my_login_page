{"version":3,"sources":["../../../src/kms/kms.ts","../../../src/kms/key-providers/bjj-provider.ts","../../../src/kms/store/abstract-key-store.ts","../../../src/kms/store/memory-key-store.ts","../../../src/kms/store/types.ts","../../../src/kms/store/local-storage-key-store.ts","../../../src/kms/store/indexed-db-key-store.ts","../../../src/kms/provider-helpers.ts","../../../src/utils/encoding.ts","../../../src/utils/object.ts","../../../src/utils/did-helper.ts","../../../src/utils/message-bus.ts","../../../src/utils/compare-func.ts","../../../src/kms/key-providers/ed25519-provider.ts","../../../src/kms/key-providers/secp256k1-provider.ts","../../../src/identity/identity-wallet.ts","../../../src/identity/common.ts","../../../src/verifiable/proof.ts","../../../src/verifiable/constants.ts","../../../src/verifiable/credential.ts","../../../src/credentials/utils.ts","../../../src/verifiable/core-utils.ts","../../../src/verifiable/presentation.ts","../../../src/verifiable/schema.ts","../../../src/schema-processor/utils.ts","../../../src/schema-processor/json/parser.ts","../../../src/schema-processor/json/validator.ts","../../../src/schema-processor/jsonld/parser.ts","../../../src/schema-processor/jsonld/cache.ts","../../../src/storage/blockchain/state.ts","../../../src/circuits/common.ts","../../../src/circuits/models.ts","../../../src/circuits/comparer.ts","../../../src/circuits/atomic-query-mtp-v2.ts","../../../src/circuits/atomic-query-mtp-v2-on-chain.ts","../../../src/circuits/atomic-query-sig-v2.ts","../../../src/circuits/atomic-query-v3.ts","../../../src/circuits/atomic-query-v3-on-chain.ts","../../../src/circuits/atomic-query-sig-v2-on-chain.ts","../../../src/circuits/auth-v2.ts","../../../src/circuits/state-transition.ts","../../../src/circuits/linked-multi-query.ts","../../../src/storage/blockchain/abi/State.json","../../../src/blockchain/transaction-service.ts","../../../src/storage/blockchain/common.ts","../../../src/storage/memory/merkletree.ts","../../../src/storage/entities/mt.ts","../../../src/storage/utils.ts","../../../src/storage/memory/data-source.ts","../../../src/storage/memory/cache-lru.ts","../../../src/iden3comm/utils/message.ts","../../../src/iden3comm/errors.ts","../../../src/iden3comm/utils/envelope.ts","../../../src/iden3comm/packageManager.ts","../../../src/iden3comm/packers/zkp.ts","../../../src/iden3comm/constants.ts","../../../src/iden3comm/utils/did.ts","../../../src/iden3comm/utils/accept-profile.ts","../../../src/iden3comm/packers/plain.ts","../../../src/iden3comm/packers/jws.ts","../../../src/iden3comm/types/protocol/credentials.ts","../../../src/iden3comm/types/protocol/contract-request.ts","../../../src/iden3comm/types/protocol/discovery-protocol.ts","../../../src/iden3comm/handlers/auth.ts","../../../src/iden3comm/handlers/common.ts","../../../src/iden3comm/handlers/message-handler.ts","../../../src/storage/blockchain/onchain-revocation.ts","../../../src/storage/blockchain/abi/CredentialStatusResolver.json","../../../src/credentials/status/on-chain-revocation.ts","../../../src/credentials/status/reverse-sparse-merkle-tree.ts","../../../src/credentials/status/sparse-merkle-tree.ts","../../../src/credentials/status/resolver.ts","../../../src/credentials/status/agent-revocation.ts","../../../src/credentials/status/credential-status-publisher.ts","../../../src/credentials/status/did-resolver-revocation.ts","../../../src/credentials/credential-wallet.ts","../../../src/credentials/rhs.ts","../../../src/iden3comm/handlers/fetch.ts","../../../src/iden3comm/handlers/contract-request.ts","../../../src/iden3comm/handlers/refresh.ts","../../../src/iden3comm/handlers/revocation-status.ts","../../../src/iden3comm/handlers/credential-proposal.ts","../../../src/iden3comm/handlers/payment.ts","../../../src/iden3comm/handlers/discovery-protocol.ts","../../../src/iden3comm/handlers/problem-report.ts","../../../src/storage/blockchain/onchain-zkp-verifier.ts","../../../src/storage/blockchain/abi/ZkpVerifier.json","../../../src/storage/blockchain/onchain-issuer.ts","../../../src/storage/blockchain/onchain-issuer-adapter/non-merklized/version/v0.0.1/onchain-non-merklized-issuer-adapter.ts","../../../src/storage/blockchain/did-resolver-readonly-storage.ts","../../../src/storage/blockchain/erc20-helper.ts","../../../src/storage/blockchain/abi/ERC20Permit.json","../../../src/storage/blockchain/abi/ERC20.json","../../../src/storage/filters/jsonQuery.ts","../../../src/storage/local-storage/data-source.ts","../../../src/storage/local-storage/merkletree.ts","../../../src/storage/indexed-db/data-source.ts","../../../src/storage/indexed-db/merkletree.ts","../../../src/storage/shared/circuit-storage.ts","../../../src/storage/shared/credential-storage.ts","../../../src/storage/shared/identity-storage.ts","../../../src/storage/fs/circuits-storage.ts","../../../src/proof/proof-service.ts","../../../src/proof/common.ts","../../../src/proof/provers/prover.ts","../../../src/proof/provers/witness_calculator.ts","../../../src/proof/provers/inputs-generator.ts","../../../src/proof/verifiers/pub-signals-verifier.ts","../../../src/proof/verifiers/query.ts","../../../src/proof/verifiers/query-hash.ts","../../../src/index.ts"],"sourcesContent":["import { KmsKeyId, KmsKeyType } from './store';\n\n/**\n * KeyProvider is responsible for signing and creation of the keys\n *\n * @public\n * @interface   IKeyProvider\n */\nexport interface IKeyProvider {\n  /**\n   * property to store key type\n   *\n   * @type {KmsKeyType}\n   */\n  keyType: KmsKeyType;\n\n  /**\n   * get all keys\n   *\n   * @returns list of keys\n   */\n  list(): Promise<\n    {\n      alias: string;\n      key: string;\n    }[]\n  >;\n  /**\n   * gets public key by key id\n   *\n   * @param {KmsKeyId} keyID - kms key identifier\n   * @returns `Promise<PublicKey>`\n   */\n  publicKey(keyID: KmsKeyId): Promise<string>;\n  /**\n   * sign data with kms key\n   *\n   * @param {KmsKeyId} keyId - key identifier\n   * @param {Uint8Array} data  - bytes payload\n   * @param {{ [key: string]: unknown }} opts  - additional options for signing\n   * @returns `Promise<Uint8Array>`\n   */\n  sign(keyId: KmsKeyId, data: Uint8Array, opts?: { [key: string]: unknown }): Promise<Uint8Array>;\n\n  /**\n   * creates new key pair from given seed\n   *\n   * @param {Uint8Array} seed - seed\n   * @returns `Promise<KmsKeyId>`\n   */\n  newPrivateKeyFromSeed(seed: Uint8Array): Promise<KmsKeyId>;\n\n  /**\n   * Verifies a message signature using the provided key ID.\n   *\n   * @param message - The message bytes to verify.\n   * @param signatureHex - The signature in hexadecimal format.\n   * @param keyId - The KMS key ID used to verify the signature.\n   * @returns A promise that resolves to a boolean indicating whether the signature is valid.\n   */\n  verify(message: Uint8Array, signatureHex: string, keyId: KmsKeyId): Promise<boolean>;\n}\n/**\n * Key management system class contains different key providers.\n * allows to register custom provider, create key, get public key and sign\n *\n * @public\n * @class KMS - class\n */\nexport class KMS {\n  private readonly _registry = new Map<KmsKeyType, IKeyProvider>();\n\n  /**\n   * register key provider in the KMS\n   *\n   * @param {KmsKeyType} keyType - kms key type\n   * @param {IKeyProvider} keyProvider - key provider implementation\n   */\n  registerKeyProvider(keyType: KmsKeyType, keyProvider: IKeyProvider): void {\n    if (this._registry.get(keyType)) {\n      throw new Error('present keyType');\n    }\n    this._registry.set(keyType, keyProvider);\n  }\n\n  /**\n   * generates a new key and returns it kms key id\n   *\n   * @param {KmsKeyType} keyType\n   * @param {Uint8Array} bytes\n   * @returns kms key id\n   */\n  async createKeyFromSeed(keyType: KmsKeyType, bytes: Uint8Array): Promise<KmsKeyId> {\n    const keyProvider = this._registry.get(keyType);\n    if (!keyProvider) {\n      throw new Error(`keyProvider not found for: ${keyType}`);\n    }\n    return keyProvider.newPrivateKeyFromSeed(bytes);\n  }\n\n  /**\n   * gets public key for key id\n   *\n   * @param {KmsKeyId} keyId -- key id\n   * @returns public key\n   */\n  async publicKey(keyId: KmsKeyId): Promise<string> {\n    const keyProvider = this._registry.get(keyId.type);\n    if (!keyProvider) {\n      throw new Error(`keyProvider not found for: ${keyId.type}`);\n    }\n\n    return keyProvider.publicKey(keyId);\n  }\n\n  /**\n   * sign Uint8Array with giv KmsKeyIden\n   *\n   * @param {KmsKeyId} keyId - key id\n   * @param {Uint8Array} data - prepared data bytes\n   * @returns `Promise<Uint8Array>` - return signature\n   */\n  async sign(\n    keyId: KmsKeyId,\n    data: Uint8Array,\n    opts?: {\n      [key: string]: unknown;\n    }\n  ): Promise<Uint8Array> {\n    const keyProvider = this._registry.get(keyId.type);\n    if (!keyProvider) {\n      throw new Error(`keyProvider not found for: ${keyId.type}`);\n    }\n\n    return keyProvider.sign(keyId, data, opts);\n  }\n\n  /**\n   * Verifies a signature against the provided data and key ID.\n   *\n   * @param data - The data to verify the signature against.\n   * @param signatureHex - The signature to verify, in hexadecimal format.\n   * @param keyId - The key ID to use for verification.\n   * @returns A promise that resolves to a boolean indicating whether the signature is valid.\n   */\n  verify(data: Uint8Array, signatureHex: string, keyId: KmsKeyId): Promise<boolean> {\n    const keyProvider = this._registry.get(keyId.type);\n    if (!keyProvider) {\n      throw new Error(`keyProvider not found for: ${keyId.type}`);\n    }\n    return keyProvider.verify(data, signatureHex, keyId);\n  }\n\n  /**\n   * get all keys by key type\n   *\n   * @param keyType - Key type\n   * @returns list of keys\n   */\n  list(keyType: KmsKeyType): Promise<\n    {\n      alias: string;\n      key: string;\n    }[]\n  > {\n    const keyProvider = this._registry.get(keyType);\n    if (!keyProvider) {\n      throw new Error(`keyProvider not found for: ${keyType}`);\n    }\n\n    return keyProvider.list();\n  }\n}\n","import { Hex, PrivateKey, PublicKey, Signature } from '@iden3/js-crypto';\nimport { BytesHelper, checkBigIntInField } from '@iden3/js-iden3-core';\nimport { IKeyProvider } from '../kms';\nimport { AbstractPrivateKeyStore, KmsKeyId, KmsKeyType } from '../store';\n\nimport * as providerHelpers from '../provider-helpers';\nimport { hexToBytes } from '../../utils';\n\n/**\n * Provider for Baby Jub Jub keys\n * @public\n * @class BjjProvider\n * @implements implements IKeyProvider interface\n */\nexport class BjjProvider implements IKeyProvider {\n  /**\n   * key type that is handled by BJJ Provider\n   * @type {KmsKeyType}\n   */\n  keyType: KmsKeyType;\n  private keyStore: AbstractPrivateKeyStore;\n  /**\n   * Creates an instance of BjjProvider.\n   * @param {KmsKeyType} keyType - kms key type\n   * @param {AbstractPrivateKeyStore} keyStore - key store for kms\n   */\n  constructor(keyType: KmsKeyType, keyStore: AbstractPrivateKeyStore) {\n    if (keyType !== KmsKeyType.BabyJubJub) {\n      throw new Error('Key type must be BabyJubJub');\n    }\n    this.keyType = keyType;\n    this.keyStore = keyStore;\n  }\n  /**\n   * get all keys\n   * @returns list of keys\n   */\n  async list(): Promise<\n    {\n      alias: string;\n      key: string;\n    }[]\n  > {\n    const allKeysFromKeyStore = await this.keyStore.list();\n    return allKeysFromKeyStore.filter((key) => key.alias.startsWith(this.keyType));\n  }\n\n  /**\n   * generates a baby jub jub key from a seed phrase\n   * @param {Uint8Array} seed - byte array seed\n   * @returns kms key identifier\n   */\n  async newPrivateKeyFromSeed(seed: Uint8Array): Promise<KmsKeyId> {\n    const newKey: Uint8Array = new Uint8Array(32);\n    newKey.set(Uint8Array.from(seed), 0);\n    newKey.fill(seed.length, 32, 0);\n    const privateKey: PrivateKey = new PrivateKey(seed);\n\n    const publicKey = privateKey.public();\n\n    const kmsId = {\n      type: this.keyType,\n      id: providerHelpers.keyPath(this.keyType, publicKey.hex())\n    };\n    await this.keyStore.importKey({ alias: kmsId.id, key: privateKey.hex() });\n\n    return kmsId;\n  }\n\n  /**\n   * Gets public key by kmsKeyId\n   *\n   * @param {KmsKeyId} keyId - key identifier\n   */\n  async publicKey(keyId: KmsKeyId): Promise<string> {\n    const privateKey: PrivateKey = await this.privateKey(keyId);\n    return privateKey.public().hex();\n  }\n\n  /**\n   * signs prepared payload of size,\n   * with a key id\n   *\n   * @param {KmsKeyId} keyId  - key identifier\n   * @param {Uint8Array} data - data to sign (32 bytes)\n   * @returns Uint8Array signature\n   */\n  async sign(keyId: KmsKeyId, data: Uint8Array): Promise<Uint8Array> {\n    if (data.length != 32) {\n      throw new Error('data to sign is too large');\n    }\n\n    const i = BytesHelper.bytesToInt(data);\n    if (!checkBigIntInField(i)) {\n      throw new Error('data to sign is too large');\n    }\n    const privateKey = await this.privateKey(keyId);\n\n    const signature = privateKey.signPoseidon(i);\n\n    return signature.compress();\n  }\n\n  private async privateKey(keyId: KmsKeyId): Promise<PrivateKey> {\n    const privateKeyHex = await this.keyStore.get({ alias: keyId.id });\n\n    return new PrivateKey(Hex.decodeString(privateKeyHex));\n  }\n\n  async verify(message: Uint8Array, signatureHex: string, keyId: KmsKeyId): Promise<boolean> {\n    const publicKey = await this.publicKey(keyId);\n\n    return PublicKey.newFromCompressed(hexToBytes(publicKey)).verifyPoseidon(\n      BytesHelper.bytesToInt(message),\n      Signature.newFromCompressed(hexToBytes(signatureHex))\n    );\n  }\n}\n","/**\n * KeyStore that allows to import and get keys by alias.\n *\n * @abstract\n * @public\n * @class AbstractPrivateKeyStore\n */\nexport abstract class AbstractPrivateKeyStore {\n  /**\n   * imports key by alias\n   *\n   * @abstract\n   * @param {{ alias: string; key: string }} args - key alias and hex representation\n   * @returns `Promise<void>`\n   */\n  abstract importKey(args: { alias: string; key: string }): Promise<void>;\n\n  /**\n   * get key by alias\n   *\n   * @abstract\n   * @param {{ alias: string }} args -key alias\n   * @returns `Promise<string>`\n   */\n  abstract get(args: { alias: string }): Promise<string>;\n\n  /**\n   * get all keys\n   *\n   * @abstract\n   * @returns `Promise<{ alias: string; key: string }[]>`\n   */\n  abstract list(): Promise<{ alias: string; key: string }[]>;\n}\n","import { AbstractPrivateKeyStore } from './abstract-key-store';\n\n/**\n * Key Store to use in memory\n *\n * @public\n * @class InMemoryPrivateKeyStore\n * @implements implements AbstractPrivateKeyStore interface\n */\nexport class InMemoryPrivateKeyStore implements AbstractPrivateKeyStore {\n  private _data: Map<string, string>;\n  constructor() {\n    this._data = new Map<string, string>();\n  }\n  list(): Promise<{ alias: string; key: string }[]> {\n    return Promise.resolve(Array.from(this._data).map(([alias, key]) => ({ alias, key })));\n  }\n  async get(args: { alias: string }): Promise<string> {\n    const privateKey = this._data.get(args.alias);\n    if (!privateKey) {\n      throw new Error('no key under given alias');\n    }\n    return privateKey;\n  }\n\n  async importKey(args: { alias: string; key: string }): Promise<void> {\n    this._data.set(args.alias, args.key);\n  }\n}\n","/**\n * Key type that can be used in the key management system\n *\n * @enum {number}\n */\nexport enum KmsKeyType {\n  BabyJubJub = 'BJJ',\n  Secp256k1 = 'Secp256k1',\n  Ed25519 = 'Ed25519'\n}\n\n/**\n * ID of the key that describe contain key type\n *\n * @public\n * @interface   KmsKeyId\n */\nexport interface KmsKeyId {\n  type: KmsKeyType;\n  id: string;\n}\n","import { AbstractPrivateKeyStore } from './abstract-key-store';\nimport { KmsKeyId } from './types';\n\n/**\n * Allows storing keys in the local storage of the browser\n * (NOT ENCRYPTED: DO NOT USE IN THE PRODUCTION)\n *\n * @public\n * @class LocalStoragePrivateKeyStore\n * @implements implements AbstractPrivateKeyStore interface\n */\nexport class LocalStoragePrivateKeyStore implements AbstractPrivateKeyStore {\n  static readonly storageKey = 'keystore';\n\n  /**\n   * get all keys\n   *\n   * @abstract\n   * @returns `Promise<{ alias: string; key: string }[]>`\n   */\n  list(): Promise<{ alias: string; key: string }[]> {\n    const dataStr = localStorage.getItem(LocalStoragePrivateKeyStore.storageKey);\n    if (!dataStr) {\n      throw new Error('no key under given alias');\n    }\n    const data = JSON.parse(dataStr);\n    return data.map((i: { id: string; value: string }) => ({ alias: i.id, key: i.value }));\n  }\n  /**\n   * Gets key from the local storage\n   *\n   * @param {{ alias: string }} args\n   * @returns hex string\n   */\n  async get(args: { alias: string }): Promise<string> {\n    const dataStr = localStorage.getItem(LocalStoragePrivateKeyStore.storageKey);\n    if (!dataStr) {\n      throw new Error('no key under given alias');\n    }\n    const data = JSON.parse(dataStr);\n    const privateKey = data.find((d: KmsKeyId) => d.id === args.alias);\n    if (!privateKey) {\n      throw new Error('no key under given alias');\n    }\n    return privateKey.value;\n  }\n\n  /**\n   * Import key to the local storage\n   *\n   * @param {{ alias: string; key: string }} args - alias and private key in the hex\n   * @returns void\n   */\n  async importKey(args: { alias: string; key: string }): Promise<void> {\n    const dataStr = localStorage.getItem(LocalStoragePrivateKeyStore.storageKey);\n    let data = [];\n    if (dataStr) {\n      data = JSON.parse(dataStr);\n    }\n\n    const index = data.findIndex((d: KmsKeyId) => d.id === args.alias);\n    if (index > -1) {\n      data[index].value = args.key;\n    } else {\n      data.push({ id: args.alias, value: args.key });\n    }\n    localStorage.setItem(LocalStoragePrivateKeyStore.storageKey, JSON.stringify(data));\n  }\n}\n","import { UseStore, createStore, get, set, entries } from 'idb-keyval';\nimport { AbstractPrivateKeyStore } from './abstract-key-store';\n\n/**\n * Allows storing keys in the indexed db storage of the browser\n * (NOT ENCRYPTED: DO NOT USE IN THE PRODUCTION)\n *\n * @public\n * @class IndexedDBPrivateKeyStore\n * @implements implements AbstractPrivateKeyStore interface\n */\nexport class IndexedDBPrivateKeyStore implements AbstractPrivateKeyStore {\n  static readonly storageKey = 'keystore';\n  private readonly _store: UseStore;\n\n  constructor() {\n    this._store = createStore(\n      `${IndexedDBPrivateKeyStore.storageKey}-db`,\n      IndexedDBPrivateKeyStore.storageKey\n    );\n  }\n\n  /**\n   * get all keys\n   *\n   * @abstract\n   * @returns `Promise<{ alias: string; key: string }[]>`\n   */\n  async list(): Promise<{ alias: string; key: string }[]> {\n    const allEntries = await entries(this._store);\n    return allEntries.map(([alias, key]) => ({ alias, key: key.value })) as unknown as {\n      alias: string;\n      key: string;\n    }[];\n  }\n\n  /**\n   * Gets key from the indexed db storage\n   *\n   * @param {{ alias: string }} args\n   * @returns hex string\n   */\n  async get(args: { alias: string }): Promise<string> {\n    const key = await get(args.alias, this._store);\n    if (!key) {\n      throw new Error('no key under given alias');\n    }\n    return key.value;\n  }\n\n  /**\n   * Import key to the indexed db storage\n   *\n   * @param {{ alias: string; key: string }} args - alias and private key in the hex\n   * @returns void\n   */\n  async importKey(args: { alias: string; key: string }): Promise<void> {\n    await set(args.alias, { value: args.key }, this._store);\n  }\n}\n","import { KmsKeyType } from './store';\n\n/**\n * builds key path\n *\n * @param {KmsKeyType} keyType - key type\n * @param {string} keyID - key id\n * @returns string path\n */\nexport function keyPath(keyType: KmsKeyType, keyID: string): string {\n  const basePath = '';\n  return basePath + String(keyType) + ':' + keyID;\n}\n","import { base58FromBytes, base58ToBytes as b58ToBytes, Hex } from '@iden3/js-crypto';\nimport { base64url, base64 } from 'rfc4648';\n\nexport const byteEncoder = new TextEncoder();\nexport const byteDecoder = new TextDecoder();\n\nexport function bytesToBase64url(b: Uint8Array, opts = { pad: false }): string {\n  return base64url.stringify(b, opts);\n}\n\nexport function base64ToBytes(s: string, opts = { loose: true }): Uint8Array {\n  return base64.parse(s, opts);\n}\n\nexport function bytesToBase64(b: Uint8Array, opts = { pad: false }): string {\n  return base64.stringify(b, opts);\n}\n\nexport function base64UrlToBytes(s: string, opts = { loose: true }): Uint8Array {\n  const inputBase64Url = s.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n  return base64url.parse(inputBase64Url, opts);\n}\n\nexport function base58ToBytes(s: string): Uint8Array {\n  return b58ToBytes(s);\n}\n\nexport function bytesToBase58(b: Uint8Array): string {\n  return base58FromBytes(b);\n}\n\nexport function hexToBytes(s: string): Uint8Array {\n  const input = s.startsWith('0x') ? s.substring(2) : s;\n  return Hex.decodeString(input.toLowerCase());\n}\n\nexport function encodeBase64url(s: string, opts = { pad: false }): string {\n  return base64url.stringify(byteEncoder.encode(s), opts);\n}\n\nexport function decodeBase64url(s: string, opts = { loose: true }): string {\n  return byteDecoder.decode(base64url.parse(s, opts));\n}\n\nexport function bytesToHex(b: Uint8Array): string {\n  return Hex.encodeString(b);\n}\n","/**\n * Merges two objects together, prioritizing the properties of the second object.\n * If a property exists in both objects, the value from the second object will be used.\n * @param credSubject - The first object to merge.\n * @param otherCredSubject - The second object to merge.\n * @returns A new object with the merged properties.\n */\n\nimport { JsonDocumentObject } from '../iden3comm';\n\nexport function mergeObjects(\n  credSubject: JsonDocumentObject,\n  otherCredSubject: JsonDocumentObject\n) {\n  let result = {} as JsonDocumentObject;\n  const credSubjectKeys = Object.keys(credSubject);\n\n  for (const key of credSubjectKeys) {\n    if (typeof otherCredSubject[key] !== 'undefined') {\n      if (typeof credSubject[key] !== 'object' && typeof otherCredSubject[key] !== 'object') {\n        throw new Error('Invalid query');\n      }\n      const subjectProperty = credSubject[key] as JsonDocumentObject;\n      const otherSubjectProperty = otherCredSubject[key] as JsonDocumentObject;\n      const propertyOperators = Object.keys(subjectProperty);\n      const subjectPropertyResult: JsonDocumentObject = {};\n      for (const operatorKey of propertyOperators) {\n        if (typeof otherSubjectProperty[operatorKey] !== 'undefined') {\n          const operatorValue1 = subjectProperty[operatorKey] as JsonDocumentObject;\n          const operatorValue2 = otherSubjectProperty[operatorKey];\n          subjectPropertyResult[operatorKey] = [\n            ...new Set([\n              ...((subjectPropertyResult[operatorKey] as Array<JsonDocumentObject>) ?? []),\n              operatorValue1,\n              ...(Array.isArray(operatorValue2) ? operatorValue2 : [operatorValue2])\n            ])\n          ];\n        } else {\n          subjectPropertyResult[operatorKey] = subjectProperty[operatorKey];\n        }\n      }\n      result[key] = {\n        ...(otherCredSubject[key] as JsonDocumentObject),\n        ...subjectPropertyResult\n      };\n    }\n  }\n\n  // Add remaining keys from obj2\n  result = { ...credSubject, ...otherCredSubject, ...result };\n  return result;\n}\n","import { Hex } from '@iden3/js-crypto';\nimport { Id, buildDIDType, genesisFromEthAddress, DID } from '@iden3/js-iden3-core';\nimport { Hash } from '@iden3/js-merkletree';\nimport { DIDResolutionResult, VerificationMethod, DIDResolutionMetadata } from 'did-resolver';\nimport { keccak256 } from 'ethers';\nimport { hexToBytes } from './encoding';\n\n/**\n * Supported DID Document Signatures\n */\nexport enum DIDDocumentSignature {\n  EthereumEip712Signature2021 = 'EthereumEip712Signature2021'\n}\n\n/**\n * Checks if state is genesis state\n *\n * @param {DID} did - did\n * @param {bigint|string} state  - hash on bigInt or hex string format\n * @returns boolean\n */\nexport function isGenesisState(did: DID, state: bigint | string): boolean {\n  if (typeof state === 'string') {\n    state = Hash.fromHex(state).bigInt();\n  }\n  const id = DID.idFromDID(did);\n  const { method, blockchain, networkId } = DID.decodePartsFromId(id);\n  const type = buildDIDType(method, blockchain, networkId);\n  const idFromState = Id.idGenesisFromIdenState(type, state);\n\n  return id.bigInt().toString() === idFromState.bigInt().toString();\n}\n\n/**\n * Checks if DID is an ethereum identity\n *\n * @param {DID} did - did\n * @returns boolean\n */\nexport function isEthereumIdentity(did: DID): boolean {\n  const issuerId = DID.idFromDID(did);\n  try {\n    Id.ethAddressFromId(issuerId);\n    // is an ethereum identity\n    return true;\n  } catch {\n    // not an ethereum identity (BabyJubJub or other)\n    return false;\n  }\n}\n\nexport const buildVerifierId = (\n  address: string,\n  info: { method: string; blockchain: string; networkId: string }\n): Id => {\n  address = address.replace('0x', '');\n  const ethAddrBytes = Hex.decodeString(address);\n  const ethAddr = ethAddrBytes.slice(0, 20);\n  const genesis = genesisFromEthAddress(ethAddr);\n\n  const tp = buildDIDType(info.method, info.blockchain, info.networkId);\n\n  return new Id(tp, genesis);\n};\n\nexport const validateDIDDocumentAuth = async (did: DID, resolverURL: string, state: Hash) => {\n  const vm = await resolveDIDDocumentAuth(did, resolverURL, state);\n  if (!vm) {\n    throw new Error(`can't resolve DID document`);\n  }\n  // published or genesis\n  if (\n    !(vm as VerificationMethod & { published: string }).published &&\n    !isGenesisState(did, state.bigInt())\n  ) {\n    throw new Error(`issuer state not published and not genesis`);\n  }\n};\n\nexport const resolveDIDDocumentAuth = async (\n  did: DID,\n  resolveURL: string,\n  state?: Hash\n): Promise<VerificationMethod | undefined> => {\n  let url = `${resolveURL}/${encodeURIComponent(did.string())}`;\n  if (state) {\n    url += `?state=${state.hex()}`;\n  }\n  const resp = await fetch(url);\n  const didResolutionRes = (await resp.json()) as DIDResolutionResult;\n  return didResolutionRes.didDocument?.verificationMethod?.find(\n    (i) => i.type === 'Iden3StateInfo2023'\n  );\n};\n\nfunction emptyStateDID(did: DID) {\n  const id = DID.idFromDID(did);\n  const didType = buildDIDType(\n    DID.methodFromId(id),\n    DID.blockchainFromId(id),\n    DID.networkIdFromId(id)\n  );\n  const identifier = Id.idGenesisFromIdenState(didType, 0n);\n  const emptyDID = DID.parseFromId(identifier);\n\n  return emptyDID;\n}\n\nexport const resolveDidDocument = async (\n  did: DID,\n  resolverUrl: string,\n  opts?: {\n    state?: Hash;\n    gist?: Hash;\n    signature?: DIDDocumentSignature;\n  }\n): Promise<DIDResolutionMetadata> => {\n  let didString = encodeURIComponent(did.string());\n  // for gist resolve we have to `hide` user did (look into resolver implementation)\n  const isGistRequest = opts?.gist && !opts.state;\n  if (isGistRequest) {\n    didString = encodeURIComponent(emptyStateDID(did).string());\n  }\n  let url = `${resolverUrl}/1.0/identifiers/${didString}`;\n\n  if (opts?.signature) {\n    url += `?signature=${opts.signature}`;\n  }\n\n  if (opts?.state) {\n    url += `${url.includes('?') ? '&' : '?'}state=${opts.state.hex()}`;\n  }\n\n  if (opts?.gist) {\n    url += `${url.includes('?') ? '&' : '?'}gist=${opts.gist.hex()}`;\n  }\n  try {\n    const resp = await fetch(url);\n    const data = await resp.json();\n    return data;\n  } catch (e) {\n    throw new Error(`Failed to resolve DID document for ${did} ${e}`);\n  }\n};\n\nexport const buildDIDFromEthPubKey = (didType: Uint8Array, pubKeyEth: string): DID => {\n  // Use Keccak-256 hash function to get public key hash\n  const hashOfPublicKey = keccak256(hexToBytes(pubKeyEth));\n  // Convert hash to buffer\n  const ethAddressBuffer = hexToBytes(hashOfPublicKey);\n  // Ethereum Address is '0x' concatenated with last 20 bytes\n  // of the public key hash\n  const ethAddr = ethAddressBuffer.slice(-20);\n  const genesis = genesisFromEthAddress(ethAddr);\n  const identifier = new Id(didType, genesis);\n  return DID.parseFromId(identifier);\n};\n","import PubSub from 'pubsub-js';\n\n/**\n * Represents an event in the SDK.\n */\ntype SdkEvent = string;\n\nexport const SDK_EVENTS: { [k: SdkEvent]: SdkEvent } = {\n  TX_RECEIPT_ACCEPTED: 'TX_RECEIPT_ACCEPTED'\n};\n\n/**\n * Represents a topic in the SDK message bus.\n */\nexport type SdkTopic = keyof typeof SDK_EVENTS;\n\n/**\n * Represents a message bus that allows publishing and subscribing to topics.\n */\nexport class MessageBus {\n  /**\n   * The singleton instance of the MessageBus class.\n   */\n  private static instance: MessageBus;\n\n  /**\n   * Private constructor for the MessageBus class.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  private constructor() {}\n\n  /**\n   * Returns the singleton instance of the MessageBus class.\n   * If the instance doesn't exist, it creates a new one.\n   * @returns The singleton instance of the MessageBus class.\n   */\n  public static getInstance(): MessageBus {\n    // If the instance doesn't exist, create it\n    if (!MessageBus.instance) {\n      MessageBus.instance = new MessageBus();\n    }\n    // Return the instance\n    return MessageBus.instance;\n  }\n\n  /**\n   * Publishes a message to the specified topic.\n   *\n   * @template T - The type of data being published.\n   * @param {SdkTopic} topic - The topic to publish the message to.\n   * @param {T} data - The data to be published.\n   * @returns {boolean} - Returns true if the message was successfully published, false otherwise.\n   */\n  public publish<T>(topic: SdkTopic, data: T): boolean {\n    return PubSub.publish(topic.toString(), data);\n  }\n\n  /**\n   * Subscribes to a specific topic and registers a callback function to be executed when a message is published.\n   *\n   * @param topic - The topic to subscribe to.\n   * @param callback - The callback function to be executed when a message is published.\n   */\n  public subscribe<T>(topic: SdkTopic, callback: (data: T) => void): string {\n    return PubSub.subscribe(topic.toString(), (_, data) => callback(data));\n  }\n\n  /**\n   * Subscribes to a specific topic and registers a callback function to be executed when a message is published.\n   * The callback function is executed only once.\n   *\n   * @param topic - The topic to subscribe to.\n   * @param callback - The callback function to be executed when a message is published.\n   */\n  public subscribeOnce<T>(topic: SdkTopic, callback: (data: T) => void): void {\n    PubSub.subscribeOnce(topic.toString(), (_, data) => callback(data));\n  }\n\n  /**\n   * Unsubscribes from a specific topic in the message bus.\n   *\n   * @param topic - The topic to unsubscribe from.\n   * @returns A string or boolean indicating the success of the unsubscribe operation.\n   */\n  public unsubscribe(topic: SdkTopic): string | boolean {\n    return PubSub.unsubscribe(topic.toString());\n  }\n}\n","export const bigIntCompare = (a: bigint, b: bigint): number => {\n  if (a < b) return -1;\n  if (a > b) return 1;\n  return 0;\n};\n","import { IKeyProvider } from '../kms';\nimport { AbstractPrivateKeyStore, KmsKeyId, KmsKeyType } from '../store';\nimport * as providerHelpers from '../provider-helpers';\nimport { ed25519 } from '@noble/curves/ed25519';\nimport { bytesToHex } from '../../utils';\n\n/**\n * Provider for Ed25519 keys\n * @public\n * @class Ed25519Provider\n * @implements IKeyProvider interface\n */\nexport class Ed25519Provider implements IKeyProvider {\n  /**\n   * Creates an instance of Ed25519Provider.\n   * @param {KmsKeyType} keyType - kms key type\n   * @param {AbstractPrivateKeyStore} keyStore - key store for kms\n   */\n  constructor(\n    public readonly keyType: KmsKeyType,\n    private readonly _keyStore: AbstractPrivateKeyStore\n  ) {}\n\n  /**\n   * get all keys\n   * @returns list of keys\n   */\n  async list(): Promise<\n    {\n      alias: string;\n      key: string;\n    }[]\n  > {\n    const allKeysFromKeyStore = await this._keyStore.list();\n    return allKeysFromKeyStore.filter((key) => key.alias.startsWith(this.keyType));\n  }\n\n  /**\n   * generates a ed25519 key from a seed phrase\n   * @param {Uint8Array} seed - byte array seed\n   * @returns {Promise<KmsKeyId>} kms key identifier\n   */\n  async newPrivateKeyFromSeed(seed: Uint8Array): Promise<KmsKeyId> {\n    if (seed.length !== 32) {\n      throw new Error('Seed should be 32 bytes');\n    }\n\n    const publicKey = ed25519.getPublicKey(seed);\n    const kmsId = {\n      type: this.keyType,\n      id: providerHelpers.keyPath(this.keyType, bytesToHex(publicKey))\n    };\n\n    await this._keyStore.importKey({\n      alias: kmsId.id,\n      key: bytesToHex(seed)\n    });\n\n    return kmsId;\n  }\n\n  /**\n   * Gets public key by kmsKeyId\n   * @param {KmsKeyId} keyId - key identifier\n   * @returns {Promise<string>} Public key as a hex string\n   */\n  async publicKey(keyId: KmsKeyId): Promise<string> {\n    const privateKeyHex = await this.privateKey(keyId);\n    const publicKey = ed25519.getPublicKey(privateKeyHex);\n    return bytesToHex(publicKey);\n  }\n\n  /**\n   * signs prepared payload of size,\n   * with a key id\n   * @param {KmsKeyId} keyId  - key identifier\n   * @param {Uint8Array} digest - data to sign (32 bytes)\n   * @returns {Promise<Uint8Array>} signature\n   */\n  async sign(keyId: KmsKeyId, digest: Uint8Array): Promise<Uint8Array> {\n    const privateKeyHex = await this.privateKey(keyId);\n    return ed25519.sign(digest, privateKeyHex);\n  }\n\n  /**\n   * Verifies a signature for the given message and key identifier.\n   * @param digest - The message to verify the signature against.\n   * @param signatureHex - The signature to verify, as a hexadecimal string.\n   * @param keyId - The key identifier to use for verification.\n   * @returns A Promise that resolves to a boolean indicating whether the signature is valid.\n   */\n  async verify(digest: Uint8Array, signatureHex: string, keyId: KmsKeyId): Promise<boolean> {\n    const publicKeyHex = await this.publicKey(keyId);\n    return ed25519.verify(signatureHex, digest, publicKeyHex);\n  }\n\n  /**\n   * Retrieves the private key for a given keyId from the key store.\n   * @param {KmsKeyId} keyId - The identifier of the key to retrieve.\n   * @returns {Promise<string>} The private key associated with the keyId.\n   */\n  private async privateKey(keyId: KmsKeyId): Promise<string> {\n    return this._keyStore.get({ alias: keyId.id });\n  }\n}\n","import { IKeyProvider } from '../kms';\nimport { AbstractPrivateKeyStore, KmsKeyId, KmsKeyType } from '../store';\nimport * as providerHelpers from '../provider-helpers';\nimport { base64UrlToBytes, bytesToHex } from '../../utils';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { sha256 } from '@iden3/js-crypto';\nimport { ES256KSigner, hexToBytes } from 'did-jwt';\n\n/**\n * Provider for Secp256k1\n * @public\n * @class Secp256k1Provider\n * @implements implements IKeyProvider interface\n */\nexport class Sec256k1Provider implements IKeyProvider {\n  /**\n   * key type that is handled by BJJ Provider\n   * @type {KmsKeyType}\n   */\n  keyType: KmsKeyType;\n  private _keyStore: AbstractPrivateKeyStore;\n\n  /**\n   * Creates an instance of BjjProvider.\n   * @param {KmsKeyType} keyType - kms key type\n   * @param {AbstractPrivateKeyStore} keyStore - key store for kms\n   */\n  constructor(keyType: KmsKeyType, keyStore: AbstractPrivateKeyStore) {\n    if (keyType !== KmsKeyType.Secp256k1) {\n      throw new Error('Key type must be Secp256k1');\n    }\n    this.keyType = keyType;\n    this._keyStore = keyStore;\n  }\n\n  /**\n   * get all keys\n   * @returns list of keys\n   */\n  async list(): Promise<\n    {\n      alias: string;\n      key: string;\n    }[]\n  > {\n    const allKeysFromKeyStore = await this._keyStore.list();\n    return allKeysFromKeyStore.filter((key) => key.alias.startsWith(this.keyType));\n  }\n\n  /**\n   * generates a baby jub jub key from a seed phrase\n   * @param {Uint8Array} seed - byte array seed\n   * @returns kms key identifier\n   */\n  async newPrivateKeyFromSeed(seed: Uint8Array): Promise<KmsKeyId> {\n    if (seed.length !== 32) {\n      throw new Error('Seed should be 32 bytes');\n    }\n    const publicKey = secp256k1.getPublicKey(seed);\n    const kmsId = {\n      type: this.keyType,\n      id: providerHelpers.keyPath(this.keyType, bytesToHex(publicKey))\n    };\n\n    await this._keyStore.importKey({\n      alias: kmsId.id,\n      key: bytesToHex(seed).padStart(64, '0')\n    });\n\n    return kmsId;\n  }\n\n  /**\n   * Gets public key by kmsKeyId\n   *\n   * @param {KmsKeyId} keyId - key identifier\n   */\n  async publicKey(keyId: KmsKeyId): Promise<string> {\n    const privateKeyHex = await this.privateKey(keyId);\n    const publicKey = secp256k1.getPublicKey(privateKeyHex, false); // 04 + x + y (uncompressed key)\n    return bytesToHex(publicKey);\n  }\n\n  /**\n   * Signs the given data using the private key associated with the specified key identifier.\n   * @param keyId - The key identifier to use for signing.\n   * @param data - The data to sign.\n   * @param opts - Signing options, such as the algorithm to use.\n   * @returns A Promise that resolves to the signature as a Uint8Array.\n   */\n  async sign(\n    keyId: KmsKeyId,\n    data: Uint8Array,\n    opts: { [key: string]: unknown } = { alg: 'ES256K' }\n  ): Promise<Uint8Array> {\n    const privateKeyHex = await this.privateKey(keyId);\n\n    const signatureBase64 = await ES256KSigner(\n      hexToBytes(privateKeyHex),\n      opts.alg === 'ES256K-R'\n    )(data);\n\n    if (typeof signatureBase64 !== 'string') {\n      throw new Error('signatureBase64 must be a string');\n    }\n\n    return base64UrlToBytes(signatureBase64);\n  }\n\n  /**\n   * Verifies a signature for the given message and key identifier.\n   * @param message - The message to verify the signature against.\n   * @param signatureHex - The signature to verify, as a hexadecimal string.\n   * @param keyId - The key identifier to use for verification.\n   * @returns A Promise that resolves to a boolean indicating whether the signature is valid.\n   */\n  async verify(message: Uint8Array, signatureHex: string, keyId: KmsKeyId): Promise<boolean> {\n    const publicKeyHex = await this.publicKey(keyId);\n    return secp256k1.verify(signatureHex, sha256(message), publicKeyHex);\n  }\n\n  private async privateKey(keyId: KmsKeyId): Promise<string> {\n    return this._keyStore.get({ alias: keyId.id });\n  }\n}\n","import { KMS, KmsKeyId, KmsKeyType } from '../kms';\nimport {\n  Blockchain,\n  buildDIDType,\n  BytesHelper,\n  Claim,\n  ClaimOptions,\n  DID,\n  DidMethod,\n  getUnixTimestamp,\n  Id,\n  NetworkId,\n  SchemaHash\n} from '@iden3/js-iden3-core';\nimport {\n  poseidon,\n  PublicKey,\n  sha256,\n  Signature,\n  Hex,\n  getRandomBytes,\n  Poseidon\n} from '@iden3/js-crypto';\nimport { Hash, hashElems, ZERO_HASH } from '@iden3/js-merkletree';\nimport { generateProfileDID, subjectPositionIndex } from './common';\nimport * as uuid from 'uuid';\nimport { JSONSchema, JsonSchemaValidator, cacheLoader } from '../schema-processor';\nimport { IDataStorage, MerkleTreeType, Profile, UserStateTransitionInfo } from '../storage';\nimport {\n  VerifiableConstants,\n  BJJSignatureProof2021,\n  MerklizedRootPosition,\n  SubjectPosition,\n  W3CCredential,\n  MerkleTreeProofWithTreeState,\n  Iden3SparseMerkleTreeProof,\n  ProofType,\n  CredentialStatusType,\n  ProofQuery,\n  CoreClaimCreationOptions\n} from '../verifiable';\nimport {\n  CredentialRequest,\n  getKMSIdByAuthCredential,\n  getNodesRepresentation,\n  ICredentialWallet,\n  ProofNode,\n  PublishMode,\n  pushHashesToRHS,\n  TreesModel\n} from '../credentials';\nimport { CircuitId, StateTransitionInputs, TreeState } from '../circuits';\nimport { buildDIDFromEthPubKey, byteEncoder, isEthereumIdentity } from '../utils';\nimport { Options } from '@iden3/js-jsonld-merklization';\nimport { Signer, TransactionReceipt } from 'ethers';\nimport {\n  CredentialStatusPublisherRegistry,\n  Iden3SmtRhsCredentialStatusPublisher\n} from '../credentials/status/credential-status-publisher';\nimport { InputGenerator, IZKProver } from '../proof';\nimport { ITransactionService, TransactionService } from '../blockchain';\n\n/**\n * DID creation options\n * seed - seed to generate BJJ key pair\n * revocationOpts -\n\n * @type IdentityCreationOptions\n */\nexport type IdentityCreationOptions = {\n  method?: string;\n  blockchain?: string;\n  networkId?: string;\n} & AuthBJJCredentialCreationOptions;\n\n/**\n * Options for creating Auth BJJ credential\n * seed - seed to generate BJJ key pair\n * revocationOpts\n *  nonce - explicit revocation nonce to use\n *  onChain - onchain status related option\n *      txCallback - defines how the TransactionReceipt is handled\n *      publishMode  - specifies the work of transaction polling type: sync / async / callback\n *  genesisPublishingDisabled - genesis is publishing by default. Set `true` to prevent genesis publishing\n */\nexport type AuthBJJCredentialCreationOptions = {\n  revocationOpts: {\n    id: string;\n    type: CredentialStatusType;\n    nonce?: number;\n    genesisPublishingDisabled?: boolean;\n    onChain?: {\n      txCallback?: (tx: TransactionReceipt) => Promise<void>;\n      publishMode?: PublishMode;\n    };\n  };\n  seed?: Uint8Array;\n};\n\n/**\n * Options for creating Ethereum based identity\n */\nexport type EthereumBasedIdentityCreationOptions = IdentityCreationOptions & {\n  ethSigner?: Signer;\n  createBjjCredential?: boolean;\n};\n\n/**\n * Options for RevocationInfoOptions.\n */\nexport type RevocationInfoOptions = {\n  revokedNonces?: number[];\n  treeModel?: TreesModel;\n  rhsUrl?: string;\n  onChain?: {\n    txCallback?: (tx: TransactionReceipt) => Promise<void>;\n    publishMode?: PublishMode;\n  };\n};\n\n/**\n *  Proof creation result\n *\n * @public\n * @interface   Iden3ProofCreationResult\n */\nexport interface Iden3ProofCreationResult {\n  credentials: W3CCredential[];\n  oldTreeState: TreeState;\n  newTreeState: TreeState;\n}\n/**\n * Interface for IdentityWallet\n * @public\n */\nexport interface IIdentityWallet {\n  /**\n   * Create Identity creates Auth BJJ credential,\n   * Merkle trees for claims, revocations and root of roots,\n   * adds auth BJJ credential to claims tree and generates mtp of inclusion\n   * based on the resulting state it provides an identifier in DID form.\n   *\n   * @param {IdentityCreationOptions} opts - default is did:iden3:polygon:amoy** with generated key.\n   * @returns `Promise<{ did: DID; credential: W3CCredential }>` - returns did and Auth BJJ credential\n   * @public\n   */\n  createIdentity(opts: IdentityCreationOptions): Promise<{ did: DID; credential: W3CCredential }>;\n\n  /**\n   *  Credential wallet getter\n   *\n   * @returns  {ICredentialWallet}\n   * @memberof IIdentityWallet\n   */\n  get credentialWallet(): ICredentialWallet;\n\n  /**\n   * Create Identity based in Ethereum address and it provides an identifier in DID form.\n   *\n   * @param {IdentityCreationOptions} opts - default is did:iden3:polygon:amoy** with generated key.\n   * @returns `Promise<{ did: DID; credential: W3CCredential | undefined }>` - returns did and Auth BJJ credential\n   * @public\n   */\n  createEthereumBasedIdentity(\n    opts: EthereumBasedIdentityCreationOptions\n  ): Promise<{ did: DID; credential: W3CCredential | undefined }>;\n\n  /**\n   * Creates profile based on genesis identifier\n   *\n   * @param {DID} did - identity to derive profile from\n   * @param {number |string} nonce - unique integer number to generate a profile\n   * @param {string} verifier - verifier identity/alias in a string from\n   * @param {string[]} tags      - optional tag that can be assigned to profile by client\n   * @returns `Promise<DID>` - profile did\n   */\n  createProfile(did: DID, nonce: number | string, verifier: string, tags?: string[]): Promise<DID>;\n\n  /**\n   * Generates a new key\n   *\n   * @param {KmsKeyType} keyType - supported key type by KMS\n   * @returns `Promise<KmsKeyId>` - creates a new key BJJ or ECDSA\n   */\n  generateKey(keyType: KmsKeyType): Promise<KmsKeyId>;\n\n  /**\n   * Issues new credential from issuer according to the claim request\n   *\n   * @param {DID} issuerDID - issuer identity\n   * @param {CredentialRequest} req - claim request\n   * @returns `Promise<W3CCredential>` - returns created W3CCredential\n   */\n  issueCredential(issuerDID: DID, req: CredentialRequest, opts?: Options): Promise<W3CCredential>;\n\n  /**\n   * Gets a tree model for given did that includes claims tree, revocation tree, the root of roots tree and calculated state hash\n   *\n   * @param {DID} did - did which trees info we need to receive\n   * @returns `Promise<TreesModel>`\n   * */\n  getDIDTreeModel(did: DID): Promise<TreesModel>;\n\n  /**\n   * Generates proof of credential inclusion / non-inclusion to the given claims tree\n   * and its root or to the current root of the Claims tree in the given Merkle tree storage.\n   *\n   * @param {DID} did - issuer did\n   * @param {W3CCredential} credential - credential to generate mtp\n   * @param {TreeState} [treeState] - tree state when to generate a proof\n   * @returns `Promise<MerkleTreeProofWithTreeState>` - MerkleTreeProof and TreeState on which proof has been generated\n   */\n  generateCredentialMtp(\n    did: DID,\n    credential: W3CCredential,\n    treeState?: TreeState\n  ): Promise<MerkleTreeProofWithTreeState>;\n\n  /**\n   * Generates proof of core claim inclusion / non-inclusion to the given claims tree\n   * and its root or to the current root of the Claims tree in the given Merkle tree storage.\n   *\n   * @param {DID} did - issuer did\n   * @param {core.Claim} core - core claim to generate mtp\n   * @param {TreeState} [treeState] - tree state when to generate a proof\n   * @returns `Promise<MerkleTreeProofWithTreeState>` - MerkleTreeProof and TreeState on which proof has been generated\n   */\n  generateCoreClaimMtp(\n    did: DID,\n    coreClaim: Claim,\n    treeState?: TreeState\n  ): Promise<MerkleTreeProofWithTreeState>;\n\n  /**\n   * Generates proof of credential revocation nonce (with credential as a param) inclusion / non-inclusion to the given revocation tree\n   * and its root or to the current root of the Revocation tree in the given Merkle tree storage.\n   *\n   * @param {DID} did\n   * @param {W3CCredential} credential\n   * @param {TreeState} [treeState]\n   * @returns `Promise<MerkleTreeProofWithTreeState>` -  MerkleTreeProof and TreeState on which proof has been generated\n   */\n  generateNonRevocationMtp(\n    did: DID,\n    credential: W3CCredential,\n    treeState?: TreeState\n  ): Promise<MerkleTreeProofWithTreeState>;\n\n  /**\n   * Generates proof of credential revocation nonce (with revNonce as a param) inclusion / non-inclusion to the given revocation tree\n   * and its root or to the current root of the Revocation tree in the given Merkle tree storage.\n   *\n   * @param {DID} did\n   * @param {bigint} revNonce\n   * @param {TreeState} [treeState]\n   * @returns `Promise<MerkleTreeProofWithTreeState>` -  MerkleTreeProof and TreeState on which proof has been generated\n   */\n  generateNonRevocationMtpWithNonce(\n    did: DID,\n    revNonce: bigint,\n    treeState?: TreeState\n  ): Promise<MerkleTreeProofWithTreeState>;\n\n  /**\n   * Signs a payload of arbitrary size with an Auth BJJ Credential that identifies a key for signing.\n   *\n   * @param {Uint8Array} payload\n   * @param {W3CCredential} credential - Auth BJJ Credential\n   * @returns `Promise<Signature>`-  the signature object with R8 and S params\n   */\n  sign(payload: Uint8Array, credential: W3CCredential): Promise<Signature>;\n\n  /**\n   * Signs a big integer with an Auth BJJ Credential that identifies a key for signing.\n   *\n   *\n   * @param {bigint} payload - big number in Field\n   * @param {W3CCredential} credential - Auth BJJ credential\n   * @returns `Promise<Signature>` - the signature object with R8 and S params\n   */\n  signChallenge(payload: bigint, credential: W3CCredential): Promise<Signature>;\n\n  /**\n   *\n   *\n   * @param {DID} issuerDID  - identifier of the issuer\n   * @param {W3CCredential} credential - credential to revoke\n   * @returns `Promise<number>` a revocation nonce of credential\n   */\n  revokeCredential(issuerDID: DID, credential: W3CCredential): Promise<number>;\n\n  /**\n   * Generate Iden3SparseMerkleTree proof of inclusion to issuer state of specific credentials\n   *\n   * @param {DID} issuerDID - issuer did\n   * @param {W3CCredential[]} credentials - list of verifiable credentials to generate a proof\n   * @param {string} txId - transaction hash in which state transition has been done\n   * @param {number} [blockNumber] - block number in which state transition has been done\n   * @param {number} [blockTimestamp] - block timestamp in which state transition has been done\n   * @returns `Promise<W3CCredential[]>` credentials with an Iden3SparseMerkleTreeProof\n   */\n  generateIden3SparseMerkleTreeProof(\n    issuerDID: DID,\n    credentials: W3CCredential[],\n    txId: string,\n    blockNumber?: number,\n    blockTimestamp?: number\n  ): Promise<W3CCredential[]>;\n\n  /**\n   * Adds verifiable credentials to issuer Claims Merkle tree\n   *\n   * @param {W3CCredential[]} credentials - credentials to include in the claims tree\n   * @param {DID} issuerDID - issuer did\n   * @returns `Promise<Iden3ProofCreationResult>`- old tree state and tree state with included credentials\n   */\n  addCredentialsToMerkleTree(\n    credentials: W3CCredential[],\n    issuerDID: DID\n  ): Promise<Iden3ProofCreationResult>;\n\n  /**\n   * Publishes issuer state to the reverse hash service by given URL\n   *\n   * @deprecated use publishRevocationInfoByCredentialStatusType instead with the same arguments in opts\n   * @param {DID} issuerDID - issuer did\n   * @param {string} rhsURL - reverse hash service URL\n   * @param {number[]} [revokedNonces] - revoked nonces for the period from the last published\n   * @returns `Promise<void>`\n   */\n  publishStateToRHS(\n    issuerDID: DID,\n    rhsURL: string,\n    revokedNonces?: number[],\n    opts?: object\n  ): Promise<void>;\n\n  /**\n   * Publishes specific state to the reverse hash service by given URL\n   * @deprecated use publishRevocationInfoByCredentialStatusType instead with the same arguments in opts\n   * @param {TreesModel} treeModel - trees model to publish\n   * @param {string} rhsURL - reverse hash service URL\n   * @param {number[]} [revokedNonces] - revoked nonces for the period from the last published\n   * @returns `Promise<void>`\n   */\n  publishSpecificStateToRHS(\n    treeModel: TreesModel,\n    rhsURL: string,\n    revokedNonces?: number[],\n    opts?: object\n  ): Promise<void>;\n\n  /**\n   * Publishes revocation info by credential status predefined publishers\n   *\n   * @param {(RevocationInfoOptions)} opts\n   * @returns {Promise<void>}\n   * @memberof IIdentityWallet\n   */\n  publishRevocationInfoByCredentialStatusType(\n    issuerDID: DID,\n    credentialStatusType: CredentialStatusType,\n    opts?: RevocationInfoOptions\n  ): Promise<void>;\n\n  /**\n   * Extracts core claim from signature or merkle tree proof. If both proof persists core claim must be the same\n   *\n   * @public\n   * @param {W3CCredential} credential - credential to extract core claim\n   * @returns `{Promise<Claim>}`\n   */\n  getCoreClaimFromCredential(credential: W3CCredential): Promise<Claim>;\n\n  /**\n   *\n   * gets profile identity by genesis identifiers\n   *\n   * @param {DID} did - genesis identifier from which profile has been derived\n   * @returns `{Promise<Profile[]>}`\n   */\n  getProfilesByDID(did: DID): Promise<Profile[]>;\n\n  /**\n   *\n   * gets profile nonce by it's id. if profile is genesis identifier - 0 is returned\n   *\n   * @param {DID} did -  profile that has been derived or genesis identity\n   * @returns `{Promise<{nonce:number, genesisIdentifier: DID}>}`\n   */\n  getGenesisDIDMetadata(did: DID): Promise<{ nonce: number | string; genesisDID: DID }>;\n\n  /**\n   *\n   * find all credentials that belong to any profile or genesis identity for the given did\n   *\n   * @param {DID} did -  profile that has been derived or genesis identity\n   * @returns `{Promise<W3CCredential[]>}`\n   */\n  findOwnedCredentialsByDID(did: DID, query: ProofQuery): Promise<W3CCredential[]>;\n  /**\n   *\n   * gets profile identity by verifier\n   * @deprecated The method should not be used. It returns only one profile per verifier, which can potentially restrict business use cases\n   * @param {string} verifier -  identifier of the verifier\n   * @returns `{Promise<Profile>}`\n   */\n  getProfileByVerifier(verifier: string): Promise<Profile | undefined>;\n\n  /**\n   * gets profile by verifiers\n   *\n   * @param {string} verifier - verifier to which profile has been shared\n   * @param {string} tags - optional, tags to filter profile entry\n   * @returns `{Promise<Profile[]>}`\n   */\n  getProfilesByVerifier(verifier: string, tags?: string[]): Promise<Profile[]>;\n\n  /**\n   *\n   * updates latest identity state in storage with given state or latest from the trees.\n   *\n   * @param {DID} issuerDID -  identifier of the issuer\n   * @param {boolean} published - if states is published onchain\n   * @param {TreeState} treeState -  contains state to upgrade\n   * @returns `{Promise<void>}`\n   */\n  updateIdentityState(issuerDID: DID, published: boolean, treeState?: TreeState): Promise<void>;\n\n  /**\n   *\n   * gets actual auth credential with proofs for provided tree state or latest from the trees.\n   *\n   * @param {DID} issuerDID -  identifier of the issuer\n   * @param {TreeState} treeStateInfo -  optional, state for retrieval\n   * @returns `{Promise<{\n      authCredential: W3CCredential;\n      incProof: MerkleTreeProofWithTreeState;\n      nonRevProof: MerkleTreeProofWithTreeState;\n    }>}`\n   */\n  getActualAuthCredential(\n    did: DID,\n    treeStateInfo?: TreeState\n  ): Promise<{\n    authCredential: W3CCredential;\n    incProof: MerkleTreeProofWithTreeState;\n    nonRevProof: MerkleTreeProofWithTreeState;\n  }>;\n\n  /**\n   * Transit state for the identity with the given DID\n   *\n   * @param {DID} did - identifier of the user\n   * @param {TreeState} oldTreeState - old state of the user\n   * @param {boolean} isOldStateGenesis  - if the old state is genesis\n   * @param {IStateStorage} stateStorage - storage to save the new state\n   * @param {Signer} ethSigner - signer to sign the transaction\n   */\n  transitState(\n    did: DID,\n    oldTreeState: TreeState,\n    isOldStateGenesis: boolean,\n    ethSigner: Signer,\n    prover?: IZKProver\n  ): Promise<string>;\n\n  /**\n   * Add BJJ credential and transit state\n   *\n   * @param {DID} did - identifier of the user\n   * @param {TreeState} oldTreeState - old tree state of the user\n   * @param {boolean} isOldTreeState - if the old state is genesis\n   * @param {Signer} ethSigner - signer to sign the transaction\n   * @param {AuthBJJCredentialCreationOptions} opts - additional options\n   */\n  addBJJAuthCredential(\n    did: DID,\n    oldTreeState: TreeState,\n    isOldTreeStateGenesis: boolean,\n    ethSigner: Signer,\n    opts?: AuthBJJCredentialCreationOptions\n  ): Promise<W3CCredential>;\n}\n\n/**\n * @public\n * Wallet instance to manage the digital identity based on iden3 protocol\n * allows to: create identity/profile, sign payloads (bigint / bytes), generate keys,\n * generate Merkle tree proofs of inclusion / non-inclusion to Merkle trees, issue credentials with a BJJSignature and Iden3SparseMerkleTree Proofs,\n * revoke credentials, add credentials to Merkle trees, push states to reverse hash service\n *\n *\n * @class IdentityWallet - class\n * @implements implements IIdentityWallet interface\n */\nexport class IdentityWallet implements IIdentityWallet {\n  private readonly _credentialStatusPublisherRegistry: CredentialStatusPublisherRegistry;\n  private readonly _inputsGenerator: InputGenerator;\n  private readonly _transactionService: ITransactionService;\n\n  /**\n   * Constructs a new instance of the `IdentityWallet` class\n   *\n   * @param {KMS} _kms - Key Management System that allows signing data with BJJ key\n   * @param {IDataStorage} _storage - data storage to access credential / identity / Merkle tree data\n   * @param {ICredentialWallet} _credentialWallet - credential wallet instance to quickly access credential CRUD functionality\n   * @public\n   */\n  public constructor(\n    private readonly _kms: KMS,\n    private readonly _storage: IDataStorage,\n    private readonly _credentialWallet: ICredentialWallet,\n    private readonly _opts?: {\n      credentialStatusPublisherRegistry?: CredentialStatusPublisherRegistry;\n    }\n  ) {\n    this._credentialStatusPublisherRegistry = this.getCredentialStatusPublisherRegistry(_opts);\n    this._inputsGenerator = new InputGenerator(this, _credentialWallet, _storage.states);\n    this._transactionService = new TransactionService(_storage.states.getRpcProvider());\n  }\n\n  get credentialWallet(): ICredentialWallet {\n    return this._credentialWallet;\n  }\n\n  private getCredentialStatusPublisherRegistry(\n    _opts:\n      | { credentialStatusPublisherRegistry?: CredentialStatusPublisherRegistry | undefined }\n      | undefined\n  ): CredentialStatusPublisherRegistry {\n    if (!_opts?.credentialStatusPublisherRegistry) {\n      const registry = new CredentialStatusPublisherRegistry();\n      const emptyPublisher = { publish: () => Promise.resolve() };\n      registry.register(\n        CredentialStatusType.Iden3ReverseSparseMerkleTreeProof,\n        new Iden3SmtRhsCredentialStatusPublisher()\n      );\n      registry.register(CredentialStatusType.SparseMerkleTreeProof, emptyPublisher);\n      registry.register(CredentialStatusType.Iden3commRevocationStatusV1, emptyPublisher);\n      return registry;\n    } else {\n      return this._opts?.credentialStatusPublisherRegistry as CredentialStatusPublisherRegistry;\n    }\n  }\n\n  private async createAuthCoreClaim(\n    revNonce: number,\n    seed: Uint8Array\n  ): Promise<{ authClaim: Claim; pubKey: PublicKey }> {\n    const keyId = await this._kms.createKeyFromSeed(KmsKeyType.BabyJubJub, seed);\n    const pubKeyHex = await this._kms.publicKey(keyId);\n    const pubKey = PublicKey.newFromHex(pubKeyHex);\n\n    const schemaHash = SchemaHash.authSchemaHash;\n\n    const authClaim = Claim.newClaim(\n      schemaHash,\n      ClaimOptions.withIndexDataInts(pubKey.p[0], pubKey.p[1]),\n      ClaimOptions.withRevocationNonce(BigInt(0))\n    );\n    authClaim.setRevocationNonce(BigInt(revNonce));\n\n    return { authClaim, pubKey };\n  }\n\n  private async createAuthBJJCredential(\n    did: DID,\n    pubKey: PublicKey,\n    authClaim: Claim,\n    currentState: Hash,\n    revocationOpts: { id: string; type: CredentialStatusType }\n  ): Promise<W3CCredential> {\n    const authData = authClaim.getExpirationDate();\n    const expiration = authData ? getUnixTimestamp(authData) : 0;\n\n    const request: CredentialRequest = {\n      credentialSchema: VerifiableConstants.AUTH.AUTH_BJJ_CREDENTIAL_SCHEMA_JSON_URL,\n      type: VerifiableConstants.AUTH.AUTH_BJJ_CREDENTIAL_TYPE,\n      credentialSubject: {\n        x: pubKey.p[0].toString(),\n        y: pubKey.p[1].toString()\n      },\n      subjectPosition: subjectPositionIndex(authClaim.getIdPosition()),\n      version: 0,\n      expiration,\n      revocationOpts: {\n        nonce: Number(authClaim.getRevocationNonce()),\n        id: revocationOpts.id.replace(/\\/$/, ''),\n        type: revocationOpts.type,\n        issuerState: currentState.hex()\n      }\n    };\n\n    // Check if has already an auth credential\n    const authCredentials = await this._credentialWallet.getAllAuthBJJCredentials(did);\n\n    let credential: W3CCredential = new W3CCredential();\n    if (authCredentials.length === 0) {\n      const schema = JSON.parse(VerifiableConstants.AUTH.AUTH_BJJ_CREDENTIAL_SCHEMA_JSON);\n      try {\n        credential = this._credentialWallet.createCredential(did, request, schema);\n      } catch (e) {\n        throw new Error(`Error create w3c credential ${(e as Error).message}`);\n      }\n    } else {\n      // credential with sigProof signed with previous auth bjj credential\n      credential = await this.issueCredential(did, request);\n    }\n    return credential;\n  }\n\n  /**\n   * {@inheritDoc IIdentityWallet.createIdentity}\n   */\n  async createIdentity(\n    opts: IdentityCreationOptions\n  ): Promise<{ did: DID; credential: W3CCredential }> {\n    const tmpIdentifier = opts.seed ? uuid.v5(Hex.encode(sha256(opts.seed)), uuid.NIL) : uuid.v4();\n    opts.seed = opts.seed ?? getRandomBytes(32);\n\n    await this._storage.mt.createIdentityMerkleTrees(tmpIdentifier);\n\n    const revNonce = opts.revocationOpts.nonce ?? 0;\n\n    const { authClaim, pubKey } = await this.createAuthCoreClaim(revNonce, opts.seed);\n\n    const { hi, hv } = authClaim.hiHv();\n    await this._storage.mt.addToMerkleTree(tmpIdentifier, MerkleTreeType.Claims, hi, hv);\n\n    const claimsTree = await this._storage.mt.getMerkleTreeByIdentifierAndType(\n      tmpIdentifier,\n      MerkleTreeType.Claims\n    );\n\n    const ctr = await claimsTree.root();\n\n    const currentState = hashElems([ctr.bigInt(), ZERO_HASH.bigInt(), ZERO_HASH.bigInt()]);\n\n    const didType = buildDIDType(\n      opts.method || DidMethod.Iden3,\n      opts.blockchain || Blockchain.Polygon,\n      opts.networkId || NetworkId.Amoy\n    );\n    const identifier = Id.idGenesisFromIdenState(didType, currentState.bigInt());\n    const did = DID.parseFromId(identifier);\n\n    await this._storage.mt.bindMerkleTreeToNewIdentifier(tmpIdentifier, did.string());\n\n    const oldTreeState = {\n      revocationRoot: ZERO_HASH,\n      claimsRoot: ctr,\n      state: currentState,\n      rootOfRoots: ZERO_HASH\n    };\n\n    const identity = await this._storage.identity.getIdentity(did.string());\n    if (!identity) {\n      await this._storage.identity.saveIdentity({\n        did: did.string(),\n        state: currentState,\n        isStatePublished: false,\n        isStateGenesis: true\n      });\n    }\n\n    // check whether we have auth credential, if not - create a new one\n    const credentials = await this._credentialWallet.findByQuery({\n      credentialSubject: {\n        x: {\n          $eq: pubKey.p[0].toString()\n        },\n        y: {\n          $eq: pubKey.p[1].toString()\n        }\n      },\n      allowedIssuers: [did.string()]\n    });\n\n    // if credential exists with the same credential status type we return this credential\n    if (\n      credentials.length === 1 &&\n      credentials[0].credentialStatus.type === opts.revocationOpts.type\n    ) {\n      return {\n        did,\n        credential: credentials[0]\n      };\n    }\n\n    // otherwise something is already wrong with storage as it has more than 1 credential in it or credential status type of existing credential is different from what user provides - We should remove everything and create new credential.\n    // in this way credential status of auth credential can be upgraded\n    for (let i = 0; i < credentials.length; i++) {\n      await this._credentialWallet.remove(credentials[i].id);\n    }\n\n    // otherwise  we create a new credential\n    const credential = await this.createAuthBJJCredential(\n      did,\n      pubKey,\n      authClaim,\n      currentState,\n      opts.revocationOpts\n    );\n\n    const index = authClaim.hIndex();\n    const { proof } = await claimsTree.generateProof(index, ctr);\n\n    const mtpProof: Iden3SparseMerkleTreeProof = new Iden3SparseMerkleTreeProof({\n      mtp: proof,\n      issuerData: {\n        id: did,\n        state: {\n          rootOfRoots: oldTreeState.rootOfRoots,\n          revocationTreeRoot: oldTreeState.revocationRoot,\n          claimsTreeRoot: ctr,\n          value: currentState\n        }\n      },\n      coreClaim: authClaim\n    });\n\n    credential.proof = [mtpProof];\n\n    // only if user specified that genesis state publishing is not needed we won't do this.\n    if (!opts.revocationOpts.genesisPublishingDisabled) {\n      await this.publishRevocationInfoByCredentialStatusType(did, opts.revocationOpts.type, {\n        rhsUrl: opts.revocationOpts.id,\n        onChain: opts.revocationOpts.onChain\n      });\n    }\n\n    await this._credentialWallet.save(credential);\n\n    return {\n      did,\n      credential\n    };\n  }\n\n  /**\n   * {@inheritDoc IIdentityWallet.createEthereumBasedIdentity}\n   */\n  async createEthereumBasedIdentity(\n    opts: EthereumBasedIdentityCreationOptions\n  ): Promise<{ did: DID; credential: W3CCredential | undefined }> {\n    opts.seed = opts.seed ?? getRandomBytes(32);\n    opts.createBjjCredential = opts.createBjjCredential ?? true;\n\n    let credential;\n    const ethSigner = opts.ethSigner;\n\n    if (opts.createBjjCredential && !ethSigner) {\n      throw new Error(VerifiableConstants.ERRORS.ID_WALLET_SIGNER_IS_REQUIRED);\n    }\n\n    const currentState = ZERO_HASH; // In Ethereum identities we don't have an initial state with the auth credential\n\n    const didType = buildDIDType(\n      opts.method || DidMethod.Iden3,\n      opts.blockchain || Blockchain.Polygon,\n      opts.networkId || NetworkId.Amoy\n    );\n\n    const keyIdEth = await this._kms.createKeyFromSeed(KmsKeyType.Secp256k1, opts.seed);\n    const pubKeyHexEth = (await this._kms.publicKey(keyIdEth)).slice(2); // 04 + x + y (uncompressed key)\n    const did = buildDIDFromEthPubKey(didType, pubKeyHexEth);\n\n    await this._storage.mt.createIdentityMerkleTrees(did.string());\n\n    await this._storage.identity.saveIdentity({\n      did: did.string(),\n      state: currentState,\n      isStatePublished: false,\n      isStateGenesis: true\n    });\n\n    if (opts.createBjjCredential && ethSigner) {\n      // Old tree state genesis state\n      const oldTreeState: TreeState = {\n        revocationRoot: ZERO_HASH,\n        claimsRoot: ZERO_HASH,\n        state: currentState,\n        rootOfRoots: ZERO_HASH\n      };\n\n      credential = await this.addBJJAuthCredential(did, oldTreeState, true, ethSigner, opts);\n    }\n\n    return {\n      did,\n      credential\n    };\n  }\n\n  /** {@inheritDoc IIdentityWallet.getGenesisDIDMetadata} */\n  async getGenesisDIDMetadata(did: DID): Promise<{ nonce: number | string; genesisDID: DID }> {\n    // check if it is a genesis identity\n    const identity = await this._storage.identity.getIdentity(did.string());\n\n    if (identity) {\n      return { nonce: 0, genesisDID: DID.parse(identity.did) };\n    }\n    const profile = await this._storage.identity.getProfileById(did.string());\n\n    if (!profile) {\n      throw new Error(VerifiableConstants.ERRORS.ID_WALLET_PROFILE_OR_IDENTITY_NOT_FOUND);\n    }\n    return { nonce: profile.nonce, genesisDID: DID.parse(profile.genesisIdentifier) };\n  }\n\n  /** {@inheritDoc IIdentityWallet.createProfile} */\n  async createProfile(\n    did: DID,\n    nonce: number | string,\n    verifier: string,\n    tags?: string[]\n  ): Promise<DID> {\n    const profileDID = generateProfileDID(did, nonce);\n\n    const identityProfiles = await this._storage.identity.getProfilesByGenesisIdentifier(\n      did.string()\n    );\n\n    const profilesForTagAndVerifier = await this._storage.identity.getProfilesByVerifier(\n      verifier,\n      tags\n    );\n    if (profilesForTagAndVerifier.length) {\n      throw new Error(VerifiableConstants.ERRORS.ID_WALLET_PROFILE_ALREADY_EXISTS_VERIFIER_TAGS);\n    }\n\n    const existingProfileWithNonce = identityProfiles.find((p) => p.nonce == nonce);\n    if (existingProfileWithNonce) {\n      throw new Error(VerifiableConstants.ERRORS.ID_WALLET_PROFILE_ALREADY_EXISTS);\n    }\n\n    await this._storage.identity.saveProfile({\n      id: profileDID.string(),\n      nonce,\n      genesisIdentifier: did.string(),\n      verifier,\n      tags\n    });\n\n    return profileDID;\n  }\n\n  /**\n   *\n   * gets profile identity by genesis identifiers\n   *\n   * @param {string} genesisIdentifier - genesis identifier from which profile has been derived\n   * @returns `{Promise<Profile[]>}`\n   */\n  async getProfilesByDID(did: DID): Promise<Profile[]> {\n    return this._storage.identity.getProfilesByGenesisIdentifier(did.string());\n  }\n  /** {@inheritDoc IIdentityWallet.generateKey} */\n  async generateKey(keyType: KmsKeyType): Promise<KmsKeyId> {\n    const key = await this._kms.createKeyFromSeed(keyType, getRandomBytes(32));\n    return key;\n  }\n  /**\n   * @deprecated The method should not be used. It returns only one profile per verifier, which can potentially restrict business use cases\n   * {@inheritDoc IIdentityWallet.getProfileByVerifier}\n   */\n  async getProfileByVerifier(verifier: string): Promise<Profile | undefined> {\n    return this._storage.identity.getProfileByVerifier(verifier);\n  }\n\n  /** {@inheritDoc IIdentityWallet.getProfilesByVerifier} */\n  async getProfilesByVerifier(verifier: string, tags?: string[]): Promise<Profile[]> {\n    return this._storage.identity.getProfilesByVerifier(verifier, tags);\n  }\n\n  /** {@inheritDoc IIdentityWallet.getDIDTreeModel} */\n  async getDIDTreeModel(did: DID): Promise<TreesModel> {\n    const didStr = did.string();\n    const claimsTree = await this._storage.mt.getMerkleTreeByIdentifierAndType(\n      didStr,\n      MerkleTreeType.Claims\n    );\n    const revocationTree = await this._storage.mt.getMerkleTreeByIdentifierAndType(\n      didStr,\n      MerkleTreeType.Revocations\n    );\n    const rootsTree = await this._storage.mt.getMerkleTreeByIdentifierAndType(\n      didStr,\n      MerkleTreeType.Roots\n    );\n    const state = hashElems([\n      (await claimsTree.root()).bigInt(),\n      (await revocationTree.root()).bigInt(),\n      (await rootsTree.root()).bigInt()\n    ]);\n\n    return {\n      state,\n      claimsTree,\n      revocationTree,\n      rootsTree\n    };\n  }\n\n  /** {@inheritDoc IIdentityWallet.generateClaimMtp} */\n  async generateCredentialMtp(\n    did: DID,\n    credential: W3CCredential,\n    treeState?: TreeState\n  ): Promise<MerkleTreeProofWithTreeState> {\n    const coreClaim = await this.getCoreClaimFromCredential(credential);\n    return this.generateCoreClaimMtp(did, coreClaim, treeState);\n  }\n\n  /** {@inheritDoc IIdentityWallet.generateClaimMtp} */\n  async generateCoreClaimMtp(\n    did: DID,\n    coreClaim: Claim,\n    treeState?: TreeState\n  ): Promise<MerkleTreeProofWithTreeState> {\n    const treesModel = await this.getDIDTreeModel(did);\n\n    const claimsTree = await this._storage.mt.getMerkleTreeByIdentifierAndType(\n      did.string(),\n      MerkleTreeType.Claims\n    );\n\n    const claimsRoot = await treesModel.claimsTree.root();\n    const rootOfRoots = await treesModel.rootsTree.root();\n    const revocationRoot = await treesModel.revocationTree.root();\n    const { proof } = await claimsTree.generateProof(\n      coreClaim.hIndex(),\n      treeState ? treeState.claimsRoot : claimsRoot\n    );\n\n    return {\n      proof,\n      treeState: treeState ?? {\n        state: treesModel.state,\n        claimsRoot,\n        rootOfRoots,\n        revocationRoot\n      }\n    };\n  }\n\n  /** {@inheritDoc IIdentityWallet.generateNonRevocationMtp} */\n  async generateNonRevocationMtp(\n    did: DID,\n    credential: W3CCredential,\n    treeState?: TreeState\n  ): Promise<MerkleTreeProofWithTreeState> {\n    const coreClaim = await this.getCoreClaimFromCredential(credential);\n\n    const revNonce = coreClaim.getRevocationNonce();\n    return this.generateNonRevocationMtpWithNonce(did, revNonce, treeState);\n  }\n\n  /** {@inheritDoc IIdentityWallet.generateNonRevocationMtpWithNonce} */\n  async generateNonRevocationMtpWithNonce(\n    did: DID,\n    revNonce: bigint,\n    treeState?: TreeState\n  ): Promise<MerkleTreeProofWithTreeState> {\n    const treesModel = await this.getDIDTreeModel(did);\n\n    const revocationTree = await this._storage.mt.getMerkleTreeByIdentifierAndType(\n      did.string(),\n      MerkleTreeType.Revocations\n    );\n\n    const claimsRoot = await treesModel.claimsTree.root();\n    const rootOfRoots = await treesModel.rootsTree.root();\n    const revocationRoot = await treesModel.revocationTree.root();\n    const { proof } = await revocationTree.generateProof(\n      revNonce,\n      treeState ? treeState.revocationRoot : revocationRoot\n    );\n\n    return {\n      proof,\n      treeState: treeState ?? {\n        state: treesModel.state,\n        claimsRoot,\n        rootOfRoots,\n        revocationRoot\n      }\n    };\n  }\n\n  /** {@inheritDoc IIdentityWallet.sign} */\n  async sign(message: Uint8Array, credential: W3CCredential): Promise<Signature> {\n    const keyKMSId = getKMSIdByAuthCredential(credential);\n    const payload = poseidon.hashBytes(message);\n\n    const signature = await this._kms.sign(keyKMSId, BytesHelper.intToBytes(payload));\n\n    return Signature.newFromCompressed(signature);\n  }\n\n  /** {@inheritDoc IIdentityWallet.signChallenge} */\n  async signChallenge(challenge: bigint, credential: W3CCredential): Promise<Signature> {\n    const keyKMSId = getKMSIdByAuthCredential(credential);\n\n    const signature = await this._kms.sign(keyKMSId, BytesHelper.intToBytes(challenge));\n\n    return Signature.newFromCompressed(signature);\n  }\n\n  /** {@inheritDoc IIdentityWallet.issueCredential} */\n  async issueCredential(\n    issuerDID: DID,\n    req: CredentialRequest,\n    opts?: Options\n  ): Promise<W3CCredential> {\n    req.revocationOpts.id = req.revocationOpts.id.replace(/\\/$/, '');\n\n    let schema: object;\n\n    const loader = opts?.documentLoader ?? cacheLoader(opts);\n    try {\n      schema = (await loader(req.credentialSchema)).document;\n    } catch (e) {\n      throw new Error(`can't load credential schema ${req.credentialSchema}`);\n    }\n\n    const jsonSchema = schema as JSONSchema;\n    let credential: W3CCredential = new W3CCredential();\n\n    const issuerRoots = await this.getDIDTreeModel(issuerDID);\n    req.revocationOpts.issuerState = issuerRoots.state.hex();\n\n    req.revocationOpts.nonce =\n      typeof req.revocationOpts.nonce === 'number'\n        ? req.revocationOpts.nonce\n        : new DataView(getRandomBytes(16).buffer).getUint32(0, false);\n\n    req.subjectPosition = req.subjectPosition ?? SubjectPosition.Index;\n\n    try {\n      credential = this._credentialWallet.createCredential(issuerDID, req, jsonSchema);\n\n      const encodedCred = byteEncoder.encode(JSON.stringify(credential));\n      const encodedSchema = byteEncoder.encode(JSON.stringify(schema));\n\n      await new JsonSchemaValidator().validate(encodedCred, encodedSchema);\n    } catch (e) {\n      throw new Error(`Error create w3c credential ${(e as Error).message}`);\n    }\n\n    const { authCredential: issuerAuthBJJCredential } = await this.getActualAuthCredential(\n      issuerDID\n    );\n\n    const coreClaimOpts: CoreClaimCreationOptions = {\n      revNonce: req.revocationOpts.nonce,\n      subjectPosition: req.subjectPosition,\n      merklizedRootPosition: req.merklizedRootPosition ?? MerklizedRootPosition.None,\n      updatable: false,\n      version: 0,\n      merklizeOpts: { ...opts, documentLoader: loader }\n    };\n\n    const coreClaim = await credential.toCoreClaim(coreClaimOpts);\n\n    const { hi, hv } = coreClaim.hiHv();\n\n    const coreClaimHash = poseidon.hash([hi, hv]);\n\n    const signature = await this.signChallenge(coreClaimHash, issuerAuthBJJCredential);\n\n    if (!issuerAuthBJJCredential.proof) {\n      throw new Error(\n        VerifiableConstants.ERRORS.ID_WALLET_ISSUER_AUTH_BJJ_CRED_MUST_HAVE_ANY_PROOF\n      );\n    }\n\n    const mtpAuthBJJProof = issuerAuthBJJCredential.getIden3SparseMerkleTreeProof();\n    if (!mtpAuthBJJProof) {\n      throw new Error(\n        VerifiableConstants.ERRORS.ID_WALLET_ISSUER_AUTH_BJJ_CRED_MUST_HAVE_MTP_PROOF\n      );\n    }\n\n    const sigProof = new BJJSignatureProof2021({\n      issuerData: {\n        id: issuerDID,\n        state: mtpAuthBJJProof.issuerData.state,\n        authCoreClaim: mtpAuthBJJProof.coreClaim,\n        mtp: mtpAuthBJJProof.mtp,\n        credentialStatus: issuerAuthBJJCredential.credentialStatus\n      },\n      coreClaim,\n      signature\n    });\n    credential.proof = [sigProof];\n\n    return credential;\n  }\n\n  /** {@inheritDoc IIdentityWallet.getActualAuthCredential} */\n  async getActualAuthCredential(\n    did: DID,\n    treeStateInfo?: TreeState\n  ): Promise<{\n    authCredential: W3CCredential;\n    incProof: MerkleTreeProofWithTreeState;\n    nonRevProof: MerkleTreeProofWithTreeState;\n  }> {\n    const authCredentials = await this._credentialWallet.getAllAuthBJJCredentials(did);\n    for (let i = 0; i < authCredentials.length; i++) {\n      const incProof = await this.generateCredentialMtp(did, authCredentials[i], treeStateInfo);\n\n      if (!incProof.proof.existence) {\n        continue;\n      }\n\n      const nonRevProof = await this.generateNonRevocationMtp(\n        did,\n        authCredentials[i],\n        treeStateInfo\n      );\n\n      if (!nonRevProof.proof.existence) {\n        return {\n          authCredential: authCredentials[i],\n          incProof,\n          nonRevProof\n        };\n      }\n    }\n\n    throw new Error(VerifiableConstants.ERRORS.NO_AUTH_CRED_FOUND);\n  }\n\n  /** {@inheritDoc IIdentityWallet.revokeCredential} */\n  async revokeCredential(issuerDID: DID, credential: W3CCredential): Promise<number> {\n    const issuerTree = await this.getDIDTreeModel(issuerDID);\n\n    const coreClaim = await this.getCoreClaimFromCredential(credential);\n\n    if (!coreClaim) {\n      throw new Error(VerifiableConstants.ERRORS.ID_WALLET_CORE_CLAIM_REQUIRED_IN_ANY_PROOF);\n    }\n    const nonce = coreClaim.getRevocationNonce();\n\n    await issuerTree.revocationTree.add(nonce, BigInt(0));\n\n    return Number(BigInt.asUintN(64, nonce));\n  }\n\n  /** {@inheritDoc IIdentityWallet.addCredentialsToMerkleTree} */\n  async addCredentialsToMerkleTree(\n    credentials: W3CCredential[],\n    issuerDID: DID\n  ): Promise<Iden3ProofCreationResult> {\n    const oldIssuerTree = await this.getDIDTreeModel(issuerDID);\n    let claimsRoot = await oldIssuerTree.claimsTree.root();\n    let rootOfRoots = await oldIssuerTree.rootsTree.root();\n    let revocationRoot = await oldIssuerTree.revocationTree.root();\n    const oldTreeState: TreeState = {\n      state: oldIssuerTree.state,\n      claimsRoot,\n      revocationRoot,\n      rootOfRoots\n    };\n\n    for (let index = 0; index < credentials.length; index++) {\n      const credential = credentials[index];\n\n      // credential must have a bjj signature proof\n      const coreClaim = credential.getCoreClaimFromProof(ProofType.BJJSignature);\n\n      if (!coreClaim) {\n        throw new Error(VerifiableConstants.ERRORS.ID_WALLET_CORE_CLAIM_REQUIRED_IN_SIG_PROOF);\n      }\n\n      await this._storage.mt.addToMerkleTree(\n        issuerDID.string(),\n        MerkleTreeType.Claims,\n        coreClaim.hIndex(),\n        coreClaim.hValue()\n      );\n    }\n\n    const newIssuerTreeState = await this.getDIDTreeModel(issuerDID);\n    const claimTreeRoot = await newIssuerTreeState.claimsTree.root();\n    await this._storage.mt.addToMerkleTree(\n      issuerDID.string(),\n      MerkleTreeType.Roots,\n      claimTreeRoot.bigInt(),\n      BigInt(0)\n    );\n    const newIssuerTreeStateWithROR = await this.getDIDTreeModel(issuerDID);\n\n    claimsRoot = await newIssuerTreeStateWithROR.claimsTree.root();\n    rootOfRoots = await newIssuerTreeStateWithROR.rootsTree.root();\n    revocationRoot = await newIssuerTreeStateWithROR.revocationTree.root();\n    return {\n      credentials,\n      newTreeState: {\n        state: newIssuerTreeStateWithROR.state,\n        claimsRoot,\n        rootOfRoots,\n        revocationRoot\n      },\n      oldTreeState: oldTreeState\n    };\n  }\n\n  /** {@inheritDoc IIdentityWallet.generateIden3SparseMerkleTreeProof} */\n  // treeState -  optional, if it is not passed proof of claim inclusion will be generated on the latest state in the tree.\n  async generateIden3SparseMerkleTreeProof(\n    issuerDID: DID,\n    credentials: W3CCredential[],\n    txId: string,\n    blockNumber?: number,\n    blockTimestamp?: number,\n    treeState?: TreeState,\n    opts?: CoreClaimCreationOptions\n  ): Promise<W3CCredential[]> {\n    for (let index = 0; index < credentials.length; index++) {\n      const credential = credentials[index];\n\n      // TODO: return coreClaim from generateCredentialMtp and use it below\n      // credential must have a bjj signature proof\n\n      const coreClaim =\n        credential.getCoreClaimFromProof(ProofType.BJJSignature) ||\n        (await credential.toCoreClaim(opts));\n\n      if (!coreClaim) {\n        throw new Error(VerifiableConstants.ERRORS.ID_WALLET_CORE_CLAIM_REQUIRED_IN_SIG_PROOF);\n      }\n      const mtpWithProof = await this.generateCoreClaimMtp(issuerDID, coreClaim, treeState);\n\n      const mtpProof: Iden3SparseMerkleTreeProof = new Iden3SparseMerkleTreeProof({\n        mtp: mtpWithProof.proof,\n        issuerData: {\n          id: issuerDID,\n          state: {\n            claimsTreeRoot: mtpWithProof.treeState.claimsRoot,\n            revocationTreeRoot: mtpWithProof.treeState.revocationRoot,\n            rootOfRoots: mtpWithProof.treeState.rootOfRoots,\n            value: mtpWithProof.treeState.state,\n            txId,\n            blockNumber,\n            blockTimestamp\n          }\n        },\n        coreClaim\n      });\n\n      if (Array.isArray(credentials[index].proof)) {\n        (credentials[index].proof as unknown[]).push(mtpProof);\n      } else {\n        credentials[index].proof = credentials[index].proof\n          ? [credentials[index].proof, mtpProof]\n          : [mtpProof];\n      }\n    }\n    return credentials;\n  }\n\n  /** {@inheritDoc IIdentityWallet.publishSpecificStateToRHS} */\n  async publishSpecificStateToRHS(\n    treeModel: TreesModel,\n    rhsURL: string,\n    revokedNonces?: number[]\n  ): Promise<void> {\n    await pushHashesToRHS(treeModel.state, treeModel, rhsURL, revokedNonces);\n  }\n\n  /** {@inheritDoc IIdentityWallet.publishStateToRHS} */\n  async publishStateToRHS(issuerDID: DID, rhsURL: string, revokedNonces?: number[]): Promise<void> {\n    const treeState = await this.getDIDTreeModel(issuerDID);\n    await pushHashesToRHS(\n      treeState.state,\n      {\n        revocationTree: treeState.revocationTree,\n        claimsTree: treeState.claimsTree,\n        state: treeState.state,\n        rootsTree: treeState.rootsTree\n      },\n      rhsURL,\n      revokedNonces\n    );\n  }\n\n  /** {@inheritDoc IIdentityWallet.publishRevocationInfoByCredentialStatusType} */\n  async publishRevocationInfoByCredentialStatusType(\n    issuerDID: DID,\n    credentialStatusType: CredentialStatusType,\n    opts?: RevocationInfoOptions\n  ): Promise<void> {\n    const rhsPublishers = this._credentialStatusPublisherRegistry.get(credentialStatusType);\n    if (!rhsPublishers) {\n      throw new Error(\n        `there is no registered publisher to save  hash is not registered for ${credentialStatusType} is not registered`\n      );\n    }\n\n    let nodes: ProofNode[] = [];\n\n    const tree = opts?.treeModel ?? (await this.getDIDTreeModel(issuerDID));\n    nodes = await getNodesRepresentation(\n      opts?.revokedNonces ?? [],\n      {\n        revocationTree: tree.revocationTree,\n        claimsTree: tree.claimsTree,\n        state: tree.state,\n        rootsTree: tree.rootsTree\n      },\n      tree.state\n    );\n\n    if (!nodes.length) {\n      return;\n    }\n\n    const rhsPublishersTask = rhsPublishers.map((publisher) =>\n      publisher.publish({ nodes, ...opts, credentialStatusType, issuerDID })\n    );\n\n    await Promise.all(rhsPublishersTask);\n  }\n\n  public async getCoreClaimFromCredential(credential: W3CCredential): Promise<Claim> {\n    const coreClaimFromSigProof = credential.getCoreClaimFromProof(ProofType.BJJSignature);\n\n    const coreClaimFromMtpProof = credential.getCoreClaimFromProof(\n      ProofType.Iden3SparseMerkleTreeProof\n    );\n\n    if (\n      coreClaimFromMtpProof &&\n      coreClaimFromSigProof &&\n      coreClaimFromMtpProof.hex() !== coreClaimFromSigProof.hex()\n    ) {\n      throw new Error(VerifiableConstants.ERRORS.ID_WALLET_CORE_CLAIM_MISMATCH);\n    }\n    if (!coreClaimFromMtpProof && !coreClaimFromSigProof) {\n      throw new Error(VerifiableConstants.ERRORS.ID_WALLET_CORE_CLAIM_IS_NOT_SET);\n    }\n\n    //eslint-disable-next-line  @typescript-eslint/no-non-null-assertion\n    const coreClaim = coreClaimFromMtpProof ?? coreClaimFromSigProof!;\n\n    return coreClaim;\n  }\n\n  async findOwnedCredentialsByDID(did: DID, query: ProofQuery): Promise<W3CCredential[]> {\n    const credentials = await this._credentialWallet.findByQuery(query);\n    if (!credentials.length) {\n      throw new Error(VerifiableConstants.ERRORS.ID_WALLET_NO_CREDENTIAL_SATISFIED_QUERY);\n    }\n\n    const { genesisDID } = await this.getGenesisDIDMetadata(did);\n\n    const profiles = await this.getProfilesByDID(genesisDID);\n\n    return credentials.filter((cred) => {\n      const credentialSubjectId = cred.credentialSubject['id'] as string; // credential subject\n      return (\n        credentialSubjectId == genesisDID.string() ||\n        profiles.some((p) => {\n          return p.id === credentialSubjectId;\n        })\n      );\n    });\n  }\n\n  /** {@inheritDoc IIdentityWallet.updateIdentityState} */\n  async updateIdentityState(\n    issuerDID: DID,\n    published: boolean,\n    treeState?: TreeState\n  ): Promise<void> {\n    const latestTreeState = await this.getDIDTreeModel(issuerDID);\n\n    await this._storage.identity.saveIdentity({\n      did: issuerDID.string(),\n      state: treeState?.state ?? latestTreeState.state,\n      isStatePublished: published,\n      isStateGenesis: false\n    });\n  }\n\n  /** {@inheritdoc IIdentityWallet.transitState} */\n  async transitState(\n    did: DID,\n    oldTreeState: TreeState,\n    isOldStateGenesis: boolean,\n    ethSigner: Signer,\n    prover?: IZKProver\n  ): Promise<string> {\n    const newTreeModel = await this.getDIDTreeModel(did);\n    const claimsRoot = await newTreeModel.claimsTree.root();\n    const rootOfRoots = await newTreeModel.rootsTree.root();\n    const revocationRoot = await newTreeModel.revocationTree.root();\n\n    const newTreeState: TreeState = {\n      revocationRoot,\n      claimsRoot,\n      state: newTreeModel.state,\n      rootOfRoots\n    };\n\n    const userId = DID.idFromDID(did);\n\n    let proof;\n    const isEthIdentity = isEthereumIdentity(did); // don't generate proof for ethereum identities\n\n    let txId;\n    if (!isEthIdentity) {\n      if (!prover) {\n        throw new Error(VerifiableConstants.ERRORS.ID_WALLET_PROVER_IS_REQUIRED);\n      }\n      // generate the proof\n      const authInfo = await this._inputsGenerator.prepareAuthBJJCredential(did, oldTreeState);\n      const challenge = Poseidon.hash([oldTreeState.state.bigInt(), newTreeState.state.bigInt()]);\n\n      const signature = await this.signChallenge(challenge, authInfo.credential);\n\n      const circuitInputs = new StateTransitionInputs();\n      circuitInputs.id = userId;\n\n      circuitInputs.signature = signature;\n      circuitInputs.isOldStateGenesis = isOldStateGenesis;\n\n      const authClaimIncProofNewState = await this.generateCredentialMtp(\n        did,\n        authInfo.credential,\n        newTreeState\n      );\n\n      circuitInputs.newTreeState = authClaimIncProofNewState.treeState;\n      circuitInputs.authClaimNewStateIncProof = authClaimIncProofNewState.proof;\n\n      circuitInputs.oldTreeState = oldTreeState;\n      circuitInputs.authClaim = {\n        claim: authInfo.coreClaim,\n        incProof: authInfo.incProof,\n        nonRevProof: authInfo.nonRevProof\n      };\n\n      const inputs = circuitInputs.inputsMarshal();\n\n      proof = await prover.generate(inputs, CircuitId.StateTransition);\n\n      txId = await this._storage.states.publishState(proof, ethSigner);\n    } else {\n      const oldUserState = oldTreeState.state;\n      const newUserState = newTreeState.state;\n      const userStateTransitionInfo: UserStateTransitionInfo = {\n        userId,\n        oldUserState,\n        newUserState,\n        isOldStateGenesis,\n        methodId: BigInt(1),\n        methodParams: '0x'\n      } as UserStateTransitionInfo;\n      txId = await this._storage.states.publishStateGeneric(ethSigner, userStateTransitionInfo);\n    }\n    await this.updateIdentityState(did, true, newTreeState);\n\n    return txId;\n  }\n\n  private async getAuthBJJCredential(\n    did: DID,\n    oldTreeState: TreeState,\n    {\n      nonce,\n      seed,\n      id,\n      type\n    }: { nonce: number; seed: Uint8Array; id: string; type: CredentialStatusType }\n  ): Promise<W3CCredential> {\n    const { authClaim, pubKey } = await this.createAuthCoreClaim(nonce, seed);\n\n    const { hi, hv } = authClaim.hiHv();\n    await this._storage.mt.addToMerkleTree(did.string(), MerkleTreeType.Claims, hi, hv);\n\n    // Calculate current state after adding credential to merkle tree\n    const claimsTree = await this._storage.mt.getMerkleTreeByIdentifierAndType(\n      did.string(),\n      MerkleTreeType.Claims\n    );\n    const currentState = hashElems([\n      (await claimsTree.root()).bigInt(),\n      oldTreeState.revocationRoot.bigInt(),\n      oldTreeState.rootOfRoots.bigInt()\n    ]);\n\n    return this.createAuthBJJCredential(did, pubKey, authClaim, currentState, {\n      id,\n      type\n    });\n  }\n\n  /** {@inheritdoc IIdentityWallet.addBJJAuthCredential} */\n  async addBJJAuthCredential(\n    did: DID,\n    oldTreeState: TreeState,\n    isOldStateGenesis: boolean,\n    ethSigner: Signer,\n    opts: AuthBJJCredentialCreationOptions,\n    prover?: IZKProver // it will be needed in case of non ethereum identities\n  ): Promise<W3CCredential> {\n    opts.seed = opts.seed ?? getRandomBytes(32);\n    opts.revocationOpts.nonce =\n      opts.revocationOpts.nonce ??\n      (isOldStateGenesis\n        ? 0\n        : opts.revocationOpts.nonce ?? new DataView(getRandomBytes(12).buffer).getUint32(0));\n\n    const credential = await this.getAuthBJJCredential(did, oldTreeState, {\n      nonce: opts.revocationOpts.nonce,\n      seed: opts.seed,\n      id: opts.revocationOpts.id,\n      type: opts.revocationOpts.type\n    });\n\n    const addMtpToCredAndPublishRevState = async () => {\n      const { receipt, block } = await this._transactionService.getTransactionReceiptAndBlock(txId);\n      const credsWithIden3MTPProof = await this.generateIden3SparseMerkleTreeProof(\n        did,\n        [credential],\n        txId,\n        receipt?.blockNumber,\n        block?.timestamp,\n        undefined,\n        {\n          revNonce: opts.revocationOpts.nonce ?? 0,\n          subjectPosition: SubjectPosition.None,\n          merklizedRootPosition: MerklizedRootPosition.None,\n          updatable: false,\n          version: 0,\n          merklizeOpts: { documentLoader: cacheLoader() }\n        }\n      );\n\n      await this._credentialWallet.saveAll(credsWithIden3MTPProof);\n\n      await this.publishRevocationInfoByCredentialStatusType(did, opts.revocationOpts.type, {\n        rhsUrl: opts.revocationOpts.id,\n        onChain: opts.revocationOpts.onChain\n      });\n\n      return credsWithIden3MTPProof[0];\n    };\n\n    let txId = '';\n\n    let attempt = 2;\n    do {\n      try {\n        txId = await this.transitState(did, oldTreeState, isOldStateGenesis, ethSigner, prover);\n        break;\n      } catch (err) {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `Error while transiting state, retrying state transition, attempt: ${attempt}`,\n          err\n        );\n      }\n    } while (--attempt);\n\n    if (!txId) {\n      const oldTransitStateInfoJson = JSON.stringify(\n        {\n          claimsRoot: oldTreeState.claimsRoot.hex(),\n          revocationRoot: oldTreeState.revocationRoot.hex(),\n          rootOfRoots: oldTreeState.rootOfRoots.hex(),\n          state: oldTreeState.state.hex(),\n          isOldStateGenesis,\n          credentialId: credential.id,\n          did: did.string()\n        },\n        null,\n        2\n      );\n      await this._credentialWallet.save(credential);\n\n      throw new Error(`Error publishing state, info to publish: ${oldTransitStateInfoJson}`);\n    }\n\n    return addMtpToCredAndPublishRevState();\n  }\n}\n","import { DID, Id, IdPosition, MerklizedRootPosition } from '@iden3/js-iden3-core';\nimport { SchemaMetadata } from '../schema-processor';\nimport { SubjectPosition } from '../verifiable';\n\n/**\n * Determines subject position\n *\n * @param {IdPosition} idPosition - index / none / value\n * @returns {SubjectPosition}\n */\nexport const subjectPositionIndex = (idPosition: IdPosition): SubjectPosition => {\n  switch (idPosition) {\n    case IdPosition.Index:\n      return SubjectPosition.Index;\n    case IdPosition.Value:\n      return SubjectPosition.Value;\n    default:\n      return SubjectPosition.None;\n  }\n};\n\n/**\n * Returns merklized root position based on schema serialization metadata and expected position\n *\n * @param {SchemaMetadata} [metadata] - schema metadata\n * @param {MerklizedRootPosition} [position] - expected mt root position\n * @returns {MerklizedRootPosition}\n */\nexport const defineMerklizedRootPosition = (\n  metadata?: SchemaMetadata,\n  position?: MerklizedRootPosition\n): MerklizedRootPosition => {\n  if (!metadata?.serialization) {\n    return MerklizedRootPosition.None;\n  }\n\n  if (position != null && position !== MerklizedRootPosition.None) {\n    return position;\n  }\n\n  return MerklizedRootPosition.Index;\n};\n\n/**\n * Returns profile DID based on did and profile nonce\n *\n * @param {DID} [did] - did from which profile will be derived\n * @param {number | string} [profileNonce] - profile nonce\n * @returns {DID}\n */\nexport const generateProfileDID = (did: DID, profileNonce?: number | string): DID => {\n  const id = DID.idFromDID(did);\n\n  profileNonce = profileNonce ?? 0;\n\n  if (!isBigInt(profileNonce)) {\n    throw new Error('profile must be number or decimal string');\n  }\n  const profile = Id.profileId(id, BigInt(profileNonce));\n  return DID.parseFromId(profile);\n};\n\nconst isBigInt = (x: number | string): boolean => {\n  try {\n    return BigInt(x).toString() === x.toString();\n  } catch {\n    return false; // conversion to BigInt failed, surely it is not a BigInt\n  }\n};\n","import { Hash, Proof } from '@iden3/js-merkletree';\nimport {\n  ProofType,\n  CredentialStatusType,\n  RefreshServiceType,\n  DisplayMethodType\n} from './constants';\nimport { TreeState } from '../circuits';\nimport { Hex, Signature } from '@iden3/js-crypto';\nimport { Claim, DID } from '@iden3/js-iden3-core';\nimport { JsonDocumentObject, JSONObject } from '../iden3comm';\n\n/**\n * Represents the published state of the issuer\n *\n * @public\n * @interface   State\n */\nexport interface State {\n  txId?: string;\n  blockTimestamp?: number;\n  blockNumber?: number;\n  rootOfRoots: Hash;\n  claimsTreeRoot: Hash;\n  revocationTreeRoot: Hash;\n  value: Hash;\n  status?: string;\n}\n\n/**\n * Iden3SparseMerkleProof is a iden3 protocol merkle tree proof\n *\n * @public\n * @class Iden3SparseMerkleTreeProof\n */\nexport class Iden3SparseMerkleTreeProof {\n  type: ProofType;\n  issuerData: {\n    id: DID;\n    state: State;\n  };\n  mtp: Proof;\n  coreClaim: Claim;\n  /**\n   * Creates an instance of Iden3SparseMerkleTreeProof.\n   * @param {object} obj\n   */\n  constructor(obj: {\n    issuerData: {\n      id: DID;\n      state: State;\n    };\n    mtp: Proof;\n    coreClaim: Claim;\n  }) {\n    this.coreClaim = obj.coreClaim;\n    this.issuerData = obj.issuerData;\n    this.type = ProofType.Iden3SparseMerkleTreeProof;\n    this.mtp = obj.mtp;\n  }\n\n  /**\n   *\n   *\n   * @returns `json object in serialized presentation`\n   */\n  toJSON() {\n    const issuerId = this.issuerData.id;\n    return {\n      issuerData: {\n        id: issuerId.string(),\n        state: {\n          ...this.issuerData.state,\n          rootOfRoots: this.issuerData.state.rootOfRoots.hex(),\n          claimsTreeRoot: this.issuerData.state.claimsTreeRoot.hex(),\n          revocationTreeRoot: this.issuerData.state.revocationTreeRoot.hex(),\n          value: this.issuerData.state.value.hex()\n        }\n      },\n      type: this.type,\n      coreClaim: this.coreClaim.hex(),\n      mtp: this.mtp.toJSON()\n    };\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static fromJSON(obj: any) {\n    let mtp: Proof;\n    if (obj?.mtp?.notEmpties && obj?.mtp?.depth && obj?.mtp?.siblings) {\n      // legacy\n\n      const ne = obj?.mtp?.notEmpties;\n      const notEmpties = ne instanceof Uint8Array ? ne : new Uint8Array(Object.values(ne));\n      const siblingsHashes = obj?.mtp?.siblings.map((h: unknown) =>\n        Hash.fromString(JSON.stringify(h))\n      );\n      const allSiblings = Proof.buildAllSiblings(obj?.mtp?.depth, notEmpties, siblingsHashes);\n      let nodeAux = obj.mtp.nodeAux || obj.mtp.node_aux;\n      if (nodeAux) {\n        nodeAux = {\n          key: Hash.fromString(JSON.stringify(nodeAux.key)),\n          value: Hash.fromString(JSON.stringify(nodeAux.value))\n        };\n      }\n      mtp = new Proof({ existence: obj?.mtp.existence, nodeAux: nodeAux, siblings: allSiblings });\n    } else {\n      mtp = Proof.fromJSON(obj.mtp);\n    }\n\n    return new Iden3SparseMerkleTreeProof({\n      coreClaim: new Claim().fromHex(obj.coreClaim),\n      mtp,\n      issuerData: {\n        id: DID.parse(obj.issuerData.id),\n        state: {\n          ...obj.issuerData.state,\n          rootOfRoots: Hash.fromHex(obj.issuerData.state.rootOfRoots),\n          claimsTreeRoot: Hash.fromHex(obj.issuerData.state.claimsTreeRoot),\n          revocationTreeRoot: Hash.fromHex(obj.issuerData.state.revocationTreeRoot),\n          value: Hash.fromHex(obj.issuerData.state.value)\n        }\n      }\n    });\n  }\n}\n\n/**\n *\n * BJJSignatureProof2021 is a signature of core claim by BJJ key\n * @public\n * @class BJJSignatureProof2021\n */\nexport class BJJSignatureProof2021 {\n  type: ProofType;\n  issuerData: {\n    id: DID;\n    state: State;\n    authCoreClaim: Claim;\n    mtp: Proof;\n    credentialStatus: CredentialStatus;\n  };\n  signature: Signature;\n  coreClaim: Claim;\n\n  constructor(obj: {\n    issuerData: {\n      id: DID;\n      state: State;\n      authCoreClaim: Claim;\n      mtp: Proof;\n      credentialStatus: CredentialStatus;\n    };\n    coreClaim: Claim;\n    signature: Signature;\n  }) {\n    this.type = ProofType.BJJSignature;\n    this.issuerData = obj.issuerData;\n    this.coreClaim = obj.coreClaim;\n    this.signature = obj.signature;\n  }\n\n  /**\n   * toJSON is a method to serialize BJJSignatureProof2021 to json\n   *\n   * @returns `json object in serialized presentation`\n   */\n  toJSON() {\n    return {\n      issuerData: {\n        id: this.issuerData.id.string(),\n        state: {\n          ...this.issuerData.state,\n          rootOfRoots: this.issuerData.state.rootOfRoots.hex(),\n          claimsTreeRoot: this.issuerData.state.claimsTreeRoot.hex(),\n          revocationTreeRoot: this.issuerData.state.revocationTreeRoot.hex(),\n          value: this.issuerData.state.value.hex()\n        },\n        mtp: this.issuerData.mtp.toJSON(),\n        authCoreClaim: this.issuerData.authCoreClaim.hex(),\n        credentialStatus: this.issuerData.credentialStatus\n      },\n      type: this.type,\n      coreClaim: this.coreClaim.hex(),\n      signature: Hex.encodeString(this.signature.compress())\n    };\n  }\n\n  /**\n   * fromJSON is a method to deserialize BJJSignatureProof2021 from json\n   * @param obj\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static fromJSON(obj: any) {\n    return new BJJSignatureProof2021({\n      issuerData: {\n        id: DID.parse(obj.issuerData.id),\n        mtp: Proof.fromJSON(obj.issuerData.mtp),\n        state: {\n          ...obj.issuerData.state,\n          rootOfRoots: Hash.fromHex(obj.issuerData.state.rootOfRoots),\n          claimsTreeRoot: Hash.fromHex(obj.issuerData.state.claimsTreeRoot),\n          revocationTreeRoot: Hash.fromHex(obj.issuerData.state.revocationTreeRoot),\n          value: Hash.fromHex(obj.issuerData.state.value)\n        },\n        credentialStatus: obj.issuerData.credentialStatus,\n        authCoreClaim: new Claim().fromHex(obj.issuerData.authCoreClaim)\n      },\n      coreClaim: new Claim().fromHex(obj.coreClaim),\n      signature: Signature.newFromCompressed(\n        Uint8Array.from(Hex.decodeString(obj.signature)).slice(0, 64)\n      )\n    });\n  }\n}\n/**\n *  Query represents structure for query to atomic circuit\n *\n * @public\n * @interface   ProofQuery\n */\nexport interface ProofQuery {\n  allowedIssuers?: string[];\n  credentialSubject?: JsonDocumentObject;\n  schema?: string; // string url\n  claimId?: string;\n  credentialSubjectId?: string;\n  context?: string;\n  type?: string;\n  skipClaimRevocationCheck?: boolean;\n  proofType?: string;\n  groupId?: number;\n  params?: JSONObject;\n}\n\n/**\n * Proof with MerkleTree info\n *\n * @public\n * @interface   MerkleTreeProofWithTreeState\n */\nexport interface MerkleTreeProofWithTreeState {\n  proof: Proof;\n  treeState: TreeState;\n}\n\n/**\n *\n * CredentialStatus contains type and revocation Url\n * @public\n * @interface   CredentialStatus\n */\nexport interface CredentialStatus {\n  id: string;\n  type: CredentialStatusType;\n  revocationNonce?: number;\n  statusIssuer?: { id: string; type: CredentialStatusType; revocationNonce?: number };\n}\n\n/**\n * RefreshService contains type and id\n * @public\n * @interface   RefreshService\n */\nexport interface RefreshService {\n  id: string;\n  type: RefreshServiceType | string;\n}\n\n/**\n * DisplayMethod contains type and id\n * @public\n * @interface   DisplayMethod\n */\nexport interface DisplayMethod {\n  id: string;\n  type: DisplayMethodType | string;\n}\n","/** Verifiable constants */\nexport const VerifiableConstants = Object.freeze({\n  ERRORS: {\n    FiELD_IS_EMPTY: 'fieldPath is empty',\n    CONTEXT_TYPE_IS_EMPTY: 'ctxType is empty',\n    // ErrStateNotFound issuer state is genesis state.\n    IDENTITY_DOES_NOT_EXIST: 'Identity does not exist',\n    NO_AUTH_CRED_FOUND: 'no auth credentials found',\n\n    // identity wallet\n\n    ID_WALLET_NO_CREDENTIAL_SATISFIED_QUERY: 'no credential satisfied query',\n    ID_WALLET_SIGNER_IS_REQUIRED:\n      'Ethereum signer is required to create Ethereum identities in order to transit state',\n    ID_WALLET_PROVER_IS_REQUIRED:\n      'prover is required to generate proofs for non ethereum identities',\n    ID_WALLET_CORE_CLAIM_REQUIRED_IN_SIG_PROOF:\n      'credential must have coreClaim representation in the signature proof',\n    ID_WALLET_CORE_CLAIM_REQUIRED_IN_ANY_PROOF:\n      'credential must have coreClaim representation in proofs',\n    ID_WALLET_CORE_CLAIM_MISMATCH:\n      'core claim representations is set in both proofs but they are not equal',\n    ID_WALLET_CORE_CLAIM_IS_NOT_SET: 'core claim is not set in credential proofs',\n    ID_WALLET_PROFILE_OR_IDENTITY_NOT_FOUND: 'profile or identity not found',\n    ID_WALLET_PROFILE_ALREADY_EXISTS: 'profile with given nonce or verifier already exists',\n    ID_WALLET_PROFILE_ALREADY_EXISTS_VERIFIER_TAGS:\n      'profile with given verifier and tags already exists',\n    ID_WALLET_ISSUER_AUTH_BJJ_CRED_MUST_HAVE_ANY_PROOF: 'issuer auth credential must have proof',\n    ID_WALLET_ISSUER_AUTH_BJJ_CRED_MUST_HAVE_MTP_PROOF:\n      'mtp is required for auth bjj key to issue new credentials',\n\n    // proof service\n\n    PROOF_SERVICE_NO_CREDENTIAL_FOR_IDENTITY_OR_PROFILE:\n      'no credentials belong to did or its profiles',\n    PROOF_SERVICE_NO_CREDENTIAL_FOR_QUERY: 'credential not found for query',\n    PROOF_SERVICE_PROFILE_GENESIS_DID_MISMATCH:\n      'subject and auth profiles are not derived from the same did',\n    PROOF_SERVICE_NO_QUERIES_IN_ZKP_REQUEST: 'no queries in zkp request',\n\n    // credential wallet\n\n    CREDENTIAL_WALLET_ALL_CREDENTIALS_ARE_REVOKED: 'all claims are revoked'\n  },\n  CREDENTIAL_TYPE: {\n    // VerifiableCredential is a W3C verifiable credential type\n    W3C_VERIFIABLE_CREDENTIAL: 'VerifiableCredential',\n    W3C_VERIFIABLE_PRESENTATION: 'VerifiablePresentation'\n  },\n  CREDENTIAL_SUBJECT_PATH: 'https://www.w3.org/2018/credentials#credentialSubject',\n  JSONLD_SCHEMA: {\n    // JSONLDSchemaIden3Credential is a schema for context with Iden3Credential type\n    IDEN3_CREDENTIAL: 'https://schema.iden3.io/core/jsonld/iden3proofs.jsonld',\n    // JSONLDSchemaIden3DisplayMethod is a schema for context with Iden3BasicDisplayMethodV1 type\n    IDEN3_DISPLAY_METHOD: 'https://schema.iden3.io/core/jsonld/displayMethod.jsonld',\n    // JSONLDSchemaW3CCredential2018 is a schema for context with VerifiableCredential type\n    W3C_CREDENTIAL_2018: 'https://www.w3.org/2018/credentials/v1',\n    W3C_VC_DOCUMENT_2018: `{\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\",\"VerifiableCredential\":{\"@id\":\"https://www.w3.org/2018/credentials#VerifiableCredential\",\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\",\"cred\":\"https://www.w3.org/2018/credentials#\",\"sec\":\"https://w3id.org/security#\",\"xsd\":\"http://www.w3.org/2001/XMLSchema#\",\"credentialSchema\":{\"@id\":\"cred:credentialSchema\",\"@type\":\"@id\",\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\",\"cred\":\"https://www.w3.org/2018/credentials#\",\"JsonSchemaValidator2018\":\"cred:JsonSchemaValidator2018\"}},\"credentialStatus\":{\"@id\":\"cred:credentialStatus\",\"@type\":\"@id\"},\"credentialSubject\":{\"@id\":\"cred:credentialSubject\",\"@type\":\"@id\"},\"evidence\":{\"@id\":\"cred:evidence\",\"@type\":\"@id\"},\"expirationDate\":{\"@id\":\"cred:expirationDate\",\"@type\":\"xsd:dateTime\"},\"holder\":{\"@id\":\"cred:holder\",\"@type\":\"@id\"},\"issued\":{\"@id\":\"cred:issued\",\"@type\":\"xsd:dateTime\"},\"issuer\":{\"@id\":\"cred:issuer\",\"@type\":\"@id\"},\"issuanceDate\":{\"@id\":\"cred:issuanceDate\",\"@type\":\"xsd:dateTime\"},\"proof\":{\"@id\":\"sec:proof\",\"@type\":\"@id\",\"@container\":\"@graph\"},\"refreshService\":{\"@id\":\"cred:refreshService\",\"@type\":\"@id\",\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\",\"cred\":\"https://www.w3.org/2018/credentials#\",\"ManualRefreshService2018\":\"cred:ManualRefreshService2018\"}},\"termsOfUse\":{\"@id\":\"cred:termsOfUse\",\"@type\":\"@id\"},\"validFrom\":{\"@id\":\"cred:validFrom\",\"@type\":\"xsd:dateTime\"},\"validUntil\":{\"@id\":\"cred:validUntil\",\"@type\":\"xsd:dateTime\"}}},\"VerifiablePresentation\":{\"@id\":\"https://www.w3.org/2018/credentials#VerifiablePresentation\",\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\",\"cred\":\"https://www.w3.org/2018/credentials#\",\"sec\":\"https://w3id.org/security#\",\"holder\":{\"@id\":\"cred:holder\",\"@type\":\"@id\"},\"proof\":{\"@id\":\"sec:proof\",\"@type\":\"@id\",\"@container\":\"@graph\"},\"verifiableCredential\":{\"@id\":\"cred:verifiableCredential\",\"@type\":\"@id\",\"@container\":\"@graph\"}}},\"EcdsaSecp256k1Signature2019\":{\"@id\":\"https://w3id.org/security#EcdsaSecp256k1Signature2019\",\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\",\"sec\":\"https://w3id.org/security#\",\"xsd\":\"http://www.w3.org/2001/XMLSchema#\",\"challenge\":\"sec:challenge\",\"created\":{\"@id\":\"http://purl.org/dc/terms/created\",\"@type\":\"xsd:dateTime\"},\"domain\":\"sec:domain\",\"expires\":{\"@id\":\"sec:expiration\",\"@type\":\"xsd:dateTime\"},\"jws\":\"sec:jws\",\"nonce\":\"sec:nonce\",\"proofPurpose\":{\"@id\":\"sec:proofPurpose\",\"@type\":\"@vocab\",\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\",\"sec\":\"https://w3id.org/security#\",\"assertionMethod\":{\"@id\":\"sec:assertionMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},\"authentication\":{\"@id\":\"sec:authenticationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"}}},\"proofValue\":\"sec:proofValue\",\"verificationMethod\":{\"@id\":\"sec:verificationMethod\",\"@type\":\"@id\"}}},\"EcdsaSecp256r1Signature2019\":{\"@id\":\"https://w3id.org/security#EcdsaSecp256r1Signature2019\",\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\",\"sec\":\"https://w3id.org/security#\",\"xsd\":\"http://www.w3.org/2001/XMLSchema#\",\"challenge\":\"sec:challenge\",\"created\":{\"@id\":\"http://purl.org/dc/terms/created\",\"@type\":\"xsd:dateTime\"},\"domain\":\"sec:domain\",\"expires\":{\"@id\":\"sec:expiration\",\"@type\":\"xsd:dateTime\"},\"jws\":\"sec:jws\",\"nonce\":\"sec:nonce\",\"proofPurpose\":{\"@id\":\"sec:proofPurpose\",\"@type\":\"@vocab\",\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\",\"sec\":\"https://w3id.org/security#\",\"assertionMethod\":{\"@id\":\"sec:assertionMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},\"authentication\":{\"@id\":\"sec:authenticationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"}}},\"proofValue\":\"sec:proofValue\",\"verificationMethod\":{\"@id\":\"sec:verificationMethod\",\"@type\":\"@id\"}}},\"Ed25519Signature2018\":{\"@id\":\"https://w3id.org/security#Ed25519Signature2018\",\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\",\"sec\":\"https://w3id.org/security#\",\"xsd\":\"http://www.w3.org/2001/XMLSchema#\",\"challenge\":\"sec:challenge\",\"created\":{\"@id\":\"http://purl.org/dc/terms/created\",\"@type\":\"xsd:dateTime\"},\"domain\":\"sec:domain\",\"expires\":{\"@id\":\"sec:expiration\",\"@type\":\"xsd:dateTime\"},\"jws\":\"sec:jws\",\"nonce\":\"sec:nonce\",\"proofPurpose\":{\"@id\":\"sec:proofPurpose\",\"@type\":\"@vocab\",\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\",\"sec\":\"https://w3id.org/security#\",\"assertionMethod\":{\"@id\":\"sec:assertionMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},\"authentication\":{\"@id\":\"sec:authenticationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"}}},\"proofValue\":\"sec:proofValue\",\"verificationMethod\":{\"@id\":\"sec:verificationMethod\",\"@type\":\"@id\"}}},\"RsaSignature2018\":{\"@id\":\"https://w3id.org/security#RsaSignature2018\",\"@context\":{\"@version\":1.1,\"@protected\":true,\"challenge\":\"sec:challenge\",\"created\":{\"@id\":\"http://purl.org/dc/terms/created\",\"@type\":\"xsd:dateTime\"},\"domain\":\"sec:domain\",\"expires\":{\"@id\":\"sec:expiration\",\"@type\":\"xsd:dateTime\"},\"jws\":\"sec:jws\",\"nonce\":\"sec:nonce\",\"proofPurpose\":{\"@id\":\"sec:proofPurpose\",\"@type\":\"@vocab\",\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\",\"sec\":\"https://w3id.org/security#\",\"assertionMethod\":{\"@id\":\"sec:assertionMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},\"authentication\":{\"@id\":\"sec:authenticationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"}}},\"proofValue\":\"sec:proofValue\",\"verificationMethod\":{\"@id\":\"sec:verificationMethod\",\"@type\":\"@id\"}}},\"proof\":{\"@id\":\"https://w3id.org/security#proof\",\"@type\":\"@id\",\"@container\":\"@graph\"}}}`,\n    IDEN3_PROOFS_DEFINITION_DOCUMENT: `{\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\",\"Iden3SparseMerkleTreeProof\":{\"@id\":\"https://schema.iden3.io/core/jsonld/iden3proofs.jsonld#Iden3SparseMerkleTreeProof\",\"@context\":{\"@version\":1.1,\"@protected\":true,\"@propagate\":true,\"id\":\"@id\",\"type\":\"@type\",\"sec\":\"https://w3id.org/security#\",\"@vocab\":\"https://schema.iden3.io/core/vocab/Iden3SparseMerkleTreeProof.md#\",\"xsd\":\"http://www.w3.org/2001/XMLSchema#\",\"mtp\":{\"@id\":\"https://schema.iden3.io/core/jsonld/iden3proofs.jsonld#SparseMerkleTreeProof\",\"@type\":\"SparseMerkleTreeProof\"},\"coreClaim\":{\"@id\":\"coreClaim\",\"@type\":\"xsd:string\"},\"issuerData\":{\"@id\":\"issuerData\",\"@context\":{\"@version\":1.1,\"state\":{\"@id\":\"state\",\"@context\":{\"txId\":{\"@id\":\"txId\",\"@type\":\"xsd:string\"},\"blockTimestamp\":{\"@id\":\"blockTimestamp\",\"@type\":\"xsd:integer\"},\"blockNumber\":{\"@id\":\"blockNumber\",\"@type\":\"xsd:integer\"},\"rootOfRoots\":{\"@id\":\"rootOfRoots\",\"@type\":\"xsd:string\"},\"claimsTreeRoot\":{\"@id\":\"claimsTreeRoot\",\"@type\":\"xsd:string\"},\"revocationTreeRoot\":{\"@id\":\"revocationTreeRoot\",\"@type\":\"xsd:string\"},\"authCoreClaim\":{\"@id\":\"authCoreClaim\",\"@type\":\"xsd:string\"},\"value\":{\"@id\":\"value\",\"@type\":\"xsd:string\"}}}}}}},\"SparseMerkleTreeProof\":{\"@id\":\"https://schema.iden3.io/core/jsonld/iden3proofs.jsonld#SparseMerkleTreeProof\",\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\",\"sec\":\"https://w3id.org/security#\",\"smt-proof-vocab\":\"https://schema.iden3.io/core/vocab/SparseMerkleTreeProof.md#\",\"xsd\":\"http://www.w3.org/2001/XMLSchema#\",\"existence\":{\"@id\":\"smt-proof-vocab:existence\",\"@type\":\"xsd:boolean\"},\"revocationNonce\":{\"@id\":\"smt-proof-vocab:revocationNonce\",\"@type\":\"xsd:number\"},\"siblings\":{\"@id\":\"smt-proof-vocab:siblings\",\"@container\":\"@list\"},\"nodeAux\":\"@nest\",\"hIndex\":{\"@id\":\"smt-proof-vocab:hIndex\",\"@nest\":\"nodeAux\",\"@type\":\"xsd:string\"},\"hValue\":{\"@id\":\"smt-proof-vocab:hValue\",\"@nest\":\"nodeAux\",\"@type\":\"xsd:string\"}}},\"BJJSignature2021\":{\"@id\":\"https://schema.iden3.io/core/jsonld/iden3proofs.jsonld#BJJSignature2021\",\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"@vocab\":\"https://schema.iden3.io/core/vocab/BJJSignature2021.md#\",\"@propagate\":true,\"type\":\"@type\",\"xsd\":\"http://www.w3.org/2001/XMLSchema#\",\"coreClaim\":{\"@id\":\"coreClaim\",\"@type\":\"xsd:string\"},\"issuerData\":{\"@id\":\"issuerData\",\"@context\":{\"@version\":1.1,\"authCoreClaim\":{\"@id\":\"authCoreClaim\",\"@type\":\"xsd:string\"},\"mtp\":{\"@id\":\"https://schema.iden3.io/core/jsonld/iden3proofs.jsonld#SparseMerkleTreeProof\",\"@type\":\"SparseMerkleTreeProof\"},\"revocationStatus\":{\"@id\":\"revocationStatus\",\"@type\":\"@id\"},\"state\":{\"@id\":\"state\",\"@context\":{\"@version\":1.1,\"rootOfRoots\":{\"@id\":\"rootOfRoots\",\"@type\":\"xsd:string\"},\"claimsTreeRoot\":{\"@id\":\"claimsTreeRoot\",\"@type\":\"xsd:string\"},\"revocationTreeRoot\":{\"@id\":\"revocationTreeRoot\",\"@type\":\"xsd:string\"},\"value\":{\"@id\":\"value\",\"@type\":\"xsd:string\"}}}}},\"signature\":{\"@id\":\"signature\",\"@type\":\"https://w3id.org/security#multibase\"},\"domain\":\"https://w3id.org/security#domain\",\"creator\":{\"@id\":\"creator\",\"@type\":\"http://www.w3.org/2001/XMLSchema#string\"},\"challenge\":\"https://w3id.org/security#challenge\",\"created\":{\"@id\":\"created\",\"@type\":\"http://www.w3.org/2001/XMLSchema#dateTime\"},\"expires\":{\"@id\":\"https://w3id.org/security#expiration\",\"@type\":\"http://www.w3.org/2001/XMLSchema#dateTime\"},\"nonce\":\"https://w3id.org/security#nonce\",\"proofPurpose\":{\"@id\":\"https://w3id.org/security#proofPurpose\",\"@type\":\"@vocab\",\"@context\":{\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\",\"assertionMethod\":{\"@id\":\"https://w3id.org/security#assertionMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},\"authentication\":{\"@id\":\"https://w3id.org/security#authenticationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},\"capabilityInvocation\":{\"@id\":\"https://w3id.org/security#capabilityInvocationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},\"capabilityDelegation\":{\"@id\":\"https://w3id.org/security#capabilityDelegationMethod\",\"@type\":\"@id\",\"@container\":\"@set\"},\"keyAgreement\":{\"@id\":\"https://w3id.org/security#keyAgreementMethod\",\"@type\":\"@id\",\"@container\":\"@set\"}}},\"proofValue\":{\"@id\":\"https://w3id.org/security#proofValue\",\"@type\":\"https://w3id.org/security#multibase\"},\"verificationMethod\":{\"@id\":\"https://w3id.org/security#verificationMethod\",\"@type\":\"@id\"}}},\"Iden3ReverseSparseMerkleTreeProof\":{\"@id\":\"https://schema.iden3.io/core/jsonld/iden3proofs.jsonld#Iden3ReverseSparseMerkleTreeProof\",\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\",\"iden3-reverse-sparse-merkle-tree-proof-vocab\":\"https://schema.iden3.io/core/vocab/Iden3ReverseSparseMerkleTreeProof.md#\",\"revocationNonce\":\"iden3-reverse-sparse-merkle-tree-proof-vocab:revocationNonce\",\"statusIssuer\":{\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\"},\"@id\":\"iden3-reverse-sparse-merkle-tree-proof-vocab:statusIssuer\"}}},\"Iden3commRevocationStatusV1.0\":{\"@id\":\"https://schema.iden3.io/core/jsonld/iden3proofs.jsonld#Iden3commRevocationStatusV1.0\",\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\",\"iden3-comm-revocation-statusV1.0-vocab\":\"https://schema.iden3.io/core/vocab/Iden3commRevocationStatusV1.0.md#\",\"revocationNonce\":\"iden3-comm-revocation-statusV1.0-vocab:revocationNonce\",\"statusIssuer\":{\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\"},\"@id\":\"iden3-comm-revocation-statusV1.0-vocab:statusIssuer\"}}},\"Iden3OnchainSparseMerkleTreeProof2023\":{\"@id\":\"https://schema.iden3.io/core/jsonld/iden3proofs.jsonld#Iden3OnchainSparseMerkleTreeProof2023\",\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\",\"iden3-onchain-sparse-merkle-tree-proof-2023-vocab\":\"https://schema.iden3.io/core/vocab/Iden3OnchainSparseMerkleTreeProof2023.md#\",\"revocationNonce\":\"iden3-onchain-sparse-merkle-tree-proof-2023-vocab:revocationNonce\",\"statusIssuer\":{\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\"},\"@id\":\"iden3-onchain-sparse-merkle-tree-proof-2023-vocab:statusIssuer\"}}},\"JsonSchema2023\":\"https://www.w3.org/ns/credentials#JsonSchema2023\",\"Iden3RefreshService2023\":\"https://schema.iden3.io/core/jsonld/iden3proofs.jsonld#Iden3RefreshService2023\"}}`,\n    IDEN3_DISPLAY_METHOD_DEFINITION_DOCUMENT: `{\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\",\"displayMethod\":{\"@id\":\"https://schema.iden3.io/core/vocab/displayMethod.md#displayMethod\",\"@type\":\"@id\",\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\",\"Iden3BasicDisplayMethodV1\":\"https://schema.iden3.io/core/vocab/displayMethod.md#Iden3BasicDisplayMethodV1\"}}}}`\n  },\n  // JsonSchema2023 JSON schema for verification of Iden3Credential\n  JSON_SCHEMA_VALIDATOR: 'JsonSchema2023',\n  SERVICE_TYPE: {\n    // Iden3CommServiceType is service type for iden3comm protocol\n    IDEN3_COMM: 'iden3-communication',\n    // PushNotificationServiceType is service type for delivering push notifications to identity\n    PUSH_NOTIFICATION: 'push-notification'\n  },\n  AUTH: {\n    AUTH_BJJ_CREDENTIAL_HASH: '013fd3f623559d850fb5b02ff012d0e2',\n    AUTH_BJJ_CREDENTIAL_SCHEMA_JSON_URL: 'https://schema.iden3.io/core/json/auth.json',\n    AUTH_BJJ_CREDENTIAL_SCHEMA_JSONLD_URL: 'https://schema.iden3.io/core/jsonld/auth.jsonld',\n    AUTH_BJJ_CREDENTIAL_TYPE: 'AuthBJJCredential',\n    AUTH_BJJ_CREDENTIAL_SCHEMA_JSON: `{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"$metadata\":{\"uris\":{\"jsonLdContext\":\"https://schema.iden3.io/core/jsonld/auth.jsonld\",\"jsonSchema\":\"https://schema.iden3.io/core/json/auth.json\"},\"serialization\":{\"indexDataSlotA\":\"x\",\"indexDataSlotB\":\"y\"}},\"type\":\"object\",\"required\":[\"@context\",\"id\",\"type\",\"issuanceDate\",\"credentialSubject\",\"credentialSchema\",\"credentialStatus\",\"issuer\"],\"properties\":{\"@context\":{\"type\":[\"string\",\"array\",\"object\"]},\"id\":{\"type\":\"string\"},\"type\":{\"type\":[\"string\",\"array\"],\"items\":{\"type\":\"string\"}},\"issuer\":{\"type\":[\"string\",\"object\"],\"format\":\"uri\",\"required\":[\"id\"],\"properties\":{\"id\":{\"type\":\"string\",\"format\":\"uri\"}}},\"issuanceDate\":{\"type\":\"string\",\"format\":\"date-time\"},\"expirationDate\":{\"type\":\"string\",\"format\":\"date-time\"},\"credentialSchema\":{\"type\":\"object\",\"required\":[\"id\",\"type\"],\"properties\":{\"id\":{\"type\":\"string\",\"format\":\"uri\"},\"type\":{\"type\":\"string\"}}},\"credentialSubject\":{\"type\":\"object\",\"required\":[\"x\",\"y\"],\"properties\":{\"id\":{\"title\":\"Credential Subject ID\",\"type\":\"string\",\"format\":\"uri\"},\"x\":{\"type\":\"string\"},\"y\":{\"type\":\"string\"}}}}}`,\n    AUTH_BJJ_CREDENTIAL_SCHEMA_JSONLD: `{\"@context\":[{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\",\"AuthBJJCredential\":{\"@id\":\"https://schema.iden3.io/core/jsonld/auth.jsonld#AuthBJJCredential\",\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\",\"iden3_serialization\":\"iden3:v1:slotIndexA=x&slotIndexB=y\",\"xsd\":\"http://www.w3.org/2001/XMLSchema#\",\"auth-vocab\":\"https://schema.iden3.io/core/vocab/auth.md#\",\"x\":{\"@id\":\"auth-vocab:x\",\"@type\":\"xsd:positiveInteger\"},\"y\":{\"@id\":\"auth-vocab:y\",\"@type\":\"xsd:positiveInteger\"}}},\"Iden3StateInfo2023\":{\"@id\":\"https://schema.iden3.io/core/jsonld/auth.jsonld#Iden3StateInfo2023\",\"@context\":{\"@version\":1.1,\"@protected\":true,\"id\":\"@id\",\"type\":\"@type\",\"xsd\":\"http://www.w3.org/2001/XMLSchema#\",\"@vocab\":\"https://schema.iden3.io/core/vocab/state-info.md#\",\"@propagate\":true,\"stateContractAddress\":{\"@id\":\"stateContractAddress\",\"@type\":\"xsd:string\"},\"published\":{\"@id\":\"published\",\"@type\":\"xsd:boolean\"},\"info\":{\"@id\":\"info\",\"@type\":\"@id\",\"@context\":{\"@protected\":true,\"id\":{\"@id\":\"id\",\"@type\":\"xsd:string\"},\"state\":{\"@id\":\"state\",\"@type\":\"xsd:string\"},\"replacedByState\":{\"@id\":\"replacedByState\",\"@type\":\"xsd:string\"},\"createdAtTimestamp\":{\"@id\":\"createdAtTimestamp\",\"@type\":\"xsd:string\"},\"replacedAtTimestamp\":{\"@id\":\"replacedAtTimestamp\",\"@type\":\"xsd:string\"},\"createdAtBlock\":{\"@id\":\"createdAtBlock\",\"@type\":\"xsd:string\"},\"replacedAtBlock\":{\"@id\":\"replacedAtBlock\",\"@type\":\"xsd:string\"}}},\"global\":{\"@id\":\"global\",\"@type\":\"@id\",\"@context\":{\"@protected\":true,\"sec\":\"https://w3id.org/security#\",\"root\":{\"@id\":\"root\",\"@type\":\"xsd:string\"},\"replacedByRoot\":{\"@id\":\"replacedByRoot\",\"@type\":\"xsd:string\"},\"createdAtTimestamp\":{\"@id\":\"createdAtTimestamp\",\"@type\":\"xsd:string\"},\"replacedAtTimestamp\":{\"@id\":\"replacedAtTimestamp\",\"@type\":\"xsd:string\"},\"createdAtBlock\":{\"@id\":\"createdAtBlock\",\"@type\":\"xsd:string\"},\"replacedAtBlock\":{\"@id\":\"replacedAtBlock\",\"@type\":\"xsd:string\"},\"proof\":{\"@id\":\"sec:proof\",\"@type\":\"@id\",\"@container\":\"@graph\"}}}}}}]}`\n  }\n});\n\n/**\n * Proof type for Verifiable Credential supported by sdk\n *\n * @enum {number}\n */\nexport enum ProofType {\n  // BJJSignatureProofType\n  BJJSignature = 'BJJSignature2021',\n  // Iden3SparseMerkleTreeProofType\n  Iden3SparseMerkleTreeProof = 'Iden3SparseMerkleTreeProof'\n}\n\n/**\n * CredentialStatusType type for revocation type\n *\n * @enum {number}\n */\nexport enum CredentialStatusType {\n  // SparseMerkleTreeProof is CredentialStatusType for standard MTP result handlers\n  SparseMerkleTreeProof = 'SparseMerkleTreeProof',\n  // Iden3ReverseSparseMerkleTreeProof is CredentialStatusType  for reverse iden3 algorithm\n  Iden3ReverseSparseMerkleTreeProof = 'Iden3ReverseSparseMerkleTreeProof',\n  // Iden3commRevocationStatusV1 is CredentialStatusType for iden3comm revocation status\n  Iden3commRevocationStatusV1 = 'Iden3commRevocationStatusV1.0',\n  // Iden3OnchainSparseMerkleTreeProof2023 is a proof type for MTP proofs with iden3 metadata from blockchain\n  Iden3OnchainSparseMerkleTreeProof2023 = 'Iden3OnchainSparseMerkleTreeProof2023'\n}\n\n/**\n * W3C Proof purpose\n *\n * @enum {number}\n */\nexport enum ProofPurpose {\n  Authentication = 'Authentication'\n}\n\n/**\n * Merklized Core.Claim root position for vc creation\n *\n * @enum {number}\n */\nexport enum MerklizedRootPosition {\n  // PositionIndex merklized root is stored in index.\n  Index = 'index',\n  // Value merklized root is stored in value.\n  Value = 'value',\n  // None merklized root is not stored in the claim. By Default.\n  None = ''\n}\n\n/**\n * Subject Core.Claim position for vc creation\n *\n * @enum {number}\n */\nexport enum SubjectPosition {\n  // CredentialSubjectPositionNone is for self issued Iden3Credential\n  None = '',\n  // Index save subject in index part of claim. By default.\n  Index = 'index',\n  // Value save subject in value part of claim.\n  Value = 'value'\n}\n\n/**\n * RefreshServiceType type for refreshService\n *\n * @enum {string}\n */\nexport enum RefreshServiceType {\n  Iden3RefreshService2023 = 'Iden3RefreshService2023'\n}\n\n/**\n * PaymentRequestDataType type for payment requests\n * @beta\n * @enum {string}\n */\nexport enum PaymentRequestDataType {\n  Iden3PaymentRequestCryptoV1 = 'Iden3PaymentRequestCryptoV1',\n  Iden3PaymentRailsRequestV1 = 'Iden3PaymentRailsRequestV1',\n  Iden3PaymentRailsERC20RequestV1 = 'Iden3PaymentRailsERC20RequestV1'\n}\n\n/**\n * PaymentType type for payment responses\n * @beta\n * @enum {string}\n */\nexport enum PaymentType {\n  Iden3PaymentCryptoV1 = 'Iden3PaymentCryptoV1',\n  Iden3PaymentRailsV1 = 'Iden3PaymentRailsV1',\n  Iden3PaymentRailsERC20V1 = 'Iden3PaymentRailsERC20V1'\n}\n\n/**\n * SupportedPaymentProofType type for payment proofs\n * @beta\n * @enum {string}\n */\nexport enum SupportedPaymentProofType {\n  EthereumEip712Signature2021 = 'EthereumEip712Signature2021'\n}\n\n/**\n * Media types for Payment supported currencies\n * @beta\n * @deprecated\n * @enum {string}\n */\nexport enum SupportedCurrencies {\n  ETH = 'ETH',\n  ETH_WEI = 'ETHWEI',\n  ETH_GWEI = 'ETHGWEI',\n  MATIC = 'MATIC',\n  POL = 'POL'\n}\n\n/**\n * Supported features for payment-request\n * @beta\n * @enum {string}\n */\nexport enum PaymentFeatures {\n  EIP_2612 = 'EIP-2612'\n}\n\n/**\n * DisplayMethodType type for display method\n *\n * @enum {string}\n */\nexport enum DisplayMethodType {\n  Iden3BasicDisplayMethodV1 = 'Iden3BasicDisplayMethodV1'\n}\n\n/**\n * Default cache max size for in-memory cache\n */\nexport const DEFAULT_CACHE_MAX_SIZE = 10_000;\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  BJJSignatureProof2021,\n  Iden3SparseMerkleTreeProof,\n  CredentialStatus,\n  RefreshService,\n  DisplayMethod\n} from './proof';\nimport {\n  Claim,\n  DID,\n  MerklizedRootPosition as MerklizedRootPositionCore,\n  IdPosition,\n  ClaimOptions,\n  getChainId\n} from '@iden3/js-iden3-core';\nimport { Proof, Hash, rootFromProof, verifyProof } from '@iden3/js-merkletree';\nimport { Merklizer, Options } from '@iden3/js-jsonld-merklization';\nimport { PublicKey, poseidon } from '@iden3/js-crypto';\nimport { CredentialRequest, CredentialStatusResolverRegistry } from '../credentials';\nimport { getUserDIDFromCredential } from '../credentials/utils';\nimport { byteEncoder, validateDIDDocumentAuth } from '../utils';\nimport {\n  CredentialStatusType,\n  MerklizedRootPosition,\n  ProofType,\n  SubjectPosition,\n  VerifiableConstants\n} from './constants';\nimport {\n  calculateCoreSchemaHash,\n  CoreClaimCreationOptions,\n  findCredentialType,\n  parseCoreClaimSlots\n} from './core-utils';\n\nimport { JsonDocumentObject } from '../iden3comm';\nimport jsonld from 'jsonld';\n\n/**\n * W3C Verifiable credential\n *\n * @public\n * @export\n * @class W3CCredential\n */\nexport class W3CCredential {\n  id = '';\n  '@context': string[] = [];\n  type: string[] = [];\n  expirationDate?: string;\n  refreshService?: RefreshService;\n  displayMethod?: DisplayMethod;\n  issuanceDate?: string;\n  credentialSubject: JsonDocumentObject = {};\n  credentialStatus!: CredentialStatus;\n  issuer = '';\n  credentialSchema!: CredentialSchema;\n  proof?: object | unknown[];\n\n  /**\n   *\n   * @param issuer - DID of the issuer\n   * @param request - Credential request\n   * @returns - W3C Credential\n   */\n  static fromCredentialRequest(issuer: DID, request: CredentialRequest): W3CCredential {\n    if (!request.id) {\n      throw new Error('Credential id is required');\n    }\n    if (!request.context) {\n      throw new Error('Credential context is required');\n    }\n\n    const context = [\n      VerifiableConstants.JSONLD_SCHEMA.W3C_CREDENTIAL_2018,\n      VerifiableConstants.JSONLD_SCHEMA.IDEN3_CREDENTIAL,\n      ...request.context\n    ];\n\n    const credentialType = [\n      VerifiableConstants.CREDENTIAL_TYPE.W3C_VERIFIABLE_CREDENTIAL,\n      request.type\n    ];\n\n    const credentialSubject = request.credentialSubject;\n    credentialSubject['type'] = request.type;\n\n    const cr = new W3CCredential();\n    cr.id = request.id;\n    cr['@context'] = context;\n    cr.type = credentialType;\n    cr.credentialSubject = credentialSubject;\n    cr.issuer = issuer.string();\n    cr.credentialSchema = {\n      id: request.credentialSchema,\n      type: VerifiableConstants.JSON_SCHEMA_VALIDATOR\n    };\n    cr.credentialStatus = W3CCredential.buildCredentialStatus(request, issuer);\n\n    request.expiration && (cr.expirationDate = new Date(request.expiration).toISOString());\n    request.refreshService && (cr.refreshService = request.refreshService);\n    request.displayMethod && (cr.displayMethod = request.displayMethod);\n    request.issuanceDate && (cr.issuanceDate = new Date(request.issuanceDate).toISOString());\n\n    return cr;\n  }\n\n  /**\n   * Builds credential status\n   * @param {CredentialRequest} request\n   * @returns `CredentialStatus`\n   */\n  private static buildCredentialStatus(request: CredentialRequest, issuer: DID): CredentialStatus {\n    const credentialStatus: CredentialStatus = {\n      id: request.revocationOpts.id,\n      type: request.revocationOpts.type,\n      revocationNonce: request.revocationOpts.nonce\n    };\n\n    switch (request.revocationOpts.type) {\n      case CredentialStatusType.SparseMerkleTreeProof:\n        return {\n          ...credentialStatus,\n          id: `${credentialStatus.id.replace(/\\/$/, '')}/${credentialStatus.revocationNonce}`\n        };\n      case CredentialStatusType.Iden3ReverseSparseMerkleTreeProof:\n        return {\n          ...credentialStatus,\n          id: request.revocationOpts.issuerState\n            ? `${credentialStatus.id.replace(/\\/$/, '')}/node?state=${\n                request.revocationOpts.issuerState\n              }`\n            : `${credentialStatus.id.replace(/\\/$/, '')}`\n        };\n      case CredentialStatusType.Iden3OnchainSparseMerkleTreeProof2023: {\n        const issuerId = DID.idFromDID(issuer);\n        const chainId = getChainId(DID.blockchainFromId(issuerId), DID.networkIdFromId(issuerId));\n        const searchParams = [\n          ['revocationNonce', request.revocationOpts.nonce?.toString() || ''],\n          ['contractAddress', `${chainId}:${request.revocationOpts.id}`],\n          ['state', request.revocationOpts.issuerState || '']\n        ]\n          .filter(([, value]) => Boolean(value))\n          .map(([key, value]) => `${key}=${value}`)\n          .join('&');\n\n        return {\n          ...credentialStatus,\n          // `[did]:[methodid]:[chain]:[network]:[id]/credentialStatus?(revocationNonce=value)&[contractAddress=[chainID]:[contractAddress]]&(state=issuerState)`\n          id: `${issuer.string()}/credentialStatus?${searchParams}`\n        };\n      }\n      default:\n        return credentialStatus;\n    }\n  }\n\n  toJSON() {\n    return {\n      ...this,\n      proof: Array.isArray(this.proof)\n        ? this.proof.map(this.proofToJSON)\n        : this.proofToJSON(this.proof)\n    };\n  }\n\n  private proofToJSON(p: any) {\n    if (!p) {\n      return p;\n    }\n    if (!p['type']) {\n      throw new Error('proof must have type property');\n    }\n    switch (p.type) {\n      case ProofType.Iden3SparseMerkleTreeProof:\n      case ProofType.BJJSignature:\n        return p.toJSON();\n      default:\n        return p;\n    }\n  }\n\n  private static proofFromJSON = (p: any) => {\n    if (!p) {\n      return p;\n    }\n    if (!p['type']) {\n      throw new Error('proof must have type property');\n    }\n    switch (p.type) {\n      case ProofType.Iden3SparseMerkleTreeProof:\n        return Iden3SparseMerkleTreeProof.fromJSON(p);\n      case ProofType.BJJSignature:\n        return BJJSignatureProof2021.fromJSON(p);\n      default:\n        return p;\n    }\n  };\n\n  static fromJSON(obj: any): W3CCredential {\n    const w = new W3CCredential();\n    Object.assign(w, structuredClone(obj));\n    w.proof = Array.isArray(w.proof)\n      ? w.proof.map(W3CCredential.proofFromJSON)\n      : W3CCredential.proofFromJSON(w.proof);\n\n    return w;\n  }\n  /**\n   * merklization of the verifiable credential\n   *\n   * @returns `Promise<Merklizer>`\n   */\n  async merklize(opts?: Options): Promise<Merklizer> {\n    const credential = { ...this };\n    delete credential.proof;\n    return await Merklizer.merklizeJSONLD(JSON.stringify(credential), opts);\n  }\n\n  /**\n   * gets core claim representation from credential proof\n   *\n   * @param {ProofType} proofType\n   * @returns {*}  {(Claim | undefined)}\n   */\n  getCoreClaimFromProof(proofType: ProofType): Claim | undefined {\n    if (Array.isArray(this.proof)) {\n      for (const proof of this.proof) {\n        const { claim, proofType: extractedProofType } = extractProof(proof);\n        if (proofType === extractedProofType) {\n          return claim;\n        }\n      }\n    } else if (typeof this.proof === 'object') {\n      const { claim, proofType: extractedProofType } = extractProof(this.proof);\n      if (extractedProofType == proofType) {\n        return claim;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * gets core claim representation from W3CCredential\n   *\n   * @param {CoreClaimParsingOptions} [opts] - options to create core claim\n   * @returns {*}  {(Promise<Claim>)}\n   */\n  async toCoreClaim(opts?: CoreClaimCreationOptions): Promise<Claim> {\n    if (!opts) {\n      opts = {\n        revNonce: 0,\n        version: 0,\n        subjectPosition: SubjectPosition.Index,\n        merklizedRootPosition: MerklizedRootPosition.None,\n        updatable: false,\n        merklizeOpts: {}\n      };\n    }\n\n    const mz = await this.merklize(opts.merklizeOpts);\n\n    const credentialType = findCredentialType(mz);\n\n    const subjectId = this.credentialSubject['id'];\n\n    const ldCtx = await jsonld.processContext(\n      await jsonld.processContext(null, null, {}),\n      this['@context'] as jsonld.JsonLdDocument,\n      mz.options\n    );\n\n    const { slots, nonMerklized } = await parseCoreClaimSlots(\n      ldCtx as unknown as { mappings: Map<string, Record<string, unknown>> },\n      mz,\n      credentialType\n    );\n\n    // if schema is for non merklized credential, root position must be set to none ('')\n    // otherwise default position for merklized position is index.\n    if (nonMerklized && opts.merklizedRootPosition !== MerklizedRootPosition.None) {\n      throw new Error('merklized root position is not supported for non-merklized claims');\n    }\n    if (!nonMerklized && opts.merklizedRootPosition === MerklizedRootPosition.None) {\n      opts.merklizedRootPosition = MerklizedRootPosition.Index;\n    }\n\n    const schemaHash = calculateCoreSchemaHash(byteEncoder.encode(credentialType));\n    const claim = Claim.newClaim(\n      schemaHash,\n      ClaimOptions.withIndexDataBytes(slots.indexA, slots.indexB),\n      ClaimOptions.withValueDataBytes(slots.valueA, slots.valueB),\n      ClaimOptions.withRevocationNonce(BigInt(opts.revNonce)),\n      ClaimOptions.withVersion(opts.version)\n    );\n\n    if (opts.updatable) {\n      claim.setFlagUpdatable(opts.updatable);\n    }\n    if (this.expirationDate) {\n      claim.setExpirationDate(new Date(this.expirationDate));\n    }\n    if (subjectId) {\n      const did = DID.parse(subjectId.toString());\n      const id = DID.idFromDID(did);\n\n      switch (opts.subjectPosition) {\n        case '':\n        case SubjectPosition.Index:\n          claim.setIndexId(id);\n          break;\n        case SubjectPosition.Value:\n          claim.setValueId(id);\n          break;\n        default:\n          throw new Error('unknown subject position');\n      }\n    }\n\n    switch (opts.merklizedRootPosition) {\n      case MerklizedRootPosition.Index: {\n        const mk = await this.merklize(opts.merklizeOpts);\n        claim.setIndexMerklizedRoot((await mk.root()).bigInt());\n        break;\n      }\n      case MerklizedRootPosition.Value: {\n        const mk = await this.merklize(opts.merklizeOpts);\n        claim.setValueMerklizedRoot((await mk.root()).bigInt());\n        break;\n      }\n      case MerklizedRootPosition.None:\n        break;\n      default:\n        throw new Error('unknown merklized root position');\n    }\n\n    return claim;\n  }\n\n  /**\n   * checks BJJSignatureProof2021 in W3C VC\n   *\n   * @returns BJJSignatureProof2021 | undefined\n   */\n  getBJJSignature2021Proof(): BJJSignatureProof2021 | undefined {\n    const proof = this.getProofByType(ProofType.BJJSignature);\n    if (proof) {\n      return proof as BJJSignatureProof2021;\n    }\n    return undefined;\n  }\n\n  /**\n   * checks Iden3SparseMerkleTreeProof in W3C VC\n   *\n   * @returns {*}  {(Iden3SparseMerkleTreeProof | undefined)}\n   */\n  getIden3SparseMerkleTreeProof(): Iden3SparseMerkleTreeProof | undefined {\n    const proof = this.getProofByType(ProofType.Iden3SparseMerkleTreeProof);\n    if (proof) {\n      return proof as Iden3SparseMerkleTreeProof;\n    }\n    return undefined;\n  }\n\n  /**\n   * Verify credential proof\n   *\n   * @returns {*}  {(boolean)}\n   */\n  async verifyProof(\n    proofType: ProofType,\n    resolverURL: string,\n    opts?: W3CProofVerificationOptions\n  ): Promise<boolean> {\n    const proof = this.getProofByType(proofType);\n    if (!proof) {\n      throw new Error('proof not found');\n    }\n\n    const coreClaim = this.getCoreClaimFromProof(proofType);\n    if (!coreClaim) {\n      throw new Error(`can't get core claim`);\n    }\n\n    await this.verifyCoreClaimMatch(coreClaim, opts?.merklizeOptions);\n\n    switch (proofType) {\n      case ProofType.BJJSignature: {\n        if (!opts?.credStatusResolverRegistry) {\n          throw new Error('please provide credential status resolver registry');\n        }\n        const bjjProof = proof as BJJSignatureProof2021;\n        const userDID = getUserDIDFromCredential(bjjProof.issuerData.id, this);\n        return this.verifyBJJSignatureProof(\n          bjjProof,\n          coreClaim,\n          resolverURL,\n          userDID,\n          opts.credStatusResolverRegistry\n        );\n      }\n      case ProofType.Iden3SparseMerkleTreeProof: {\n        return this.verifyIden3SparseMerkleTreeProof(\n          proof as Iden3SparseMerkleTreeProof,\n          coreClaim,\n          resolverURL\n        );\n      }\n      default: {\n        throw new Error('invalid proof type');\n      }\n    }\n  }\n\n  private async verifyCoreClaimMatch(coreClaim: Claim, merklizeOpts?: Options) {\n    let merklizedRootPosition = '';\n\n    const merklizedPosition = coreClaim.getMerklizedPosition();\n    switch (merklizedPosition) {\n      case MerklizedRootPositionCore.None:\n        merklizedRootPosition = MerklizedRootPosition.None;\n        break;\n      case MerklizedRootPositionCore.Index:\n        merklizedRootPosition = MerklizedRootPosition.Index;\n        break;\n      case MerklizedRootPositionCore.Value:\n        merklizedRootPosition = MerklizedRootPosition.Value;\n        break;\n    }\n\n    let subjectPosition = '';\n    const idPosition = coreClaim.getIdPosition();\n    switch (idPosition) {\n      case IdPosition.None:\n        subjectPosition = SubjectPosition.None;\n        break;\n      case IdPosition.Index:\n        subjectPosition = SubjectPosition.Index;\n        break;\n      case IdPosition.Value:\n        subjectPosition = SubjectPosition.Value;\n        break;\n    }\n\n    const coreClaimOpts: CoreClaimCreationOptions = {\n      revNonce: Number(coreClaim.getRevocationNonce()),\n      version: coreClaim.getVersion(),\n      merklizedRootPosition,\n      subjectPosition,\n      updatable: coreClaim.getFlagUpdatable(),\n      merklizeOpts: merklizeOpts\n    };\n\n    const credentialCoreClaim = await this.toCoreClaim(coreClaimOpts);\n    if (coreClaim.hex() != credentialCoreClaim.hex()) {\n      throw new Error('proof generated for another credential');\n    }\n  }\n\n  private async verifyBJJSignatureProof(\n    proof: BJJSignatureProof2021,\n    coreClaim: Claim,\n    resolverURL: string,\n    userDID: DID,\n    credStatusResolverRegistry: CredentialStatusResolverRegistry\n  ): Promise<boolean> {\n    // issuer auth claim\n    const authClaim = proof.issuerData.authCoreClaim;\n    const rawSlotsInt = authClaim.rawSlotsAsInts();\n    const pubKey = new PublicKey([rawSlotsInt[2], rawSlotsInt[3]]);\n\n    // core claim hash\n    const { hi, hv } = coreClaim.hiHv();\n    const claimHash = poseidon.hash([hi, hv]);\n    const bjjValid = pubKey.verifyPoseidon(claimHash, proof.signature);\n\n    if (!bjjValid) {\n      throw new Error('signature is not valid');\n    }\n    await validateDIDDocumentAuth(proof.issuerData.id, resolverURL, proof.issuerData.state.value);\n\n    const credStatusType = proof.issuerData.credentialStatus.type;\n    const credStatusResolver = await credStatusResolverRegistry.get(credStatusType);\n    if (!credStatusResolver) {\n      throw new Error(`please register credential status resolver for ${credStatusType} type`);\n    }\n    const credStatus = await credStatusResolver.resolve(proof.issuerData.credentialStatus, {\n      issuerDID: proof.issuerData.id,\n      userDID: userDID\n    });\n    const stateValid = validateTreeState(credStatus.issuer);\n    if (!stateValid) {\n      throw new Error(\n        'signature proof: invalid tree state of the issuer while checking credential status of singing key'\n      );\n    }\n\n    const revocationNonce = BigInt(proof.issuerData.credentialStatus.revocationNonce || 0);\n    if (revocationNonce !== proof.issuerData.authCoreClaim.getRevocationNonce()) {\n      throw new Error(\n        `revocation nonce mismatch: revocation nonce from core representation of auth credential is not the same as in its credential`\n      );\n    }\n    const proofValid = await verifyProof(\n      Hash.fromHex(credStatus.issuer.revocationTreeRoot),\n      credStatus.mtp,\n      revocationNonce,\n      BigInt(0)\n    );\n    if (!proofValid) {\n      throw new Error(`proof validation failed. revNonce=${revocationNonce}`);\n    }\n    if (credStatus.mtp.existence) {\n      throw new Error('signature proof: singing key of the issuer is revoked');\n    }\n    return true;\n  }\n\n  private async verifyIden3SparseMerkleTreeProof(\n    proof: Iden3SparseMerkleTreeProof,\n    coreClaim: Claim,\n    resolverURL: string\n  ): Promise<boolean> {\n    await validateDIDDocumentAuth(proof.issuerData.id, resolverURL, proof.issuerData.state.value);\n    // root from proof == issuerData.state.claimsTreeRoot\n    const { hi, hv } = coreClaim.hiHv();\n    const rootFromProofValue = await rootFromProof(proof.mtp, hi, hv);\n    if (!rootFromProofValue.equals(proof.issuerData.state.claimsTreeRoot)) {\n      throw new Error(\n        'verifyIden3SparseMerkleTreeProof: root from proof not equal to issuer data claims tree root'\n      );\n    }\n    return true;\n  }\n\n  private getProofByType(proofType: ProofType): unknown | undefined {\n    if (Array.isArray(this.proof)) {\n      for (const proof of this.proof) {\n        if ((proof as { [k: string]: ProofType })?.type === proofType) {\n          return proof;\n        }\n      }\n    } else if ((this.proof as { [k: string]: ProofType })?.type == proofType) {\n      return this.proof;\n    }\n    return undefined;\n  }\n}\n\n/**\n * extracts core claim from Proof and returns Proof Type\n *\n * @param {object} proof - proof of vc\n * @returns {*}  {{ claim: Claim; proofType: ProofType }}\n */\nexport function extractProof(proof: object): { claim: Claim; proofType: ProofType } {\n  if (proof instanceof Iden3SparseMerkleTreeProof) {\n    return {\n      claim: proof.coreClaim,\n      proofType: ProofType.Iden3SparseMerkleTreeProof\n    };\n  }\n  if (proof instanceof BJJSignatureProof2021) {\n    return { claim: proof.coreClaim, proofType: ProofType.BJJSignature };\n  }\n  if (typeof proof === 'object') {\n    const p = proof as { type: ProofType; coreClaim: string | Claim };\n    const defaultProofType: ProofType = p.type;\n    if (!defaultProofType) {\n      throw new Error('proof type is not specified');\n    }\n\n    if (!p.coreClaim) {\n      throw new Error(`coreClaim field is not defined in proof type ${defaultProofType}`);\n    }\n\n    const coreClaim = p.coreClaim instanceof Claim ? p.coreClaim : new Claim().fromHex(p.coreClaim);\n\n    return { claim: coreClaim, proofType: defaultProofType as ProofType };\n  }\n\n  throw new Error('proof format is not supported');\n}\n\n/**\n * validate tree state by recalculating poseidon hash of roots and comparing with state\n *\n * @param {Issuer} treeState - issuer struct\n * @returns {boolean}\n */\nexport function validateTreeState(treeState: Issuer) {\n  const ctrHash = treeState.claimsTreeRoot ? Hash.fromHex(treeState.claimsTreeRoot) : new Hash();\n  const rtrHash = treeState.revocationTreeRoot\n    ? Hash.fromHex(treeState.revocationTreeRoot)\n    : new Hash();\n  const rorHash = treeState.rootOfRoots ? Hash.fromHex(treeState.rootOfRoots) : new Hash();\n  const wantState = poseidon.hash([ctrHash.bigInt(), rtrHash.bigInt(), rorHash.bigInt()]);\n\n  const stateHash = treeState.state ? Hash.fromHex(treeState.state) : new Hash();\n  return wantState === stateHash.bigInt();\n}\n\n/**\n * Credential schema vc\n *\n * @public\n * @interface   CredentialSchema\n */\nexport interface CredentialSchema {\n  id: string;\n  type: string;\n}\n\n/**\n * Issuer tree information\n *\n * @public\n * @interface   Issuer\n */\nexport interface Issuer {\n  state?: string;\n  rootOfRoots?: string;\n  claimsTreeRoot?: string;\n  revocationTreeRoot?: string;\n}\n\n/**\n *\n * RevocationStatus status of revocation nonce. Info required to check revocation state of claim in circuits\n * @public\n * @interface   RevocationStatus\n */\nexport interface RevocationStatus {\n  mtp: Proof;\n  issuer: Issuer;\n}\n\n/**\n *\n * Proof verification options\n * @public\n * @interface   W3CProofVerificationOptions\n */\nexport interface W3CProofVerificationOptions {\n  credStatusResolverRegistry?: CredentialStatusResolverRegistry;\n  merklizeOptions?: Options;\n}\n","import { DID } from '@iden3/js-iden3-core';\nimport { W3CCredential } from '../verifiable';\nimport { PublicKey } from '@iden3/js-crypto';\nimport { KmsKeyId, KmsKeyType, keyPath } from '../kms';\n\n/**\n * Retrieves the user DID from a given credential.\n * If the credential does not have a credentialSubject.id property, the issuer DID is returned.\n * If the credentialSubject.id is not a string, an error is thrown.\n * @param issuerDID The DID of the issuer.\n * @param credential The credential object.\n * @returns The user DID parsed from the credential.\n * @throws Error if the credentialSubject.id is not a string.\n */\nexport const getUserDIDFromCredential = (issuerDID: DID, credential: W3CCredential) => {\n  if (!credential.credentialSubject.id) {\n    return issuerDID;\n  }\n\n  if (typeof credential.credentialSubject.id !== 'string') {\n    throw new Error('credential subject `id` is not a string');\n  }\n  return DID.parse(credential.credentialSubject.id);\n};\n\nexport const getKMSIdByAuthCredential = (credential: W3CCredential): KmsKeyId => {\n  if (!credential.type.includes('AuthBJJCredential')) {\n    throw new Error(\"can't sign with not AuthBJJCredential credential\");\n  }\n  const x = credential.credentialSubject['x'] as string;\n  const y = credential.credentialSubject['y'] as string;\n\n  const pb: PublicKey = new PublicKey([BigInt(x), BigInt(y)]);\n  const kp = keyPath(KmsKeyType.BabyJubJub, pb.hex());\n  return { type: KmsKeyType.BabyJubJub, id: kp };\n};\n","import { BytesHelper, SchemaHash } from '@iden3/js-iden3-core';\nimport { Merklizer, Options, Path } from '@iden3/js-jsonld-merklization';\nimport { byteDecoder, hexToBytes } from '../utils';\nimport jsonld from 'jsonld';\nimport { keccak256 } from 'ethers';\n\nconst credentialSubjectKey = 'credentialSubject';\nconst contextFullKey = '@context';\nconst serializationFullKey = 'iden3_serialization';\nconst fieldPrefix = 'iden3:v1:';\nconst credentialSubjectFullKey = 'https://www.w3.org/2018/credentials#credentialSubject';\nconst verifiableCredentialFullKey = 'https://www.w3.org/2018/credentials#VerifiableCredential';\nconst typeFullKey = '@type';\n\ntype ParsedCtx = { mappings: Map<string, Record<string, unknown>> };\n\n/**\n * CoreClaimCreationOptions is params for core claim creation\n *\n * @public\n * @interface   CoreClaimCreationOptions\n */\nexport interface CoreClaimCreationOptions {\n  revNonce: number;\n  version: number;\n  subjectPosition: string;\n  merklizedRootPosition: string;\n  updatable: boolean;\n  merklizeOpts?: Options;\n}\n\n/**\n * Parsed slots of core.Claim\n *\n * @public\n * @interface   CoreClaimParsedSlots\n */\nexport interface CoreClaimParsedSlots {\n  indexA: Uint8Array;\n  indexB: Uint8Array;\n  valueA: Uint8Array;\n  valueB: Uint8Array;\n}\n\n/**\n * Slots paths of core.Claim\n *\n * @public\n * @interface   CoreClaimSlotsPaths\n */\nexport interface CoreClaimSlotsPaths {\n  indexAPath: string;\n  indexBPath: string;\n  valueAPath: string;\n  valueBPath: string;\n}\n\n/**\n * GetFieldSlotIndex return index of slot from 0 to 7 (each claim has by default 8 slots) for non-merklized claims\n *\n * @param {string} field - field name\n * @param {Uint8Array} schemaBytes -json schema bytes\n * @returns `number`\n */\nexport const getFieldSlotIndex = async (\n  field: string,\n  typeName: string,\n  schemaBytes: Uint8Array\n): Promise<number> => {\n  let ctxDoc = JSON.parse(byteDecoder.decode(schemaBytes));\n  ctxDoc = ctxDoc[contextFullKey];\n  if (ctxDoc === undefined) {\n    throw new Error('document has no @context');\n  }\n\n  const ldCtx = await jsonld.processContext(\n    await jsonld.processContext(null, null, {}),\n    ctxDoc,\n    {}\n  );\n\n  const serAttr = await getSerializationAttrFromParsedContext(\n    ldCtx as unknown as ParsedCtx,\n    typeName\n  );\n\n  if (!serAttr) {\n    throw new Error('serialization attribute is not set');\n  }\n\n  const sPaths = parseSerializationAttr(serAttr);\n\n  switch (field) {\n    case sPaths.indexAPath:\n      return 2;\n    case sPaths.indexBPath:\n      return 3;\n    case sPaths.valueAPath:\n      return 6;\n    case sPaths.valueBPath:\n      return 7;\n    default:\n      throw new Error(`field ${field} not specified in serialization info`);\n  }\n};\n\n/**\n * checks if data can fill the slot\n *\n * @param {Uint8Array} slotData - slot data\n * @param {Merklizer} mz - merklizer\n * @param {string} path - path\n * @returns {void}\n */\nexport const fillCoreClaimSlot = async (\n  slotData: Uint8Array,\n  mz: Merklizer,\n  path: string\n): Promise<void> => {\n  if (!path) {\n    return;\n  }\n\n  path = credentialSubjectKey + '.' + path;\n\n  try {\n    const p = await mz.resolveDocPath(path, mz.options);\n    const entry = await mz.entry(p);\n    const intVal = await entry.getValueMtEntry();\n\n    const bytesVal = BytesHelper.intToBytes(intVal);\n    slotData.set(bytesVal, 0);\n  } catch (err: unknown) {\n    if ((err as Error).toString().includes('entry not found')) {\n      throw new Error(`field not found in credential ${path}`);\n    }\n\n    throw err;\n  }\n};\n\n// Get `iden3_serialization` attr definition from context document either using\n// type name like DeliverAddressMultiTestForked or by type id like\n// urn:uuid:ac2ede19-b3b9-454d-b1a9-a7b3d5763100.\nexport const getSerializationAttrFromContext = async (\n  context: object,\n  opts: Options,\n  tp: string\n): Promise<string> => {\n  const ldCtx = await jsonld.processContext(\n    await jsonld.processContext(null, null, {}),\n    context,\n    opts\n  );\n\n  return getSerializationAttrFromParsedContext(ldCtx as unknown as ParsedCtx, tp);\n};\n\nexport const getSerializationAttrFromParsedContext = async (\n  ldCtx: ParsedCtx,\n  tp: string\n): Promise<string> => {\n  const termDef = ldCtx.mappings;\n  if (!termDef) {\n    throw new Error('terms definitions is not of correct type');\n  }\n\n  const term = termDef.get(tp) ?? [...termDef.values()].find((value) => value['@id'] === tp);\n\n  if (!term) {\n    return '';\n  }\n\n  const termCtx = term[contextFullKey];\n\n  if (!termCtx) {\n    throw new Error('type @context is not of correct type');\n  }\n\n  const serStr = (termCtx as Record<string, string>)[serializationFullKey] ?? '';\n  return serStr;\n};\n\nexport const parseSerializationAttr = (serAttr: string): CoreClaimSlotsPaths => {\n  if (!serAttr.startsWith(fieldPrefix)) {\n    throw new Error('serialization attribute does not have correct prefix');\n  }\n  const parts = serAttr.slice(fieldPrefix.length).split('&');\n  if (parts.length > 4) {\n    throw new Error('serialization attribute has too many parts');\n  }\n\n  const paths = {} as CoreClaimSlotsPaths;\n  for (const part of parts) {\n    const kv = part.split('=');\n    if (kv.length !== 2) {\n      throw new Error('serialization attribute part does not have correct format');\n    }\n    switch (kv[0]) {\n      case 'slotIndexA':\n        paths.indexAPath = kv[1];\n        break;\n      case 'slotIndexB':\n        paths.indexBPath = kv[1];\n        break;\n      case 'slotValueA':\n        paths.valueAPath = kv[1];\n        break;\n      case 'slotValueB':\n        paths.valueBPath = kv[1];\n        break;\n      default:\n        throw new Error('unknown serialization attribute slot');\n    }\n  }\n  return paths;\n};\n\nexport const findCredentialType = (mz: Merklizer): string => {\n  const opts = mz.options;\n\n  try {\n    // try to look into credentialSubject.@type to get type of credentials\n    const path1 = new Path([credentialSubjectFullKey, typeFullKey], opts.hasher);\n    const e = mz.rawValue(path1);\n    return e as string;\n  } catch (err) {\n    // if type of credentials not found in credentialSubject.@type, loop at\n    // top level @types if it contains two elements: type we are looking for\n    // and \"VerifiableCredential\" type.\n    const path2 = new Path([typeFullKey], opts.hasher);\n\n    const topLevelTypes = mz.rawValue(path2);\n    if (!Array.isArray(topLevelTypes)) {\n      throw new Error('top level @type expected to be an array');\n    }\n\n    if (topLevelTypes.length !== 2) {\n      throw new Error('top level @type expected to be of length 2');\n    }\n\n    switch (verifiableCredentialFullKey) {\n      case topLevelTypes[0]:\n        return topLevelTypes[1];\n      case topLevelTypes[1]:\n        return topLevelTypes[0];\n      default:\n        throw new Error('@type(s) are expected to contain VerifiableCredential type');\n    }\n  }\n};\n\n/**\n * parseCoreClaimSlots converts payload to claim slots using provided schema\n *\n * @param { { mappings: Map<string, Record<string, unknown>> } } ldCtx - ldCtx\n * @param {Merklizer} mz - Merklizer\n * @param {string} credentialType - credential type\n * @returns `Promise<{ slots: ParsedSlots; nonMerklized: boolean }>`\n */\nexport const parseCoreClaimSlots = async (\n  ldCtx: { mappings: Map<string, Record<string, unknown>> },\n  mz: Merklizer,\n  credentialType: string\n): Promise<{ slots: CoreClaimParsedSlots; nonMerklized: boolean }> => {\n  // parseSlots converts payload to claim slots using provided schema\n\n  const slots = {\n    indexA: new Uint8Array(32),\n    indexB: new Uint8Array(32),\n    valueA: new Uint8Array(32),\n    valueB: new Uint8Array(32)\n  };\n\n  const serAttr = await getSerializationAttrFromParsedContext(ldCtx, credentialType);\n\n  if (!serAttr) {\n    return { slots, nonMerklized: false };\n  }\n\n  const sPaths = parseSerializationAttr(serAttr);\n  const isSPathEmpty = !Object.values(sPaths).some(Boolean);\n  if (isSPathEmpty) {\n    return { slots, nonMerklized: true };\n  }\n\n  await fillCoreClaimSlot(slots.indexA, mz, sPaths.indexAPath);\n\n  await fillCoreClaimSlot(slots.indexB, mz, sPaths.indexBPath);\n\n  await fillCoreClaimSlot(slots.valueA, mz, sPaths.valueAPath);\n\n  await fillCoreClaimSlot(slots.valueB, mz, sPaths.valueBPath);\n\n  return { slots, nonMerklized: true };\n};\n\n/**\n * Calculates core schema hash\n *\n * @param {Uint8Array} schemaId\n * @returns {*}  {SchemaHash}\n */\nexport const calculateCoreSchemaHash = (schemaId: Uint8Array): SchemaHash => {\n  const sHash = hexToBytes(keccak256(schemaId));\n  return new SchemaHash(sHash.slice(sHash.length - 16, sHash.length));\n};\n","import { VerifiableConstants } from './constants';\nimport { Options, Path } from '@iden3/js-jsonld-merklization';\nimport { W3CCredential } from './credential';\nimport { QueryMetadata } from '../proof';\nimport { VerifiablePresentation, JsonDocumentObject } from '../iden3comm';\n\nexport const stringByPath = (obj: { [key: string]: unknown }, path: string): string => {\n  const parts = path.split('.');\n\n  let value = obj;\n  for (let index = 0; index < parts.length; index++) {\n    const key = parts[index];\n    if (!key) {\n      throw new Error('path is empty');\n    }\n    value = value[key] as { [key: string]: unknown };\n    if (value === undefined) {\n      throw new Error('path not found');\n    }\n  }\n  return value.toString();\n};\n\nexport const buildFieldPath = async (\n  ldSchema: string,\n  contextType: string,\n  field: string,\n  opts?: Options\n): Promise<Path> => {\n  let path = new Path();\n\n  if (field) {\n    path = await Path.getContextPathKey(ldSchema, contextType, field, opts);\n  }\n  path.prepend([VerifiableConstants.CREDENTIAL_SUBJECT_PATH]);\n  return path;\n};\n\nexport const findValue = (fieldName: string, credential: W3CCredential): JsonDocumentObject => {\n  const [first, ...rest] = fieldName.split('.');\n  let v = credential.credentialSubject[first];\n  for (const part of rest) {\n    v = (v as JsonDocumentObject)[part];\n  }\n  return v as JsonDocumentObject;\n};\n\nexport const createVerifiablePresentation = (\n  context: string,\n  tp: string,\n  credential: W3CCredential,\n  queries: QueryMetadata[]\n): VerifiablePresentation => {\n  const baseContext = [VerifiableConstants.JSONLD_SCHEMA.W3C_CREDENTIAL_2018];\n  const ldContext = baseContext[0] === context ? baseContext : [...baseContext, context];\n\n  const vc = VerifiableConstants.CREDENTIAL_TYPE.W3C_VERIFIABLE_CREDENTIAL;\n  const vcTypes = [vc];\n  if (tp !== vc) {\n    vcTypes.push(tp);\n  }\n\n  const skeleton = {\n    '@context': baseContext,\n    type: VerifiableConstants.CREDENTIAL_TYPE.W3C_VERIFIABLE_PRESENTATION,\n    verifiableCredential: {\n      '@context': ldContext,\n      type: vcTypes,\n      credentialSubject: {\n        type: tp\n      }\n    }\n  };\n\n  let result: JsonDocumentObject = {};\n  for (const query of queries) {\n    const parts = query.fieldName.split('.');\n    const current: JsonDocumentObject = parts.reduceRight(\n      (acc: JsonDocumentObject, part: string) => {\n        if (result[part]) {\n          return { [part]: { ...(result[part] as JsonDocumentObject), ...acc } };\n        }\n        return { [part]: acc };\n      },\n      findValue(query.fieldName, credential) as JsonDocumentObject\n    );\n\n    result = { ...result, ...current };\n  }\n\n  skeleton.verifiableCredential.credentialSubject = {\n    ...skeleton.verifiableCredential.credentialSubject,\n    ...result\n  };\n\n  return skeleton;\n};\n","/** DIDDocumentJSONSchema is a basic schema of did document */\nexport const DIDDocumentJSONSchema = `{\n  \"type\": \"object\",\n  \"$defs\": {\n    \"serviceEndpoint\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": {\n          \"type\": \"string\"\n        },\n        \"type\": {\n          \"type\": \"string\"\n        },\n        \"serviceEndpoint\": {\n          \"type\": \"string\"\n        },\n        \"metadata\": {\n          \"type\": \"object\"\n        }\n      },\n      \"required\": [\n        \"id\",\n        \"type\",\n        \"serviceEndpoint\"\n      ]\n    },\n    \"jsonWebKey\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"alg\": {\n          \"type\": \"string\"\n        },\n        \"crv\": {\n          \"type\": \"string\"\n        },\n        \"e\": {\n          \"type\": \"string\"\n        },\n        \"ext\": {\n          \"type\": \"boolean\"\n        },\n        \"key_ops\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n          }\n        },\n        \"kid\": {\n          \"type\": \"string\"\n        },\n        \"kty\": {\n          \"type\": \"string\"\n        },\n        \"n\": {\n          \"type\": \"string\"\n        },\n        \"use\": {\n          \"type\": \"string\"\n        },\n        \"x\": {\n          \"type\": \"string\"\n        },\n        \"y\": {\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"kty\"\n      ],\n      \"description\": \"Public parts of JSON web key\"\n    },\n    \"verificationMethod\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"id\": {\n          \"type\": \"string\"\n        },\n        \"type\": {\n          \"type\": \"string\"\n        },\n        \"controller\": {\n          \"type\": \"string\"\n        },\n        \"publicKeyBase58\": {\n          \"type\": \"string\"\n        },\n        \"publicKeyBase64\": {\n          \"type\": \"string\"\n        },\n        \"publicKeyJwk\": {\n          \"$ref\": \"#/$defs/jsonWebKey\"\n        },\n        \"publicKeyHex\": {\n          \"type\": \"string\"\n        },\n        \"publicKeyMultibase\": {\n          \"type\": \"string\"\n        },\n        \"blockchainAccountId\": {\n          \"type\": \"string\"\n        },\n        \"ethereumAddress\": {\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"id\",\n        \"type\",\n        \"controller\"\n      ]\n    }\n  },\n  \"properties\": {\n    \"authentication\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"anyOf\": [\n          {\n            \"type\": \"string\"\n          },\n          {\n            \"$ref\": \"#/$defs/verificationMethod\"\n          }\n        ]\n      }\n    },\n    \"assertionMethod\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"anyOf\": [\n          {\n            \"type\": \"string\"\n          },\n          {\n            \"$ref\": \"#/$defs/verificationMethod\"\n          }\n        ]\n      }\n    },\n    \"keyAgreement\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"anyOf\": [\n          {\n            \"type\": \"string\"\n          },\n          {\n            \"$ref\": \"#/$defs/verificationMethod\"\n          }\n        ]\n      }\n    },\n    \"capabilityInvocation\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"anyOf\": [\n          {\n            \"type\": \"string\"\n          },\n          {\n            \"$ref\": \"#/$defs/verificationMethod\"\n          }\n        ]\n      }\n    },\n    \"capabilityDelegation\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"anyOf\": [\n          {\n            \"type\": \"string\"\n          },\n          {\n            \"$ref\": \"#/$defs/verificationMethod\"\n          }\n        ]\n      }\n    },\n    \"@context\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\",\n          \"const\": \"https://www.w3.org/ns/did/v1\"\n        },\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n          }\n        }\n      ]\n    },\n    \"id\": {\n      \"type\": \"string\"\n    },\n    \"alsoKnownAs\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\"\n      }\n    },\n    \"controller\": {\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n          }\n        }\n      ]\n    },\n    \"verificationMethod\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/$defs/verificationMethod\"\n      }\n    },\n    \"service\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/$defs/serviceEndpoint\"\n      }\n    },\n    \"publicKey\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"$ref\": \"#/$defs/verificationMethod\"\n      },\n      \"deprecated\": true\n    }\n  },\n  \"required\": [\n    \"id\"\n  ]\n}`;\n","import { BytesHelper, checkBigIntInField, SchemaHash } from '@iden3/js-iden3-core';\nimport { Merklizer } from '@iden3/js-jsonld-merklization';\nimport { calculateCoreSchemaHash, fillCoreClaimSlot } from '../verifiable';\n\n/**\n * SwapEndianness swaps the endianness of the value encoded in buf. If buf is\n * Big-Endian, the result will be Little-Endian and vice-versa.\n *\n * @param {Uint8Array} buf - bytes to swap\n * @returns Uint8Array - swapped bytes\n */\nexport const swapEndianness = (buf: Uint8Array): Uint8Array => buf.reverse();\n\n/**\n * FieldToByteArray convert fields to byte representation based on type\n *\n * @param {unknown} field - field to convert\n * @returns Uint8Array\n */\nexport function fieldToByteArray(field: unknown): Uint8Array {\n  let bigIntField: bigint;\n\n  if (typeof field === 'string') {\n    bigIntField = BigInt(field);\n  } else if (typeof field === 'number') {\n    bigIntField = BigInt(Math.trunc(field));\n  } else {\n    throw new Error('field type is not supported');\n  }\n  return BytesHelper.intToBytes(bigIntField);\n}\n\n/**\n * checks if data fills into slot capacity ()\n *\n * @param {Uint8Array} slot - current slot data\n * @param {Uint8Array} newData - new slot data\n * @returns boolean\n */\nexport function dataFillsSlot(slot: Uint8Array, newData: Uint8Array): boolean {\n  return checkBigIntInField(BytesHelper.bytesToInt(Uint8Array.from([...slot, ...newData])));\n}\n\n/**\n * check if byte data is in Q field\n *\n * @param {Uint8Array} data - bytes payload\n * @returns boolean\n */\nexport function checkDataInField(data: Uint8Array): boolean {\n  return checkBigIntInField(BytesHelper.bytesToInt(data));\n}\n\n/**\n *\n * @deprecated The method should not be used. Use calculateCoreSchemaHash from verifiable.\n * Calculates schema hash\n *\n * @param {Uint8Array} schemaId\n * @returns {*}  {SchemaHash}\n */\nexport const createSchemaHash = (schemaId: Uint8Array): SchemaHash => {\n  return calculateCoreSchemaHash(schemaId);\n};\n\n/**\n *\n * @deprecated The method should not be used. Use fillCoreClaimSlot from verifiable.\n * checks if data can fill the slot\n *\n * @param {Uint8Array} slotData - slot data\n * @param {Merklizer} mz - merklizer\n * @param {string} path - path\n * @returns {void}\n */\nexport const fillSlot = async (\n  slotData: Uint8Array,\n  mz: Merklizer,\n  path: string\n): Promise<void> => {\n  return fillCoreClaimSlot(slotData, mz, path);\n};\n\nexport const credentialSubjectKey = 'credentialSubject';\n","import {\n  W3CCredential,\n  getSerializationAttrFromContext,\n  parseSerializationAttr,\n  getFieldSlotIndex,\n  findCredentialType,\n  CoreClaimCreationOptions,\n  CoreClaimParsedSlots,\n  CoreClaimSlotsPaths,\n  getSerializationAttrFromParsedContext,\n  parseCoreClaimSlots\n} from '../../verifiable';\nimport { Claim as CoreClaim } from '@iden3/js-iden3-core';\nimport { Merklizer, Options } from '@iden3/js-jsonld-merklization';\nimport jsonld from 'jsonld';\n\n/**\n *\n * @deprecated The interface should not be used. Use CoreClaimParsingOptions from verifiable package instead.\n * CoreClaimOptions is params for core claim parsing\n *\n * @public\n * @interface   CoreClaimOptions\n */\nexport type CoreClaimOptions = CoreClaimCreationOptions;\n\n/**\n * @deprecated The interface should not be used. Use CoreClaimParsedSlots from verifiable package instead.\n * Parsed slots of core.Claim\n *\n * @public\n * @interface   ParsedSlots\n */\nexport type ParsedSlots = CoreClaimParsedSlots;\n\n/**\n * @deprecated The interface should not be used. Use CoreClaimSlotsPaths from verifiable package instead.\n */\nexport type SlotsPaths = CoreClaimSlotsPaths;\n\n/**\n * Serialization of data slots for the fields non-merklized claims\n *\n * @public\n * @interface   SerializationSchema\n */\nexport interface SerializationSchema {\n  indexDataSlotA: string;\n  indexDataSlotB: string;\n  valueDataSlotA: string;\n  valueDataSlotB: string;\n}\n\n/**\n * schema metadata in the json credential schema\n *\n * @public\n * @interface   SchemaMetadata\n */\nexport interface SchemaMetadata {\n  uris: { [key: string]: string };\n  serialization?: SerializationSchema;\n}\n\n/**\n * JSON credential Schema\n *\n * @public\n * @interface   Schema\n */\nexport interface JSONSchema {\n  $metadata: SchemaMetadata;\n  $schema: string;\n  type: string;\n}\n\n/**\n * Parser can parse claim and schema data according to specification\n *\n * @public\n * @class Parser\n */\nexport class Parser {\n  /**\n   *  @deprecated The method should not be used. Use credential.toCoreClaim instead.\n   *  ParseClaim creates core.Claim object from W3CCredential\n   *\n   * @param {W3CCredential} credential - Verifiable Credential\n   * @param {CoreClaimOptions} [opts] - options to parse core claim\n   * @returns `Promise<CoreClaim>`\n   */\n  static async parseClaim(credential: W3CCredential, opts?: CoreClaimOptions): Promise<CoreClaim> {\n    return credential.toCoreClaim(opts);\n  }\n\n  /**\n   * @deprecated The method should not be used. Use findCredentialType from verifiable.\n   */\n  static findCredentialType(mz: Merklizer): string {\n    return findCredentialType(mz);\n  }\n\n  /**\n   *  @deprecated The method should not be used. Use credential.getSerializationAttr instead.\n   *\n   *  Get `iden3_serialization` attr definition from context document either using\n   *  type name like DeliverAddressMultiTestForked or by type id like\n   *  urn:uuid:ac2ede19-b3b9-454d-b1a9-a7b3d5763100.\n   *  */\n  static async getSerializationAttr(\n    credential: W3CCredential,\n    opts: Options,\n    tp: string\n  ): Promise<string> {\n    const ldCtx = await jsonld.processContext(\n      await jsonld.processContext(null, null, {}),\n      credential['@context'] as jsonld.JsonLdDocument,\n      opts\n    );\n\n    return getSerializationAttrFromParsedContext(\n      ldCtx as unknown as { mappings: Map<string, Record<string, unknown>> },\n      tp\n    );\n  }\n\n  /**\n   * @deprecated The method should not be used. Use getSerializationAttrFromContext from verifiable.\n   *\n   *  Get `iden3_serialization` attr definition from context document either using\n   *  type name like DeliverAddressMultiTestForked or by type id like\n   *  urn:uuid:ac2ede19-b3b9-454d-b1a9-a7b3d5763100.\n   *\n   */\n  static async getSerializationAttrFromContext(\n    context: object,\n    opts: Options,\n    tp: string\n  ): Promise<string> {\n    return getSerializationAttrFromContext(context, opts, tp);\n  }\n\n  /**\n   * @deprecated The method should not be used. Use getSerializationAttrFromParsedContext from verifiable.\n   *\n   * */\n  static async getSerializationAttrFromParsedContext(\n    ldCtx: { mappings: Map<string, Record<string, unknown>> },\n    tp: string\n  ): Promise<string> {\n    return getSerializationAttrFromParsedContext(ldCtx, tp);\n  }\n\n  /**\n   * @deprecated The method should not be used. Use parseSerializationAttr from verifiable.\n   *\n   */\n  static parseSerializationAttr(serAttr: string): SlotsPaths {\n    return parseSerializationAttr(serAttr);\n  }\n\n  /**\n   *\n   * @deprecated The method should not be used. Use credential.parseSlots instead.\n   * ParseSlots converts payload to claim slots using provided schema\n   *\n   * @param {Merklizer} mz - Merklizer\n   * @param {W3CCredential} credential - Verifiable Credential\n   * @param {string} credentialType - credential type\n   * @returns `ParsedSlots`\n   */\n  static async parseSlots(\n    mz: Merklizer,\n    credential: W3CCredential,\n    credentialType: string\n  ): Promise<{ slots: ParsedSlots; nonMerklized: boolean }> {\n    const ldCtx = await jsonld.processContext(\n      await jsonld.processContext(null, null, {}),\n      credential['@context'] as jsonld.JsonLdDocument,\n      mz.options\n    );\n\n    return parseCoreClaimSlots(\n      ldCtx as unknown as { mappings: Map<string, Record<string, unknown>> },\n      mz,\n      credentialType\n    );\n  }\n\n  /**\n   * @deprecated The method should not be used. Use getFieldSlotIndex from verifiable.\n   *\n   * GetFieldSlotIndex return index of slot from 0 to 7 (each claim has by default 8 slots) for non-merklized claims\n   *\n   * @param {string} field - field name\n   * @param {Uint8Array} schemaBytes -json schema bytes\n   * @returns `number`\n   */\n  static async getFieldSlotIndex(\n    field: string,\n    typeName: string,\n    schemaBytes: Uint8Array\n  ): Promise<number> {\n    return getFieldSlotIndex(field, typeName, schemaBytes);\n  }\n\n  /**\n   * ExtractCredentialSubjectProperties return credential subject types from JSON schema\n   *\n   * @param {string | JSON} schema - JSON schema\n   * @returns `Promise<Array<string>>`\n   */\n  static async extractCredentialSubjectProperties(schema: string): Promise<Array<string>> {\n    const parsedSchema = typeof schema === 'string' ? JSON.parse(schema) : schema;\n    const props = parsedSchema.properties?.credentialSubject?.properties;\n    if (!props) {\n      throw new Error('properties.credentialSubject.properties is not set');\n    }\n    // drop @id field\n    delete props['id'];\n    return Object.keys(props);\n  }\n\n  // /**\n  //  * GetLdPrefixesByJSONSchema return possible credential types for JSON schema\n  //  *\n  //  * @param {string} schema  - JSON schema\n  //  * @returns `Promise<Map<string, string>>`\n  //  */\n  // public static async getLdPrefixesByJSONSchema(schema: string): Promise<Map<string, string>> {\n  //   const metadata = Parser.extractMetadata(schema);\n  //   const ldURL = metadata.uris['jsonLdContext'];\n  //   if (!ldURL) {\n  //     throw new Error('jsonLdContext is not set');\n  //   }\n\n  //   const props = await Parser.extractCredentialSubjectProperties(schema);\n\n  //   let jsonLdContext;\n  //   try {\n  //     const response = await fetch(ldURL);\n  //     jsonLdContext = await response.json();\n  //   } catch (e) {\n  //     throw new Error(`failed to fetch jsonLdContext ${e}`);\n  //   }\n\n  //   let prefixes;\n  //   try {\n  //     prefixes = await LDParser.getPrefixes(jsonLdContext, false, props);\n  //   } catch (e) {\n  //     throw new Error(`failed to extract terms from jsonLdContext ${e}`);\n  //   }\n\n  //   return prefixes;\n  // }\n}\n","// or ESM/TypeScript import\nimport Ajv from 'ajv';\nimport { byteDecoder } from '../../utils';\nimport Ajv2020 from 'ajv/dist/2020.js';\nimport Ajv2019 from 'ajv/dist/2019.js';\nimport addFormats from 'ajv-formats';\n\nconst defaultOpts = { verbose: true, strict: false };\nconst defaultJSONSchemaValidator = new Ajv(defaultOpts);\n\n/** JSON SCHEMA VALIDATOR REGISTRY */\nexport const JSON_SCHEMA_VALIDATORS_REGISTRY = {\n  'http://json-schema.org/draft-07/schema': defaultJSONSchemaValidator,\n  'https://json-schema.org/draft/2019-09/schema': new Ajv2019(defaultOpts),\n  'https://json-schema.org/draft/2020-12/schema': new Ajv2020(defaultOpts)\n};\n\n/**\n * JSON Schema Validator\n *\n * @public\n * @class JsonSchemaValidator\n */\nexport class JsonSchemaValidator {\n  /**\n   * Validate data according to the given schema\n   *\n   * @param {Uint8Array} dataBytes - payload to validate\n   * @param {Uint8Array} schemaBytes - schema to process\n   * @returns `Promise<boolean>`\n   */\n  async validate(dataBytes: Uint8Array, schemaBytes: Uint8Array): Promise<boolean> {\n    const schema = JSON.parse(byteDecoder.decode(schemaBytes));\n    const data = JSON.parse(byteDecoder.decode(dataBytes));\n    const draft = schema['$schema']?.replaceAll('#', '');\n    let validator: Ajv | Ajv2019 | Ajv2020;\n    if (!draft) {\n      validator = defaultJSONSchemaValidator;\n    }\n    const ajv =\n      JSON_SCHEMA_VALIDATORS_REGISTRY[draft as keyof typeof JSON_SCHEMA_VALIDATORS_REGISTRY];\n    validator = ajv ?? defaultJSONSchemaValidator;\n    if (validator.formats && !Object.keys(validator.formats).length) {\n      addFormats(validator);\n      addCustomFormats(validator);\n    }\n    const validate =\n      (schema.$id ? validator.getSchema(schema.$id) : undefined) || validator.compile(schema);\n    const valid = validate(data);\n    if (!valid) {\n      // TODO: extract correct error messages\n      throw new Error(validate.errors?.map((e) => e.message).join(', '));\n    }\n    return true;\n  }\n}\n\nfunction addCustomFormats(validator: Ajv | Ajv2019 | Ajv2020) {\n  validator.addFormat('positive-integer', {\n    type: 'string',\n    validate: (positiveIntegerStr: string) => /^[1-9]\\d*$/.test(positiveIntegerStr)\n  });\n  validator.addFormat('non-negative-integer', {\n    type: 'string',\n    validate: (nonNegativeIntegerStr: string) => /^(0|[1-9]\\d*)$/.test(nonNegativeIntegerStr)\n  });\n}\n","import jsonld from 'jsonld';\n\n/**\n * LDParser can parse JSONLD schema according to specification\n *\n * @public\n * @class LDParser\n */\nexport class LDParser {\n  /**\n   * ExtractTerms returns the terms definitions from the JSON-LD context\n   *\n   * @param {string} context - JSONLD context\n   * @returns Promise<Map<string, string>>\n   */\n  public static async extractTerms(context: string | JSON): Promise<Map<string, unknown>> {\n    let data;\n    let res;\n    try {\n      data = typeof context === 'string' ? JSON.parse(context) : context;\n      res = await jsonld.processContext(await jsonld.processContext(null, null, {}), data, {});\n    } catch (e) {\n      throw new Error(`Failed process LD context. Error ${e}`);\n    }\n\n    const terms = res.mappings;\n    return terms;\n  }\n\n  /**\n   * GetPrefixes returns a map of potential RDF prefixes based on the JSON-LD Term Definitions\n   * in this context. No guarantees of the prefixes are given, beyond that it will not contain \":\".\n   *\n   * onlyCommonPrefixes: If true, the result will not include \"not so useful\" prefixes, such as\n   * \"term1\": \"http://example.com/term1\", e.g. all IRIs will end with \"/\" or \"#\".\n   * If false, all potential prefixes are returned.\n   * @param {string | JSON} context - JSONLD context\n   * @param {boolean} onlyCommonPrefixes - only common prefixes\n   * @param {Array<string>} properties - available properties in type definition\n   * @returns Promise<<Map<string, string>>\n   */\n  public static async getPrefixes(\n    context: string | JSON,\n    onlyCommonPrefixes: boolean,\n    properties?: Array<string>\n  ): Promise<Map<string, string>> {\n    const prefixes: Map<string, string> = new Map();\n    const data = await this.extractTerms(context);\n\n    for (const [term, termDefinition] of data) {\n      if (term.includes(':')) {\n        continue;\n      }\n      if (!termDefinition) {\n        continue;\n      }\n      const termDefinitionMap = termDefinition as Record<string, unknown>;\n      const id = termDefinitionMap['@id'] as string;\n      if (!id) {\n        continue;\n      }\n      if (term.startsWith('@') || id.startsWith('@')) {\n        continue;\n      }\n      if (!onlyCommonPrefixes || id.endsWith('/') || id.endsWith('#')) {\n        prefixes.set(term, id);\n      }\n\n      if (properties) {\n        const c = termDefinitionMap['@context'] as Record<string, undefined>;\n        if (!c) {\n          prefixes.delete(term);\n          continue;\n        }\n        if (!this.isKeysInMap(properties, c)) {\n          prefixes.delete(term);\n          continue;\n        }\n      }\n    }\n\n    return prefixes;\n  }\n\n  private static isKeysInMap(keys: string[], rec: Record<string, undefined>): boolean {\n    for (const key of keys) {\n      if (!rec[key]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n","import { DocumentLoader, Options, getDocumentLoader } from '@iden3/js-jsonld-merklization';\nimport { RemoteDocument, Url } from 'jsonld/jsonld-spec';\nimport { VerifiableConstants } from '../../verifiable';\n\n/**\n * cacheLoader returns a remote document with additional logic for caching the urls remote documents.\n * If the same url is called more then once, remote document will be not downloaded again but will returned from memory cache.\n * @param {Options } context - JSONLD loader options\n * @returns Promise<DocumentLoader>\n */\n\nconst doc = JSON.parse(VerifiableConstants.JSONLD_SCHEMA.W3C_VC_DOCUMENT_2018);\nconst docIden3Proofs = JSON.parse(\n  VerifiableConstants.JSONLD_SCHEMA.IDEN3_PROOFS_DEFINITION_DOCUMENT\n);\nconst docIden3DisplayMethod = JSON.parse(\n  VerifiableConstants.JSONLD_SCHEMA.IDEN3_DISPLAY_METHOD_DEFINITION_DOCUMENT\n);\nconst docIden3AuthBJJ = JSON.parse(VerifiableConstants.AUTH.AUTH_BJJ_CREDENTIAL_SCHEMA_JSONLD);\n\nexport const cacheLoader = (opts?: Options): DocumentLoader => {\n  const cache = new Map<string, RemoteDocument>();\n  cache.set(VerifiableConstants.JSONLD_SCHEMA.W3C_CREDENTIAL_2018, {\n    document: doc,\n    documentUrl: VerifiableConstants.JSONLD_SCHEMA.W3C_CREDENTIAL_2018\n  });\n  cache.set(VerifiableConstants.JSONLD_SCHEMA.IDEN3_CREDENTIAL, {\n    document: docIden3Proofs,\n    documentUrl: VerifiableConstants.JSONLD_SCHEMA.IDEN3_PROOFS_DEFINITION_DOCUMENT\n  });\n  cache.set(VerifiableConstants.JSONLD_SCHEMA.IDEN3_DISPLAY_METHOD, {\n    document: docIden3DisplayMethod,\n    documentUrl: VerifiableConstants.JSONLD_SCHEMA.IDEN3_DISPLAY_METHOD_DEFINITION_DOCUMENT\n  });\n  cache.set(VerifiableConstants.AUTH.AUTH_BJJ_CREDENTIAL_SCHEMA_JSONLD_URL, {\n    document: docIden3AuthBJJ,\n    documentUrl: VerifiableConstants.AUTH.AUTH_BJJ_CREDENTIAL_SCHEMA_JSONLD\n  });\n\n  return async (url: Url): Promise<RemoteDocument> => {\n    let remoteDoc = cache.get(url);\n    if (remoteDoc) {\n      return remoteDoc;\n    }\n    remoteDoc = await getDocumentLoader(opts)(url);\n    cache.set(url, remoteDoc);\n    return remoteDoc;\n  };\n};\n","import { RootInfo, StateProof } from './../entities/state';\nimport { ZKProof } from '@iden3/js-jwz';\nimport { IStateStorage, UserStateTransitionInfo } from '../interfaces/state';\nimport { Contract, JsonRpcProvider, Signer, TransactionRequest } from 'ethers';\nimport { StateInfo } from '../entities/state';\nimport { StateTransitionPubSignals } from '../../circuits';\nimport { byteEncoder } from '../../utils';\nimport abi from './abi/State.json';\nimport { DID, getChainId, Id } from '@iden3/js-iden3-core';\nimport { ITransactionService, TransactionService } from '../../blockchain';\nimport { prepareZkpProof } from './common';\nimport { ICache, createInMemoryCache } from '../memory';\nimport { PROTOCOL_CONSTANTS } from '../../iden3comm';\nimport { DEFAULT_CACHE_MAX_SIZE } from '../../verifiable';\n\n/**\n * Configuration options for caching behavior\n */\nexport type ResolverCacheOptions = {\n  /** TTL in milliseconds for latest states/roots (shorter since they can change) */\n  notReplacedTtl?: number;\n  /** TTL in milliseconds for historical states/roots (longer since they can change with less probability) */\n  replacedTtl?: number;\n  /** Maximum number of entries to store in cache */\n  maxSize?: number;\n};\n\n/**\n * Simplified cache config with a single TTL (used for latest/gist proofs etc.)\n */\nexport type SimpleCacheOptions = {\n  /** TTL in milliseconds for latest states/gist proof */\n  ttl?: number;\n  /** Maximum number of entries to store in cache */\n  maxSize?: number;\n};\n\n/**\n * EthStateStorageOptions options for the Ethereum state storage.\n */\nexport type EthStateStorageOptions = {\n  /** Disable caching */\n  disableCache?: boolean;\n  /** Configuration for latest state resolution caching */\n  latestStateCacheOptions?: {\n    /** Custom cache implementation (if not provided, uses in-memory cache) */\n    cache?: ICache<StateInfo>;\n  } & SimpleCacheOptions;\n  /** Configuration for state resolution caching */\n  stateCacheOptions?: {\n    /** Custom cache implementation (if not provided, uses in-memory cache) */\n    cache?: ICache<StateInfo>;\n  } & ResolverCacheOptions;\n  /** Configuration for GIST root resolution caching */\n  rootCacheOptions?: {\n    /** Custom cache implementation (if not provided, uses in-memory cache) */\n    cache?: ICache<RootInfo>;\n  } & ResolverCacheOptions;\n  gistProofCacheOptions?: {\n    /** Custom cache implementation for GIST proofs (if not provided, uses in-memory cache) */\n    cache?: ICache<StateProof>;\n  } & SimpleCacheOptions;\n};\n\n/**\n * Configuration of ethereum based blockchain connection\n *\n * @public\n * @interface   EthConnectionConfig\n */\nexport interface EthConnectionConfig {\n  url: string;\n  defaultGasLimit: number;\n  minGasPrice?: string;\n  maxGasPrice?: string; // eip-1559 transaction do not support gasPrice\n  maxFeePerGas?: string;\n  maxPriorityFeePerGas?: string;\n  confirmationBlockCount: number;\n  confirmationTimeout: number;\n  contractAddress: string;\n  receiptTimeout: number;\n  rpcResponseTimeout: number;\n  waitReceiptCycleTime: number;\n  waitBlockCycleTime: number;\n  chainId?: number;\n}\n\nexport /** @type {EthConnectionConfig} - default configuration for EthConnectionConfig */\nconst defaultEthConnectionConfig: EthConnectionConfig = {\n  url: 'http://localhost:8545',\n  defaultGasLimit: 600000,\n  minGasPrice: '0',\n  maxGasPrice: '100000000000',\n  confirmationBlockCount: 5,\n  confirmationTimeout: 600000,\n  contractAddress: '',\n  receiptTimeout: 600000,\n  rpcResponseTimeout: 5000,\n  waitReceiptCycleTime: 30000,\n  waitBlockCycleTime: 3000\n};\n\n/**\n *\n *\n * @public\n * @class EthStateStorage\n * @implements implements IStateStorage interface\n */\nexport class EthStateStorage implements IStateStorage {\n  public readonly stateContract: Contract;\n  private readonly provider: JsonRpcProvider;\n  private readonly _transactionService: ITransactionService;\n\n  private _latestStateResolveCache: ICache<StateInfo>;\n  private _stateResolveCache: ICache<StateInfo>;\n  private _rootResolveCache: ICache<RootInfo>;\n  private _gistProofResolveCache: ICache<StateProof>;\n\n  private _latestStateCacheOptions: Required<SimpleCacheOptions>;\n  private _stateCacheOptions: Required<ResolverCacheOptions>;\n  private _rootCacheOptions: Required<ResolverCacheOptions>;\n  private _gistProofCacheOptions: Required<SimpleCacheOptions>;\n\n  private _disableCache = false;\n\n  /**\n   * Creates an instance of EthStateStorage.\n   * @param {EthConnectionConfig} [ethConfig=defaultEthConnectionConfig]\n   */\n  constructor(\n    private readonly ethConfig: EthConnectionConfig | EthConnectionConfig[],\n    options?: EthStateStorageOptions\n  ) {\n    const config = Array.isArray(ethConfig) ? ethConfig[0] : ethConfig;\n    this.provider = new JsonRpcProvider(config.url);\n    this.stateContract = new Contract(config.contractAddress, abi, this.provider);\n    this._transactionService = new TransactionService(this.getRpcProvider());\n\n    // Store cache options for later use\n    this._latestStateCacheOptions = {\n      ttl:\n        options?.latestStateCacheOptions?.ttl ?? PROTOCOL_CONSTANTS.DEFAULT_PROOF_VERIFY_DELAY / 2,\n      maxSize: options?.latestStateCacheOptions?.maxSize ?? DEFAULT_CACHE_MAX_SIZE\n    };\n    this._stateCacheOptions = {\n      notReplacedTtl:\n        options?.stateCacheOptions?.notReplacedTtl ??\n        PROTOCOL_CONSTANTS.DEFAULT_PROOF_VERIFY_DELAY / 2,\n      replacedTtl:\n        options?.stateCacheOptions?.replacedTtl ?? PROTOCOL_CONSTANTS.DEFAULT_PROOF_VERIFY_DELAY,\n      maxSize: options?.stateCacheOptions?.maxSize ?? DEFAULT_CACHE_MAX_SIZE\n    };\n    this._rootCacheOptions = {\n      replacedTtl:\n        options?.rootCacheOptions?.replacedTtl ?? PROTOCOL_CONSTANTS.DEFAULT_AUTH_VERIFY_DELAY,\n      notReplacedTtl:\n        options?.rootCacheOptions?.notReplacedTtl ??\n        PROTOCOL_CONSTANTS.DEFAULT_AUTH_VERIFY_DELAY / 2,\n      maxSize: options?.rootCacheOptions?.maxSize ?? DEFAULT_CACHE_MAX_SIZE\n    };\n    this._gistProofCacheOptions = {\n      ttl: PROTOCOL_CONSTANTS.DEFAULT_AUTH_VERIFY_DELAY / 2,\n      maxSize: options?.gistProofCacheOptions?.maxSize ?? DEFAULT_CACHE_MAX_SIZE\n    };\n\n    // Initialize cache instances\n    this._latestStateResolveCache =\n      options?.latestStateCacheOptions?.cache ??\n      createInMemoryCache({\n        maxSize: this._latestStateCacheOptions.maxSize,\n        ttl: this._latestStateCacheOptions.ttl\n      });\n    this._stateResolveCache =\n      options?.stateCacheOptions?.cache ??\n      createInMemoryCache({\n        maxSize: this._stateCacheOptions.maxSize,\n        ttl: this._stateCacheOptions.replacedTtl\n      });\n\n    this._rootResolveCache =\n      options?.rootCacheOptions?.cache ??\n      createInMemoryCache({\n        maxSize: this._rootCacheOptions.maxSize,\n        ttl: this._rootCacheOptions.replacedTtl\n      });\n\n    this._gistProofResolveCache =\n      options?.gistProofCacheOptions?.cache ??\n      createInMemoryCache({\n        maxSize: this._gistProofCacheOptions.maxSize,\n        ttl: this._gistProofCacheOptions.ttl\n      });\n\n    this._disableCache = options?.disableCache ?? false;\n  }\n\n  /** {@inheritdoc IStateStorage.getLatestStateById} */\n  async getLatestStateById(id: bigint): Promise<StateInfo> {\n    const cacheKey = this.getLatestStateCacheKey(id);\n    if (!this._disableCache) {\n      // Check cache first\n      const cachedResult = await this._latestStateResolveCache?.get(cacheKey);\n      if (cachedResult) {\n        return cachedResult;\n      }\n    }\n\n    const { stateContract } = this.getStateContractAndProviderForId(id);\n    const rawData = await stateContract.getStateInfoById(id);\n    const stateInfo: StateInfo = {\n      id: BigInt(rawData[0]),\n      state: BigInt(rawData[1]),\n      replacedByState: BigInt(rawData[2]),\n      createdAtTimestamp: BigInt(rawData[3]),\n      replacedAtTimestamp: BigInt(rawData[4]),\n      createdAtBlock: BigInt(rawData[5]),\n      replacedAtBlock: BigInt(rawData[6])\n    };\n\n    !this._disableCache &&\n      (await this._latestStateResolveCache?.set(\n        cacheKey,\n        stateInfo,\n        this._latestStateCacheOptions.ttl\n      ));\n    return stateInfo;\n  }\n\n  /** {@inheritdoc IStateStorage.getStateInfoByIdAndState} */\n  async getStateInfoByIdAndState(id: bigint, state: bigint): Promise<StateInfo> {\n    const cacheKey = this.getStateCacheKey(id, state);\n    if (!this._disableCache) {\n      // Check cache first\n      const cachedResult = await this._stateResolveCache?.get(cacheKey);\n      if (cachedResult) {\n        return cachedResult;\n      }\n    }\n\n    const { stateContract } = this.getStateContractAndProviderForId(id);\n    const rawData = await stateContract.getStateInfoByIdAndState(id, state);\n    const stateInfo: StateInfo = {\n      id: BigInt(rawData[0]),\n      state: BigInt(rawData[1]),\n      replacedByState: BigInt(rawData[2]),\n      createdAtTimestamp: BigInt(rawData[3]),\n      replacedAtTimestamp: BigInt(rawData[4]),\n      createdAtBlock: BigInt(rawData[5]),\n      replacedAtBlock: BigInt(rawData[6])\n    };\n\n    const ttl =\n      stateInfo.replacedAtTimestamp === 0n\n        ? this._stateCacheOptions.notReplacedTtl\n        : this._stateCacheOptions.replacedTtl;\n    !this._disableCache && (await this._stateResolveCache?.set(cacheKey, stateInfo, ttl));\n    return stateInfo;\n  }\n\n  /** {@inheritdoc IStateStorage.publishState} */\n  async publishState(proof: ZKProof, signer: Signer): Promise<string> {\n    const stateTransitionPubSig = new StateTransitionPubSignals();\n    stateTransitionPubSig.pubSignalsUnmarshal(\n      byteEncoder.encode(JSON.stringify(proof.pub_signals))\n    );\n    const { userId, oldUserState, newUserState, isOldStateGenesis } = stateTransitionPubSig;\n\n    const { stateContract, provider } = this.getStateContractAndProviderForId(userId.bigInt());\n    const contract = stateContract.connect(signer) as Contract;\n\n    const preparedZkpProof = prepareZkpProof(proof.proof);\n    const payload = [\n      userId.bigInt().toString(),\n      oldUserState.bigInt().toString(),\n      newUserState.bigInt().toString(),\n      isOldStateGenesis,\n      preparedZkpProof.a,\n      preparedZkpProof.b,\n      preparedZkpProof.c\n    ];\n\n    const feeData = await provider.getFeeData();\n\n    const maxFeePerGas = defaultEthConnectionConfig.maxFeePerGas\n      ? BigInt(defaultEthConnectionConfig.maxFeePerGas)\n      : feeData.maxFeePerGas;\n    const maxPriorityFeePerGas = defaultEthConnectionConfig.maxPriorityFeePerGas\n      ? BigInt(defaultEthConnectionConfig.maxPriorityFeePerGas)\n      : feeData.maxPriorityFeePerGas;\n\n    const gasLimit = await contract.transitState.estimateGas(...payload);\n    const txData = await contract.transitState.populateTransaction(...payload);\n\n    const request: TransactionRequest = {\n      to: txData.to,\n      data: txData.data,\n      gasLimit,\n      maxFeePerGas,\n      maxPriorityFeePerGas\n    };\n\n    const { txnHash } = await this._transactionService.sendTransactionRequest(signer, request);\n\n    return txnHash;\n  }\n\n  /** {@inheritdoc IStateStorage.publishStateGeneric} */\n  async publishStateGeneric(\n    signer: Signer,\n    userStateTransitionInfo: UserStateTransitionInfo\n  ): Promise<string> {\n    const { userId, oldUserState, newUserState, isOldStateGenesis, methodId, methodParams } =\n      userStateTransitionInfo;\n    const { stateContract, provider } = this.getStateContractAndProviderForId(userId.bigInt());\n    const contract = stateContract.connect(signer) as Contract;\n    const feeData = await provider.getFeeData();\n\n    const maxFeePerGas = defaultEthConnectionConfig.maxFeePerGas\n      ? BigInt(defaultEthConnectionConfig.maxFeePerGas)\n      : feeData.maxFeePerGas;\n    const maxPriorityFeePerGas = defaultEthConnectionConfig.maxPriorityFeePerGas\n      ? BigInt(defaultEthConnectionConfig.maxPriorityFeePerGas)\n      : feeData.maxPriorityFeePerGas;\n\n    const payload = [\n      userId.bigInt().toString(),\n      oldUserState.bigInt().toString(),\n      newUserState.bigInt().toString(),\n      isOldStateGenesis,\n      methodId, //BigInt(1),\n      methodParams //'0x'\n    ];\n    const gasLimit = await contract.transitStateGeneric.estimateGas(...payload);\n    const txData = await contract.transitStateGeneric.populateTransaction(...payload);\n\n    const request: TransactionRequest = {\n      to: txData.to,\n      data: txData.data,\n      gasLimit,\n      maxFeePerGas,\n      maxPriorityFeePerGas\n    };\n\n    const { txnHash } = await this._transactionService.sendTransactionRequest(signer, request);\n\n    return txnHash;\n  }\n\n  /** {@inheritdoc IStateStorage.getGISTProof} */\n  async getGISTProof(id: bigint): Promise<StateProof> {\n    const cacheKey = this.getGistProofCacheKey(id);\n    if (!this._disableCache) {\n      // Check cache first\n      const cachedResult = await this._gistProofResolveCache?.get(cacheKey);\n      if (cachedResult) {\n        return cachedResult;\n      }\n    }\n\n    const { stateContract } = this.getStateContractAndProviderForId(id);\n    const data = await stateContract.getGISTProof(id);\n\n    const stateProof = {\n      root: BigInt(data.root.toString()),\n      existence: data.existence,\n      siblings: data.siblings?.map(\n        (sibling: { toString: () => string | number | bigint | boolean }) =>\n          BigInt(sibling.toString())\n      ),\n      index: BigInt(data.index.toString()),\n      value: BigInt(data.value.toString()),\n      auxExistence: data.auxExistence,\n      auxIndex: BigInt(data.auxIndex.toString()),\n      auxValue: BigInt(data.auxValue.toString())\n    };\n\n    !this._disableCache &&\n      (await this._gistProofResolveCache?.set(\n        cacheKey,\n        stateProof,\n        this._gistProofCacheOptions.ttl\n      ));\n    return stateProof;\n  }\n\n  /** {@inheritdoc IStateStorage.getGISTRootInfo} */\n  async getGISTRootInfo(root: bigint, id: bigint): Promise<RootInfo> {\n    const cacheKey = this.getRootCacheKey(root);\n    if (!this._disableCache) {\n      // Check cache first\n      const cachedResult = await this._rootResolveCache?.get(cacheKey);\n      if (cachedResult) {\n        return cachedResult;\n      }\n    }\n\n    const { stateContract } = this.getStateContractAndProviderForId(id);\n    const data = await stateContract.getGISTRootInfo(root);\n\n    const rootInfo = {\n      root: BigInt(data.root.toString()),\n      replacedByRoot: BigInt(data.replacedByRoot.toString()),\n      createdAtTimestamp: BigInt(data.createdAtTimestamp.toString()),\n      replacedAtTimestamp: BigInt(data.replacedAtTimestamp.toString()),\n      createdAtBlock: BigInt(data.createdAtBlock.toString()),\n      replacedAtBlock: BigInt(data.replacedAtBlock.toString())\n    };\n\n    const ttl =\n      rootInfo.replacedAtTimestamp == 0n\n        ? this._rootCacheOptions.notReplacedTtl\n        : this._rootCacheOptions.replacedTtl;\n    !this._disableCache && (await this._rootResolveCache?.set(cacheKey, rootInfo, ttl));\n    return rootInfo;\n  }\n\n  /** {@inheritdoc IStateStorage.getRpcProvider} */\n  getRpcProvider(): JsonRpcProvider {\n    return this.provider;\n  }\n\n  /** enable caching */\n  enableCache(): void {\n    this._disableCache = false;\n  }\n\n  /** disable caching */\n  disableCache(): void {\n    this._disableCache = true;\n  }\n\n  private getStateContractAndProviderForId(id: bigint): {\n    stateContract: Contract;\n    provider: JsonRpcProvider;\n  } {\n    const idTyped = Id.fromBigInt(id as bigint);\n    const chainId = getChainId(DID.blockchainFromId(idTyped), DID.networkIdFromId(idTyped));\n    const config = this.networkByChainId(chainId);\n\n    const provider = new JsonRpcProvider(config.url);\n    const stateContract = new Contract(config.contractAddress, abi, provider);\n\n    return { stateContract, provider };\n  }\n\n  private networkByChainId(chainId: number): EthConnectionConfig {\n    const config = Array.isArray(this.ethConfig) ? this.ethConfig : [this.ethConfig];\n    const network = config.find((c) => c.chainId === chainId);\n    if (!network) {\n      throw new Error(`chainId \"${chainId}\" not supported`);\n    }\n    return network;\n  }\n\n  private getGistProofCacheKey(id: bigint): string {\n    return `gist-${id.toString()}`;\n  }\n\n  private getLatestStateCacheKey(id: bigint): string {\n    return `latest-${id.toString()}`;\n  }\n\n  private getStateCacheKey(id: bigint, state: bigint): string {\n    return `${id.toString()}-${state.toString()}`;\n  }\n\n  private getRootCacheKey(root: bigint): string {\n    return root.toString();\n  }\n}\n","import { Hex } from '@iden3/js-crypto';\nimport { Hash, ZERO_HASH, Proof, swapEndianness } from '@iden3/js-merkletree';\nimport { TreeState } from './models';\nimport { Id } from '@iden3/js-iden3-core';\n\nexport const defaultMTLevels = 40; // max MT levels, default value for identity circuits\nexport const defaultValueArraySize = 64; // max value array size, default value for identity circuits\nexport const defaultMTLevelsOnChain = 64; // max MT levels on chain, default value for identity circuits\nexport const defaultMTLevelsClaim = 32; // max MT levels of JSON-LD merklization on claim\n\nexport const ErrorEmptyAuthClaimProof = 'empty auth claim mtp proof';\nexport const ErrorEmptyAuthClaimNonRevProof = 'empty auth claim non-revocation mtp proof';\nexport const ErrorEmptyChallengeSignature = 'empty challenge signature';\nexport const ErrorEmptyClaimSignature = 'empty claim signature';\nexport const ErrorEmptyClaimProof = 'empty claim mtp proof';\nexport const ErrorEmptyClaimNonRevProof = 'empty claim non-revocation mtp proof';\nexport const ErrorUserStateInRelayClaimProof =\n  'empty user state in relay claim non-revocation mtp proof';\nexport const ErrorEmptyIssuerAuthClaimProof = 'empty issuer auth claim mtp proof';\nexport const ErrorEmptyIssuerAuthClaimNonRevProof =\n  'empty issuer auth claim non-revocation mtp proof';\n\n/**\n * base config for circuit inputs\n *\n * @public\n * @class BaseConfig\n */\nexport class BaseConfig {\n  mtLevel!: number; // Max levels of MT\n  maxValueArraySize!: number; // Size if( value array in identity circuit)s\n  mtLevelOnChain!: number;\n  mtLevelClaim!: number; // Max level of JSONLD claim\n\n  /**\n   *  getMTLevel max circuit MT levels\n   *\n   * @returns number\n   */\n  getMTLevel(): number {\n    return this.mtLevel ? this.mtLevel : defaultMTLevels;\n  }\n  /**\n   *  GetMTLevelsClaim max jsonld Claim levels\n   *\n   * @returns number\n   */\n  getMTLevelsClaim(): number {\n    return this.mtLevelClaim ? this.mtLevelClaim : defaultMTLevelsClaim;\n  }\n\n  /**\n   * GetValueArrSize return size of circuits value array size\n   *\n   * @returns number\n   */\n  getValueArrSize(): number {\n    return this.maxValueArraySize ? this.maxValueArraySize : defaultValueArraySize;\n  }\n\n  /**\n   * getMTLevelOnChain return level on chain for given circuit\n   *\n   * @returns number\n   */\n  getMTLevelOnChain(): number {\n    return this.mtLevelOnChain ? this.mtLevelOnChain : defaultMTLevelsOnChain;\n  }\n}\n\n/**\n * @deprecated The method should not be used and will be removed in the next major version,\n * please use Hash.fromHex instead\n * @param {(string | undefined)} s - string hex\n * @returns Hash\n */\nexport const strMTHex = (s: string | undefined): Hash => {\n  if (!s) {\n    return ZERO_HASH;\n  }\n  const h = new Hash();\n  h.value = swapEndianness(Hex.decodeString(s));\n  return h;\n};\n\n/**\n * converts hexes of tree roots to Hashes\n *\n * @param {(string | undefined)} state - state of tree hex\n * @param {(string | undefined)} claimsTreeRoot - claims tree root hex\n * @param {(string | undefined)} revocationTreeRoot - revocation tree root hex\n * @param {(string | undefined)} rootOfRoots - root of roots tree root hex\n * @returns TreeState\n */\nexport const buildTreeState = (\n  state: string | undefined,\n  claimsTreeRoot: string | undefined,\n  revocationTreeRoot: string | undefined,\n  rootOfRoots: string | undefined\n): TreeState => ({\n  state: Hash.fromHex(state),\n  claimsRoot: Hash.fromHex(claimsTreeRoot),\n  revocationRoot: Hash.fromHex(revocationTreeRoot),\n  rootOfRoots: Hash.fromHex(rootOfRoots)\n});\n\n/**\n * siblings as string array\n *\n * @param {Proof} proof - proof with siblings\n * @param {number} levels - levels number\n * @returns string[]\n */\nexport const prepareSiblingsStr = (proof: Proof, levels: number): string[] => {\n  const siblings = proof.allSiblings();\n\n  // Add the rest of empty levels to the siblings\n  for (let i = siblings.length; i < levels; i++) {\n    siblings.push(ZERO_HASH);\n  }\n  return siblings.map((s: Hash) => s.bigInt().toString());\n};\n\n/**\n * PrepareCircuitArrayValues padding values to size.\n * Validate array size and throw an exception if array is bigger than size\n * if array is bigger, circuit cannot compile because number of inputs does not match\n *\n *\n * @param {bigint[]} arr - given values\n * @param {number} size - size to pad\n * @returns bigint[]\n */\nexport const prepareCircuitArrayValues = (arr: bigint[], size: number): bigint[] => {\n  if (!arr) {\n    arr = [];\n  }\n  if (arr.length > size) {\n    throw new Error(`array size ${arr.length} is bigger max expected size ${size}`);\n  }\n\n  // Add the empty values\n  for (let i = arr.length; i < size; i++) {\n    arr.push(BigInt(0));\n  }\n\n  return arr;\n};\n\n/**\n * converts each big integer in array to string\n *\n * @param {bigint[]} arr -  array of big numbers\n * @returns string[]\n */\nexport const bigIntArrayToStringArray = (arr: bigint[]): string[] => {\n  return arr.map((a) => a.toString());\n};\n\n/**\n * auxiliary node\n *\n * @public\n * @interface   NodeAuxValue\n */\nexport interface NodeAuxValue {\n  key: Hash;\n  value: Hash;\n  noAux: string;\n}\n\nexport /**\n * gets auxiliary node from proof\n *\n * @param {(Proof | undefined)} p - mtp\n * @returns NodeAuxValue\n */\nconst getNodeAuxValue = (p: Proof | undefined): NodeAuxValue => {\n  // proof of inclusion\n  if (p?.existence) {\n    return {\n      key: ZERO_HASH,\n      value: ZERO_HASH,\n      noAux: '0'\n    };\n  }\n\n  // proof of non-inclusion (NodeAux exists)\n  if (p?.nodeAux?.value !== undefined && p?.nodeAux?.key !== undefined) {\n    return {\n      key: p.nodeAux.key,\n      value: p.nodeAux.value,\n      noAux: '0'\n    };\n  }\n  // proof of non-inclusion (NodeAux does not exist)\n  return {\n    key: ZERO_HASH,\n    value: ZERO_HASH,\n    noAux: '1'\n  };\n};\n\n/**\n * converts boolean existence param to integer\n * if true - 1, else - 0\n *\n * @param {boolean} b - existence\n * @returns number\n */\nexport const existenceToInt = (b: boolean): number => (b ? 0 : 1);\n\n/**\n * return object properties\n *\n * @param {object} obj\n * @returns object\n */\nexport function getProperties(obj: object): object {\n  const result: { [key: string]: unknown } = {};\n\n  for (const property in obj) {\n    // eslint-disable-next-line no-prototype-builtins\n    if (obj.hasOwnProperty(property) && !property.startsWith('_')) {\n      result[property] = obj[property as keyof typeof obj];\n    }\n  }\n  return result;\n}\n\n/**\n * states info from pub signals\n *\n * @public\n * @type   StatesInfo\n */\nexport type StatesInfo = {\n  states: {\n    id: Id;\n    state: Hash;\n  }[];\n  gists: {\n    id: Id;\n    root: Hash;\n  }[];\n};\n\n/**\n * state pub signals\n *\n * @public\n * @interface   IStatePubSignals\n */\nexport interface IStateInfoPubSignals {\n  /**\n   * return object with state params\n   *\n   * @returns {OnChainStateInfo}\n   */\n  getStatesInfo(): StatesInfo;\n}\n","import { Signature } from '@iden3/js-crypto';\nimport { Claim, Claim as CoreClaim, Id } from '@iden3/js-iden3-core';\nimport { Hash, Proof } from '@iden3/js-merkletree';\nimport { Operators, QueryOperators } from './comparer';\n\n/**\n * TreeState is model for merkle tree roots\n *\n * @public\n * @interface   TreeState\n */\nexport interface TreeState {\n  state: Hash;\n  claimsRoot: Hash;\n  revocationRoot: Hash;\n  rootOfRoots: Hash;\n}\n\n/**\n * claim non revocation status for circuit\n * TreeState and Proof of inclusion / non-inclusion\n *\n * @public\n * @interface   ClaimNonRevStatus\n */\nexport interface ClaimNonRevStatus {\n  treeState: TreeState;\n  proof: Proof;\n}\n/**\n * Query represents basic request to claim slot verification\n *\n * @public\n * @class Query\n */\nexport class Query {\n  slotIndex!: number;\n  values!: bigint[];\n  operator!: number;\n  valueProof!: ValueProof;\n\n  /**\n   * Validates Query instance\n   *\n   */\n  validate(): void {\n    if (\n      this.operator !== QueryOperators.$noop &&\n      this.operator !== QueryOperators.$sd &&\n      this.values?.some((v) => typeof v !== 'bigint')\n    )\n      throw new Error(CircuitError.EmptyQueryValue);\n  }\n\n  validateValueArraySize(maxArrSize: number): void {\n    if (\n      [Operators.NOOP, Operators.SD, Operators.NULLIFY].includes(this.operator) &&\n      this.values.length !== 0\n    ) {\n      throw new Error(CircuitError.InvalidValuesArrSize);\n    } else if (\n      [\n        Operators.EQ,\n        Operators.LT,\n        Operators.GT,\n        Operators.NE,\n        Operators.LTE,\n        Operators.GTE,\n        Operators.EXISTS\n      ].includes(this.operator) &&\n      this.values.length !== 1\n    ) {\n      throw new Error(CircuitError.InvalidValuesArrSize);\n    } else if (\n      [Operators.BETWEEN, Operators.NONBETWEEN].includes(this.operator) &&\n      this.values.length !== 2\n    ) {\n      throw new Error(CircuitError.InvalidValuesArrSize);\n    } else if (\n      [Operators.IN, Operators.NIN].includes(this.operator) &&\n      this.values.length > maxArrSize\n    ) {\n      throw new Error(CircuitError.InvalidValuesArrSize);\n    }\n  }\n}\n\n/**\n * CircuitID is alias for circuit identifier\n *\n * @enum {number}\n */\nexport enum CircuitId {\n  // Auth is a type that must be used for authV2.circom\n  AuthV2 = 'authV2',\n  // StateTransition is a type that must be used for stateTransition.circom\n  StateTransition = 'stateTransition',\n  // AtomicQueryMTPV2 is a type for credentialAtomicQueryMTPV2.circom\n  AtomicQueryMTPV2 = 'credentialAtomicQueryMTPV2',\n  // AtomicQueryMTPV2OnChain is a type for credentialAtomicQueryMTPV2OnChain.circom\n  AtomicQueryMTPV2OnChain = 'credentialAtomicQueryMTPV2OnChain',\n  // AtomicQuerySig is a type for credentialAttrQuerySig.circom\n  AtomicQuerySigV2 = 'credentialAtomicQuerySigV2',\n  // AtomicQuerySigOnChain is a type for credentialAtomicQuerySigOnChain.circom\n  AtomicQuerySigV2OnChain = 'credentialAtomicQuerySigV2OnChain',\n  /**\n   * @beta\n   */\n  // AtomicQueryV3CircuitID is a type for credentialAtomicQueryV3.circom\n  AtomicQueryV3 = 'credentialAtomicQueryV3-beta.1',\n  /**\n   * @beta\n   */\n  // AtomicQueryV3OnChainCircuitID is a type for credentialAtomicQueryV3OnChain.circom\n  AtomicQueryV3OnChain = 'credentialAtomicQueryV3OnChain-beta.1',\n  /**\n   * @beta\n   */\n  // LinkedMultiQuery is a type for linkedMultiQuery.circom\n  LinkedMultiQuery10 = 'linkedMultiQuery10-beta.1'\n}\n\n/**\n * Claim structure for circuit inputs\n *\n * @public\n * @class CircuitClaim\n */\nexport class CircuitClaim {\n  issuerId!: Id;\n  claim!: CoreClaim;\n  treeState!: TreeState;\n  proof!: Proof;\n  nonRevProof!: ClaimNonRevStatus; // Claim non revocation proof\n  signatureProof!: BJJSignatureProof;\n}\n\n/**\n *\n * Claim for circuit with non revocation proof and signature proof\n * @public\n * @interface   ClaimWithSigProof\n */\nexport interface ClaimWithSigProof {\n  issuerID?: Id;\n  claim?: Claim;\n  nonRevProof?: MTProof;\n  signatureProof?: BJJSignatureProof;\n}\n\n/**\n * Claim for circuit with non revocation proof and proof of merkle tree inclusion\n *\n * @public\n * @interface   ClaimWithMTPProof\n */\nexport interface ClaimWithMTPProof {\n  issuerID?: Id;\n  claim?: Claim;\n  incProof?: MTProof;\n  nonRevProof?: MTProof;\n}\n\n/**\n * prepared bjj signature for circuits with auth bjj claim data\n *\n * @public\n * @interface   BJJSignatureProof\n */\nexport interface BJJSignatureProof {\n  signature: Signature;\n  issuerAuthClaim?: Claim;\n  issuerAuthIncProof: MTProof;\n  issuerAuthNonRevProof: MTProof;\n}\n\n/**\n * prepared mtp with a tree state\n *\n * @public\n * @interface   MTProof\n */\nexport interface MTProof {\n  proof?: Proof;\n  treeState?: TreeState;\n}\n/**\n * global identity state proof\n *\n * @public\n * @interface   GISTProof\n */\nexport interface GISTProof {\n  root: Hash;\n  proof: Proof;\n}\n\n/**\n * List of errors of circuit inputs processing\n *\n * @enum {number}\n */\nexport enum CircuitError {\n  EmptyAuthClaimProof = 'empty auth claim mtp proof',\n  EmptyAuthClaimProofInTheNewState = 'empty auth claim mtp proof in the new state',\n  EmptyAuthClaimNonRevProof = 'empty auth claim non-revocation mtp proof',\n  EmptyChallengeSignature = 'empty challenge signature',\n  EmptyClaimSignature = 'empty claim signature',\n  EmptyClaimProof = 'empty claim mtp proof',\n  EmptyClaimNonRevProof = 'empty claim non-revocation mtp proof',\n  EmptyIssuerAuthClaimProof = 'empty issuer auth claim mtp proof',\n  EmptyIssuerAuthClaimNonRevProof = 'empty issuer auth claim non-revocation mtp proof',\n  EmptyJsonLDQueryProof = 'empty JSON-LD query mtp proof',\n  EmptyJsonLDQueryValue = 'empty JSON-LD query value',\n  EmptyJsonLDQueryPath = 'empty JSON-LD query path',\n  EmptyQueryValue = 'empty query value',\n  EmptyJsonLDQueryValues = 'empty JSON-LD query values',\n  EmptyId = 'empty Id',\n  EmptyChallenge = 'empty challenge',\n  EmptyGISTProof = 'empty GIST merkle tree proof',\n  EmptyTreeState = 'empty tree state',\n  EmptyRequestID = 'empty request ID',\n  InvalidProofType = 'invalid proof type',\n  InvalidValuesArrSize = 'invalid query Values array size',\n  InvalidOperationType = 'invalid operation type'\n}\n\n/**\n * ValueProof represents a Merkle Proof for a value stored as MT\n *\n * @public\n * @class ValueProof\n */\nexport class ValueProof {\n  path: bigint;\n  value: bigint;\n  mtp: Proof;\n\n  /**\n   * Creates an instance of ValueProof.\n   */\n  constructor() {\n    this.path = BigInt(0);\n    this.value = BigInt(0);\n    this.mtp = new Proof();\n  }\n\n  /**\n   * validates instance of ValueProof\n   *\n   */\n  validate(): void {\n    if (typeof this.path !== 'bigint') {\n      throw new Error(CircuitError.EmptyJsonLDQueryPath);\n    }\n    if (typeof this.value !== 'bigint') {\n      throw new Error(CircuitError.EmptyJsonLDQueryValue);\n    }\n    if (!this.mtp) {\n      throw new Error(CircuitError.EmptyJsonLDQueryProof);\n    }\n  }\n}\n","/**\n * Represents the XSD namespace and its corresponding data types.\n */\n\nexport enum XSDNS {\n  Boolean = 'http://www.w3.org/2001/XMLSchema#boolean',\n  Integer = 'http://www.w3.org/2001/XMLSchema#integer',\n  NonNegativeInteger = 'http://www.w3.org/2001/XMLSchema#nonNegativeInteger',\n  NonPositiveInteger = 'http://www.w3.org/2001/XMLSchema#nonPositiveInteger',\n  NegativeInteger = 'http://www.w3.org/2001/XMLSchema#negativeInteger',\n  PositiveInteger = 'http://www.w3.org/2001/XMLSchema#positiveInteger',\n  DateTime = 'http://www.w3.org/2001/XMLSchema#dateTime',\n  Double = 'http://www.w3.org/2001/XMLSchema#double',\n  String = 'http://www.w3.org/2001/XMLSchema#string'\n}\n\n/**\n * List of available operators.\n *\n * @enum {number}\n */\nexport enum Operators {\n  NOOP = 0, // No operation, skip query verification in circuit\n  EQ = 1,\n  LT = 2,\n  GT = 3,\n  IN = 4,\n  NIN = 5,\n  NE = 6,\n  LTE = 7,\n  GTE = 8,\n  BETWEEN = 9,\n  NONBETWEEN = 10,\n  EXISTS = 11,\n  SD = 16,\n  NULLIFY = 17\n}\n\n/** QueryOperators represents operators for atomic circuits */\nexport const QueryOperators = {\n  $noop: Operators.NOOP,\n  $eq: Operators.EQ,\n  $lt: Operators.LT,\n  $gt: Operators.GT,\n  $in: Operators.IN,\n  $nin: Operators.NIN,\n  $ne: Operators.NE,\n  $lte: Operators.LTE,\n  $gte: Operators.GTE,\n  $between: Operators.BETWEEN,\n  $nonbetween: Operators.NONBETWEEN,\n  $exists: Operators.EXISTS,\n  $sd: Operators.SD,\n  $nullify: Operators.NULLIFY\n};\n\nexport const getOperatorNameByValue = (operator: number): string => {\n  const ops = Object.entries(QueryOperators).find(([, queryOp]) => queryOp === operator);\n  return ops ? ops[0] : 'unknown';\n};\n\nconst allOperations = Object.values(QueryOperators);\n\nexport const availableTypesOperators: Map<string, Operators[]> = new Map([\n  [\n    XSDNS.Boolean,\n    [QueryOperators.$eq, QueryOperators.$ne, QueryOperators.$sd, QueryOperators.$exists]\n  ],\n  [XSDNS.Integer, allOperations],\n  [XSDNS.NonNegativeInteger, allOperations],\n  [XSDNS.PositiveInteger, allOperations],\n  [\n    XSDNS.Double,\n    [\n      QueryOperators.$eq,\n      QueryOperators.$ne,\n      QueryOperators.$in,\n      QueryOperators.$nin,\n      QueryOperators.$sd,\n      QueryOperators.$exists\n    ]\n  ],\n  [\n    XSDNS.String,\n    [\n      QueryOperators.$eq,\n      QueryOperators.$ne,\n      QueryOperators.$in,\n      QueryOperators.$nin,\n      QueryOperators.$sd,\n      QueryOperators.$exists\n    ]\n  ],\n  [XSDNS.DateTime, allOperations]\n]);\n\n/**\n * Checks if the given operation is valid for the specified datatype.\n * @param datatype - The datatype to check the operation for.\n * @param op - The operation to check.\n * @returns True if the operation is valid, false otherwise.\n */\nexport const isValidOperation = (datatype: string, op: number): boolean => {\n  if (op === Operators.NOOP) {\n    return true;\n  }\n\n  if (!availableTypesOperators.has(datatype)) {\n    return false;\n  }\n  const ops = availableTypesOperators.get(datatype);\n  if (!ops) {\n    return false;\n  }\n  return ops.includes(op);\n};\n\n// Comparer value.\nexport interface IComparer {\n  compare(int: number): boolean;\n}\n\n/**\n * Scalar is used to compare two scalar value.\n *\n * @public\n * @class Scalar\n * @implements implements IComparer interface\n */\nexport class Scalar implements IComparer {\n  /**\n   * Creates an instance of Scalar.\n   * @param {bigint} x - val x\n   * @param {bigint} y - val y\n   */\n  constructor(private x: bigint, private y: bigint) {}\n  /**\n   * compares two  scalar values\n   *\n   * @param {Operators} operator - EQ / LT / GT\n   * @returns boolean\n   */\n  compare(operator: Operators): boolean {\n    switch (operator) {\n      case Operators.EQ:\n        return this.x === this.y;\n      case Operators.LT:\n        return this.x < this.y;\n      case Operators.GT:\n        return this.x > this.y;\n      case Operators.NE:\n        return this.x !== this.y;\n      default:\n        throw new Error('unknown compare type for scalar');\n    }\n  }\n}\n\n/**\n * Vector uses for find/not find x scalar type in y vector type.\n *\n * @public\n * @class Vector\n * @implements implements IComparer interface\n */\nexport class Vector implements IComparer {\n  /**\n   * Creates an instance of Vector.\n   * @param {bigint} x - val x\n   * @param {bigint[]} y - array values y\n   */\n  constructor(private x: bigint, private y: bigint[]) {}\n  /**\n   *\n   *\n   * @param {Operators} operator - IN / NIN\n   * @returns boolean\n   */\n  compare(operator: Operators): boolean {\n    switch (operator) {\n      case Operators.IN:\n        return this.y.includes(this.x);\n      case Operators.NIN:\n        return !this.y.includes(this.x);\n      case Operators.BETWEEN:\n        if (this.y.length !== 2) {\n          return false;\n        }\n        return this.x >= this.y[0] && this.x <= this.y[1];\n      case Operators.NONBETWEEN:\n        if (this.y.length !== 2) {\n          return false;\n        }\n        return this.x < this.y[0] || this.x > this.y[1];\n      default:\n        throw new Error('unknown compare type for vector');\n    }\n  }\n}\n\n/**\n * FactoryComparer depends on input data will return right comparer.\n *\n * @param {bigint} x - val x\n * @param {bigint[]} y - array of values y\n * @param {Operators} operator - EQ / LT / GT / IN / NIN\n * @returns IComparer\n */\nexport const factoryComparer = (x: bigint, y: bigint[], operator: Operators): IComparer => {\n  switch (operator) {\n    case Operators.EQ:\n    case Operators.LT:\n    case Operators.GT:\n    case Operators.NE:\n      if (y.length !== 1) {\n        throw new Error('currently we support only one value for scalar comparison');\n      }\n      return new Scalar(x, y[0]);\n    case Operators.IN:\n    case Operators.NIN:\n    case Operators.BETWEEN:\n    case Operators.NONBETWEEN:\n      return new Vector(x, y);\n    default:\n      throw new Error('unknown compare type');\n  }\n};\n","import { Id, SchemaHash } from '@iden3/js-iden3-core';\nimport { Query, ClaimWithMTPProof, ValueProof, CircuitError } from './models';\nimport { Hash } from '@iden3/js-merkletree';\nimport {\n  BaseConfig,\n  bigIntArrayToStringArray,\n  existenceToInt,\n  getNodeAuxValue,\n  prepareCircuitArrayValues,\n  prepareSiblingsStr\n} from './common';\nimport { byteDecoder, byteEncoder } from '../utils';\n\n/**\n * AtomicQueryMTPInputs ZK private inputs for credentialAtomicQueryMTP.circom\n *\n * @public\n * @class AtomicQueryMTPV2Inputs\n * @extends {BaseConfig}\n */\nexport class AtomicQueryMTPV2Inputs extends BaseConfig {\n  // auth\n  id!: Id;\n  profileNonce!: bigint;\n  claimSubjectProfileNonce!: bigint;\n  // claim issued for user\n  claim!: ClaimWithMTPProof;\n  skipClaimRevocationCheck!: boolean;\n  requestID!: bigint;\n\n  currentTimeStamp!: number;\n\n  // query\n  query!: Query;\n\n  /**\n   * Validate AtomicQueryMTPV2 inputs\n   *\n   */\n  validate(): void {\n    if (!this.requestID) {\n      throw new Error(CircuitError.EmptyRequestID);\n    }\n  }\n\n  /**\n   *\n   * Inputs marshalling\n   * @returns {Uint8Array}\n   */\n  inputsMarshal(): Uint8Array {\n    this.validate();\n    if (this.query.valueProof) {\n      this.query.validate();\n      this.query.valueProof.validate();\n    }\n\n    const valueProof = this.query.valueProof ?? new ValueProof();\n\n    const s: Partial<AtomicQueryMTPV2CircuitInputs> = {\n      requestID: this.requestID.toString(),\n      userGenesisID: this.id.bigInt().toString(),\n      profileNonce: this.profileNonce?.toString(),\n      claimSubjectProfileNonce: this.claimSubjectProfileNonce?.toString(),\n      issuerID: this.claim.issuerID?.bigInt().toString(),\n      issuerClaim: this.claim.claim?.marshalJson(),\n      issuerClaimMtp:\n        this.claim.incProof?.proof &&\n        prepareSiblingsStr(this.claim.incProof.proof, this.getMTLevel()),\n      issuerClaimClaimsTreeRoot: this.claim.incProof?.treeState?.claimsRoot?.bigInt().toString(),\n      issuerClaimRevTreeRoot: this.claim.incProof?.treeState?.revocationRoot?.bigInt().toString(),\n      issuerClaimRootsTreeRoot: this.claim.incProof?.treeState?.rootOfRoots?.bigInt().toString(),\n      issuerClaimIdenState: this.claim.incProof?.treeState?.state?.bigInt().toString(),\n      issuerClaimNonRevMtp:\n        this.claim.nonRevProof?.proof &&\n        prepareSiblingsStr(this.claim.nonRevProof.proof, this.getMTLevel()),\n      issuerClaimNonRevClaimsTreeRoot: this.claim.nonRevProof?.treeState?.claimsRoot\n        ?.bigInt()\n        .toString(),\n      issuerClaimNonRevRevTreeRoot: this.claim.nonRevProof?.treeState?.revocationRoot\n        ?.bigInt()\n        .toString(),\n      issuerClaimNonRevRootsTreeRoot: this.claim.nonRevProof?.treeState?.rootOfRoots\n        ?.bigInt()\n        .toString(),\n      issuerClaimNonRevState: this.claim.nonRevProof?.treeState?.state?.bigInt().toString(),\n      claimSchema: this.claim.claim?.getSchemaHash().bigInt().toString(),\n      claimPathMtp: prepareSiblingsStr(valueProof.mtp, this.getMTLevelsClaim()),\n      claimPathValue: valueProof.value.toString(),\n      operator: this.query.operator,\n      slotIndex: this.query.slotIndex,\n      timestamp: this.currentTimeStamp\n    };\n\n    const nodeAux = getNodeAuxValue(this.claim.nonRevProof?.proof);\n    s.issuerClaimNonRevMtpAuxHi = nodeAux?.key.bigInt().toString();\n    s.issuerClaimNonRevMtpAuxHv = nodeAux?.value.bigInt().toString();\n    s.issuerClaimNonRevMtpNoAux = nodeAux?.noAux;\n\n    s.claimPathNotExists = existenceToInt(valueProof.mtp.existence);\n    const nodAuxJSONLD = getNodeAuxValue(valueProof.mtp);\n    s.claimPathMtpNoAux = nodAuxJSONLD.noAux;\n    s.claimPathMtpAuxHi = nodAuxJSONLD.key.bigInt().toString();\n    s.claimPathMtpAuxHv = nodAuxJSONLD.value.bigInt().toString();\n\n    s.claimPathKey = valueProof.path.toString();\n\n    if (this.skipClaimRevocationCheck) {\n      s.isRevocationChecked = 0;\n    } else {\n      s.isRevocationChecked = 1;\n    }\n\n    const values =\n      this.query.values && prepareCircuitArrayValues(this.query.values, this.getValueArrSize());\n\n    s.value = bigIntArrayToStringArray(values);\n\n    return byteEncoder.encode(JSON.stringify(s));\n  }\n}\n\n// stateTransitionInputsInternal type represents credentialAtomicQueryMTP.circom private inputs required by prover\ninterface AtomicQueryMTPV2CircuitInputs {\n  requestID: string;\n  userGenesisID: string;\n  profileNonce: string;\n  claimSubjectProfileNonce: string;\n  issuerID: string;\n  issuerClaim?: string[];\n  issuerClaimMtp: string[];\n  issuerClaimClaimsTreeRoot?: string;\n  issuerClaimRevTreeRoot?: string;\n  issuerClaimRootsTreeRoot?: string;\n  issuerClaimIdenState?: string;\n  issuerClaimNonRevClaimsTreeRoot?: string;\n  issuerClaimNonRevRevTreeRoot?: string;\n  issuerClaimNonRevRootsTreeRoot?: string;\n  issuerClaimNonRevState?: string;\n  issuerClaimNonRevMtp: string[];\n  issuerClaimNonRevMtpAuxHi?: string;\n  issuerClaimNonRevMtpAuxHv?: string;\n  issuerClaimNonRevMtpNoAux: string;\n  isRevocationChecked: number;\n  claimSchema: string;\n  claimPathNotExists: number;\n  claimPathMtp: string[];\n  claimPathMtpNoAux: string;\n  claimPathMtpAuxHi?: string;\n  claimPathMtpAuxHv?: string;\n  claimPathKey: string;\n  claimPathValue: string;\n  operator: number;\n  slotIndex: number;\n  timestamp: number;\n  value: string[];\n}\n\n/**\n * Public signals\n *\n * @public\n * @class AtomicQueryMTPV2PubSignals\n * @extends {BaseConfig}\n */\nexport class AtomicQueryMTPV2PubSignals extends BaseConfig {\n  requestID!: bigint;\n  userID!: Id;\n  issuerID!: Id;\n  issuerClaimIdenState!: Hash;\n  issuerClaimNonRevState!: Hash;\n  claimSchema!: SchemaHash;\n  slotIndex!: number;\n  operator!: number;\n  value: bigint[] = [];\n  timestamp!: number;\n  merklized!: number;\n  claimPathKey!: bigint;\n  // 0 for inclusion, 1 for non-inclusion\n  claimPathNotExists!: number;\n  // 0 revocation not check, // 1 for check revocation\n  isRevocationChecked!: number;\n\n  /**\n   * PubSignalsUnmarshal unmarshal credentialAtomicQueryMTP.circom public signals array to AtomicQueryMTPPubSignals\n   *\n   * @param {Uint8Array} data\n   * @returns AtomicQueryMTPV2PubSignals\n   */\n  pubSignalsUnmarshal(data: Uint8Array): AtomicQueryMTPV2PubSignals {\n    // expected order:\n    // merklized\n    // userID\n    // requestID\n    // issuerID\n    // issuerClaimIdenState\n    // issuerClaimNonRevState\n    // timestamp\n    // claimSchema\n    // claimPathNotExists\n    // claimPathKey\n    // slotIndex\n    // operator\n    // value\n\n    // 12 is a number of fields in AtomicQueryMTPV2PubSignals before values, values is last element in the proof and\n    // it is length could be different base on the circuit configuration. The length could be modified by set value\n    // in ValueArraySize\n    const fieldLength = 13;\n\n    const sVals: string[] = JSON.parse(byteDecoder.decode(data));\n\n    if (sVals.length !== fieldLength + this.getValueArrSize()) {\n      throw new Error(\n        `invalid number of Output values expected ${fieldLength + this.getValueArrSize()} got ${\n          sVals.length\n        }`\n      );\n    }\n\n    let fieldIdx = 0;\n\n    // -- merklized\n    this.merklized = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    //  - userID\n    this.userID = Id.fromBigInt(BigInt(sVals[fieldIdx]));\n    fieldIdx++;\n\n    // - requestID\n    this.requestID = BigInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - issuerID\n    this.issuerID = Id.fromBigInt(BigInt(sVals[fieldIdx]));\n    fieldIdx++;\n\n    // - issuerClaimIdenState\n    this.issuerClaimIdenState = Hash.fromString(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - isRevocationChecked\n    this.isRevocationChecked = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - issuerClaimNonRevState\n    this.issuerClaimNonRevState = Hash.fromString(sVals[fieldIdx]);\n    fieldIdx++;\n\n    //  - timestamp\n    this.timestamp = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    //  - claimSchema\n    this.claimSchema = SchemaHash.newSchemaHashFromInt(BigInt(sVals[fieldIdx]));\n    fieldIdx++;\n\n    // - ClaimPathNotExists\n    this.claimPathNotExists = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - ClaimPathKey\n    this.claimPathKey = BigInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - slotIndex\n    this.slotIndex = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - operator\n    this.operator = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    //  - values\n    for (let index = 0; index < this.getValueArrSize(); index++) {\n      this.value.push(BigInt(sVals[fieldIdx]));\n      fieldIdx++;\n    }\n\n    return this;\n  }\n}\n","import { Id, Claim } from '@iden3/js-iden3-core';\nimport { Signature } from '@iden3/js-crypto';\nimport { Query, ValueProof, CircuitError, TreeState, GISTProof, ClaimWithMTPProof } from './models';\nimport { Hash, Proof } from '@iden3/js-merkletree';\nimport {\n  BaseConfig,\n  bigIntArrayToStringArray,\n  existenceToInt,\n  getNodeAuxValue,\n  IStateInfoPubSignals,\n  StatesInfo,\n  prepareCircuitArrayValues,\n  prepareSiblingsStr\n} from './common';\nimport { byteDecoder, byteEncoder } from '../utils';\n\n/**\n * AtomicQueryMTPV2OnChainInputs ZK private inputs for credentialAtomicQueryMTPV2OnChain.circom\n *\n * @public\n * @class AtomicQuerySigV2OnChainInputs\n * @extends {BaseConfig}\n */\nexport class AtomicQueryMTPV2OnChainInputs extends BaseConfig {\n  // auth\n  id!: Id;\n  profileNonce!: bigint;\n  claimSubjectProfileNonce!: bigint;\n  // claim issued for user\n  claim!: ClaimWithMTPProof;\n  skipClaimRevocationCheck!: boolean;\n  requestID!: bigint;\n\n  currentTimeStamp!: number;\n\n  authClaim!: Claim;\n  authClaimIncMtp!: Proof;\n  authClaimNonRevMtp!: Proof;\n  treeState!: TreeState;\n\n  gistProof!: GISTProof;\n\n  signature!: Signature;\n  challenge!: bigint;\n\n  // query\n  query!: Query;\n\n  /**\n   *  Validate inputs\n   *\n   */\n  validate(): void {\n    if (!this.requestID) {\n      throw new Error(CircuitError.EmptyRequestID);\n    }\n    if (!this.authClaimIncMtp) {\n      throw new Error(CircuitError.EmptyAuthClaimProof);\n    }\n    if (!this.authClaimNonRevMtp) {\n      throw new Error(CircuitError.EmptyAuthClaimNonRevProof);\n    }\n    if (!this.gistProof.proof) {\n      throw new Error(CircuitError.EmptyGISTProof);\n    }\n    if (!this.signature) {\n      throw new Error(CircuitError.EmptyChallengeSignature);\n    }\n    if (this.challenge === null || this.challenge === undefined) {\n      throw new Error(CircuitError.EmptyChallenge);\n    }\n  }\n\n  /**\n   * marshal inputs\n   *\n   * @returns Uint8Array\n   */\n  inputsMarshal(): Uint8Array {\n    this.validate();\n    if (this.query.valueProof) {\n      this.query.validate();\n      this.query.valueProof.validate();\n    }\n\n    const valueProof = this.query.valueProof ?? new ValueProof();\n    const s: Partial<atomicQueryMTPV2OnChainCircuitInputs> = {\n      requestID: this.requestID.toString(),\n      userGenesisID: this.id.bigInt().toString(),\n      profileNonce: this.profileNonce.toString(),\n      claimSubjectProfileNonce: this.claimSubjectProfileNonce?.toString(),\n      issuerID: this.claim.issuerID?.bigInt().toString(),\n      issuerClaim: this.claim.claim?.marshalJson(),\n      issuerClaimMtp:\n        this.claim.incProof?.proof &&\n        prepareSiblingsStr(this.claim.incProof.proof, this.getMTLevel()),\n      issuerClaimClaimsTreeRoot: this.claim.incProof?.treeState?.claimsRoot?.string(),\n      issuerClaimRevTreeRoot: this.claim.incProof?.treeState?.revocationRoot?.string(),\n      issuerClaimRootsTreeRoot: this.claim.incProof?.treeState?.rootOfRoots?.string(),\n      issuerClaimIdenState: this.claim.incProof?.treeState?.state?.string(),\n      issuerClaimNonRevMtp:\n        this.claim.nonRevProof?.proof &&\n        prepareSiblingsStr(this.claim.nonRevProof?.proof, this.getMTLevel()),\n      issuerClaimNonRevClaimsTreeRoot: this.claim.nonRevProof?.treeState?.claimsRoot?.string(),\n      issuerClaimNonRevRevTreeRoot: this.claim.nonRevProof?.treeState?.revocationRoot?.string(),\n      issuerClaimNonRevRootsTreeRoot: this.claim.nonRevProof?.treeState?.rootOfRoots?.string(),\n      issuerClaimNonRevState: this.claim.nonRevProof?.treeState?.state?.string(),\n      claimSchema: this.claim.claim?.getSchemaHash().bigInt().toString(),\n      claimPathMtp: prepareSiblingsStr(valueProof.mtp, this.getMTLevelsClaim()),\n      claimPathValue: valueProof.value.toString(),\n      operator: this.query.operator,\n      slotIndex: this.query.slotIndex,\n      timestamp: this.currentTimeStamp ?? undefined,\n      isRevocationChecked: 1,\n      authClaim: this.authClaim.marshalJson(),\n      authClaimIncMtp:\n        this.authClaimIncMtp && prepareSiblingsStr(this.authClaimIncMtp, this.getMTLevel()),\n      authClaimNonRevMtp:\n        this.authClaimNonRevMtp && prepareSiblingsStr(this.authClaimNonRevMtp, this.getMTLevel()),\n      challenge: this.challenge.toString(),\n      challengeSignatureR8x: this.signature.R8[0].toString(),\n      challengeSignatureR8y: this.signature.R8[1].toString(),\n      challengeSignatureS: this.signature.S.toString(),\n      userClaimsTreeRoot: this.treeState.claimsRoot?.string(),\n      userRevTreeRoot: this.treeState.revocationRoot?.string(),\n      userRootsTreeRoot: this.treeState.rootOfRoots?.string(),\n      userState: this.treeState.state?.string(),\n      gistRoot: this.gistProof.root?.string(),\n      gistMtp: this.gistProof && prepareSiblingsStr(this.gistProof.proof, this.getMTLevelOnChain())\n    };\n\n    if (this.skipClaimRevocationCheck) {\n      s.isRevocationChecked = 0;\n    }\n\n    const nodeAuxNonRev =\n      this.claim.nonRevProof?.proof && getNodeAuxValue(this.claim.nonRevProof.proof);\n    s.issuerClaimNonRevMtpAuxHi = nodeAuxNonRev?.key.bigInt().toString();\n    s.issuerClaimNonRevMtpAuxHv = nodeAuxNonRev?.value.bigInt().toString();\n    s.issuerClaimNonRevMtpNoAux = nodeAuxNonRev?.noAux;\n\n    s.claimPathNotExists = existenceToInt(valueProof.mtp.existence);\n    const nodAuxJSONLD = getNodeAuxValue(valueProof.mtp);\n    s.claimPathMtpNoAux = nodAuxJSONLD.noAux;\n    s.claimPathMtpAuxHi = nodAuxJSONLD.key.bigInt().toString();\n    s.claimPathMtpAuxHv = nodAuxJSONLD.value.bigInt().toString();\n\n    s.claimPathKey = valueProof.path.toString();\n    const values =\n      this.query.values && prepareCircuitArrayValues(this.query.values, this.getValueArrSize());\n    s.value = values && bigIntArrayToStringArray(values);\n\n    const nodeAuxAuth = this.authClaimNonRevMtp && getNodeAuxValue(this.authClaimNonRevMtp);\n    s.authClaimNonRevMtpAuxHi = nodeAuxAuth.key.string();\n    s.authClaimNonRevMtpAuxHv = nodeAuxAuth.value.string();\n    s.authClaimNonRevMtpNoAux = nodeAuxAuth.noAux;\n\n    const globalNodeAux = this.gistProof && getNodeAuxValue(this.gistProof.proof);\n    s.gistMtpAuxHi = globalNodeAux.key.string();\n    s.gistMtpAuxHv = globalNodeAux.value.string();\n    s.gistMtpNoAux = globalNodeAux.noAux;\n\n    return byteEncoder.encode(JSON.stringify(s));\n  }\n}\n\n// atomicQueryMTPV2OnChainCircuitInputs type represents credentialAtomicQueryMTP.circom private inputs required by prover\ninterface atomicQueryMTPV2OnChainCircuitInputs {\n  requestID: string;\n  userGenesisID: string;\n  profileNonce: string;\n  claimSubjectProfileNonce: string;\n  issuerID: string;\n  issuerClaim: string[];\n\n  issuerClaimMtp: string[];\n  issuerClaimClaimsTreeRoot: string;\n  issuerClaimRevTreeRoot: string;\n  issuerClaimRootsTreeRoot: string;\n  issuerClaimIdenState: string;\n\n  issuerClaimNonRevClaimsTreeRoot: string;\n  issuerClaimNonRevRevTreeRoot: string;\n  issuerClaimNonRevRootsTreeRoot: string;\n  issuerClaimNonRevState: string;\n  issuerClaimNonRevMtp: string[];\n  issuerClaimNonRevMtpAuxHi?: string;\n  issuerClaimNonRevMtpAuxHv?: string;\n  issuerClaimNonRevMtpNoAux: string;\n\n  isRevocationChecked: number;\n  claimSchema: string;\n  // Query\n  // JSON path\n  claimPathNotExists: number; // 0 for inclusion, 1 for non-inclusion\n  claimPathMtp: string[];\n  claimPathMtpNoAux: string; // 1 if aux node is empty,\n  // 0 if non-empty or for inclusion proofs\n  claimPathMtpAuxHi: string; // 0 for inclusion proof\n  claimPathMtpAuxHv: string; // 0 for inclusion proof\n  claimPathKey: string; // hash of path in merklized json-ld document\n  claimPathValue: string; // value in this path in merklized json-ld document\n\n  operator: number;\n  slotIndex: number;\n  timestamp: number;\n  value: string[];\n\n  // AuthClaim proof of inclusion\n  authClaim: string[];\n  authClaimIncMtp: string[];\n\n  // AuthClaim non revocation proof\n  authClaimNonRevMtp: string[];\n  authClaimNonRevMtpAuxHi: string;\n  authClaimNonRevMtpAuxHv: string;\n  authClaimNonRevMtpNoAux: string;\n\n  challenge: string;\n  challengeSignatureR8x: string;\n  challengeSignatureR8y: string;\n  challengeSignatureS: string;\n\n  // User State\n  userClaimsTreeRoot: string;\n  userRevTreeRoot: string;\n  userRootsTreeRoot: string;\n  userState: string;\n\n  // Global on-cain state\n  gistRoot: string;\n  gistMtp: string[];\n  gistMtpAuxHi: string;\n  gistMtpAuxHv: string;\n  gistMtpNoAux: string;\n}\n\n/**\n *\n * public signals\n * @public\n * @class AtomicQueryMTPV2OnChainPubSignals\n * @extends {BaseConfig}\n */\nexport class AtomicQueryMTPV2OnChainPubSignals extends BaseConfig implements IStateInfoPubSignals {\n  requestID!: bigint;\n  userID!: Id;\n  issuerID!: Id;\n  issuerClaimIdenState!: Hash;\n  issuerClaimNonRevState!: Hash;\n  timestamp!: number;\n  merklized!: number;\n  isRevocationChecked!: number; // 0 revocation not check, // 1 for check revocation\n  circuitQueryHash!: bigint;\n  challenge!: bigint;\n  gistRoot!: Hash;\n\n  /**\n   *\n   * // PubSignalsUnmarshal unmarshal credentialAtomicQueryMTPV2OnChain.circom public signals array to AtomicQueryMTPPubSignals\n   * @param {Uint8Array} data\n   * @returns AtomicQuerySigV2PubSignals\n   */\n  pubSignalsUnmarshal(data: Uint8Array): AtomicQueryMTPV2OnChainPubSignals {\n    // expected order:\n    // merklized\n    // userID\n    // circuitQueryHash\n    // requestID\n    // challenge\n    // gistRoot\n    // issuerID\n    // issuerClaimIdenState\n    // isRevocationChecked\n    // issuerClaimNonRevState\n    // timestamp\n\n    const sVals: string[] = JSON.parse(byteDecoder.decode(data));\n    let fieldIdx = 0;\n\n    // -- merklized\n    this.merklized = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    //  - userID\n    this.userID = Id.fromBigInt(BigInt(sVals[fieldIdx]));\n    fieldIdx++;\n\n    //  - circuitQueryHash\n    this.circuitQueryHash = BigInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - requestID\n    this.requestID = BigInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - challenge\n    this.challenge = BigInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - gistRoot\n    this.gistRoot = Hash.fromString(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - issuerID\n    this.issuerID = Id.fromBigInt(BigInt(sVals[fieldIdx]));\n    fieldIdx++;\n\n    // - issuerClaimIdenState\n    this.issuerClaimIdenState = Hash.fromString(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - isRevocationChecked\n    this.isRevocationChecked = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - issuerClaimNonRevState\n    this.issuerClaimNonRevState = Hash.fromString(sVals[fieldIdx]);\n    fieldIdx++;\n\n    //  - timestamp\n    this.timestamp = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    return this;\n  }\n\n  /** {@inheritDoc IStateInfoPubSignals.getStatesInfo} */\n  getStatesInfo(): StatesInfo {\n    return {\n      states: [\n        { id: this.issuerID, state: this.issuerClaimIdenState },\n        { id: this.issuerID, state: this.issuerClaimNonRevState }\n      ],\n      gists: [{ id: this.userID, root: this.gistRoot }]\n    };\n  }\n}\n","import { Id, SchemaHash } from '@iden3/js-iden3-core';\nimport { Query, ValueProof, CircuitError, ClaimWithSigProof } from './models';\nimport { Hash } from '@iden3/js-merkletree';\nimport {\n  BaseConfig,\n  bigIntArrayToStringArray,\n  existenceToInt,\n  getNodeAuxValue,\n  prepareCircuitArrayValues,\n  prepareSiblingsStr\n} from './common';\nimport { QueryOperators } from './comparer';\nimport { byteDecoder, byteEncoder } from '../utils';\n\n/**\n * AtomicQuerySigV2Inputs representation for credentialAtomicQuerySig.circom\n * Inputs and public signals declaration, marshalling and parsing\n *\n * @public\n * @class AtomicQuerySigV2Inputs\n * @extends {BaseConfig}\n */\nexport class AtomicQuerySigV2Inputs extends BaseConfig {\n  requestID!: bigint;\n  // auth\n  id!: Id;\n  profileNonce!: bigint;\n  claimSubjectProfileNonce!: bigint;\n\n  // claim issued for user\n  claim!: ClaimWithSigProof;\n  skipClaimRevocationCheck!: boolean;\n\n  currentTimeStamp!: number;\n\n  // query\n  query!: Query;\n\n  /**\n   *  Validate inputs\n   *\n   */\n  validate(): void {\n    if (!this.requestID) {\n      throw new Error(CircuitError.EmptyRequestID);\n    }\n    if (!this.claim.nonRevProof?.proof) {\n      throw new Error(CircuitError.EmptyClaimNonRevProof);\n    }\n\n    if (!this.claim.signatureProof?.issuerAuthIncProof.proof) {\n      throw new Error(CircuitError.EmptyIssuerAuthClaimProof);\n    }\n\n    if (!this.claim.signatureProof.issuerAuthNonRevProof.proof) {\n      throw new Error(CircuitError.EmptyIssuerAuthClaimNonRevProof);\n    }\n\n    if (!this.claim.signatureProof.signature) {\n      throw new Error(CircuitError.EmptyClaimSignature);\n    }\n\n    if (!this.query.values && this.query.operator !== QueryOperators.$noop) {\n      throw new Error(CircuitError.EmptyQueryValue);\n    }\n  }\n\n  /**\n   * marshal inputs\n   *\n   * @returns Uint8Array\n   */\n  inputsMarshal(): Uint8Array {\n    this.validate();\n    if (this.query.valueProof) {\n      this.query.validate();\n      this.query.valueProof.validate();\n    }\n\n    const valueProof = this.query.valueProof ?? new ValueProof();\n\n    const treeState = this.skipClaimRevocationCheck\n      ? this.claim.signatureProof?.issuerAuthNonRevProof.treeState\n      : this.claim.nonRevProof?.treeState;\n\n    const s: Partial<AtomicQuerySigV2CircuitInputs> = {\n      requestID: this.requestID.toString(),\n      userGenesisID: this.id.bigInt().toString(),\n      profileNonce: this.profileNonce.toString(),\n      claimSubjectProfileNonce: this.claimSubjectProfileNonce?.toString(),\n      issuerID: this.claim.issuerID?.bigInt().toString(),\n      issuerClaim: this.claim.claim?.marshalJson(),\n      issuerClaimNonRevClaimsTreeRoot: treeState?.claimsRoot.bigInt().toString(),\n      issuerClaimNonRevRevTreeRoot: treeState?.revocationRoot.bigInt().toString(),\n      issuerClaimNonRevRootsTreeRoot: treeState?.rootOfRoots.bigInt().toString(),\n      issuerClaimNonRevState: treeState?.state.bigInt().toString(),\n      issuerClaimNonRevMtp:\n        this.claim.nonRevProof?.proof &&\n        prepareSiblingsStr(this.claim.nonRevProof.proof, this.getMTLevel()),\n      issuerClaimSignatureR8x: this.claim.signatureProof?.signature.R8[0].toString(),\n      issuerClaimSignatureR8y: this.claim.signatureProof?.signature.R8[1].toString(),\n      issuerClaimSignatureS: this.claim.signatureProof?.signature.S.toString(),\n      issuerAuthClaim: this.claim.signatureProof?.issuerAuthClaim?.marshalJson(),\n      issuerAuthClaimMtp:\n        this.claim.signatureProof?.issuerAuthIncProof?.proof &&\n        prepareSiblingsStr(this.claim.signatureProof.issuerAuthIncProof.proof, this.getMTLevel()),\n      issuerAuthClaimsTreeRoot: this.claim.signatureProof?.issuerAuthIncProof.treeState?.claimsRoot\n        .bigInt()\n        .toString(),\n      issuerAuthRevTreeRoot:\n        this.claim.signatureProof?.issuerAuthIncProof?.treeState?.revocationRoot\n          .bigInt()\n          .toString(),\n      issuerAuthRootsTreeRoot: this.claim.signatureProof?.issuerAuthIncProof?.treeState?.rootOfRoots\n        .bigInt()\n        .toString(),\n\n      issuerAuthClaimNonRevMtp:\n        this.claim.signatureProof?.issuerAuthNonRevProof?.proof &&\n        prepareSiblingsStr(\n          this.claim.signatureProof.issuerAuthNonRevProof.proof,\n          this.getMTLevel()\n        ),\n\n      claimSchema: this.claim.claim?.getSchemaHash().bigInt().toString(),\n\n      claimPathMtp: prepareSiblingsStr(valueProof.mtp, this.getMTLevelsClaim()),\n      claimPathValue: valueProof.value.toString(),\n      operator: this.query.operator,\n      timestamp: this.currentTimeStamp,\n      // value in this path in merklized json-ld document\n      slotIndex: this.query.slotIndex\n    };\n\n    if (this.skipClaimRevocationCheck) {\n      s.isRevocationChecked = 0;\n    } else {\n      s.isRevocationChecked = 1;\n    }\n    const nodeAuxNonRev = getNodeAuxValue(this.claim.nonRevProof?.proof);\n    s.issuerClaimNonRevMtpAuxHi = nodeAuxNonRev?.key.bigInt().toString();\n    s.issuerClaimNonRevMtpAuxHv = nodeAuxNonRev?.value.bigInt().toString();\n    s.issuerClaimNonRevMtpNoAux = nodeAuxNonRev?.noAux;\n\n    const nodeAuxIssuerAuthNonRev =\n      this.claim.signatureProof &&\n      getNodeAuxValue(this.claim.signatureProof.issuerAuthNonRevProof.proof);\n    s.issuerAuthClaimNonRevMtpAuxHi = nodeAuxIssuerAuthNonRev?.key.bigInt().toString();\n    s.issuerAuthClaimNonRevMtpAuxHv = nodeAuxIssuerAuthNonRev?.value.bigInt().toString();\n    s.issuerAuthClaimNonRevMtpNoAux = nodeAuxIssuerAuthNonRev?.noAux;\n\n    s.claimPathNotExists = existenceToInt(valueProof.mtp.existence);\n    const nodAuxJSONLD = getNodeAuxValue(valueProof.mtp);\n    s.claimPathMtpNoAux = nodAuxJSONLD.noAux;\n    s.claimPathMtpAuxHi = nodAuxJSONLD.key.bigInt().toString();\n    s.claimPathMtpAuxHv = nodAuxJSONLD.value.bigInt().toString();\n\n    s.claimPathKey = valueProof.path.toString();\n\n    if (this.skipClaimRevocationCheck) {\n      s.isRevocationChecked = 0;\n    } else {\n      s.isRevocationChecked = 1;\n    }\n\n    const values = prepareCircuitArrayValues(this.query.values, this.getValueArrSize());\n    s.value = bigIntArrayToStringArray(values);\n\n    return byteEncoder.encode(JSON.stringify(s));\n  }\n}\n\ninterface AtomicQuerySigV2CircuitInputs {\n  requestID: string;\n  userGenesisID: string;\n  profileNonce: string;\n  claimSubjectProfileNonce: string;\n  issuerID: string;\n  issuerClaim?: string[];\n  issuerClaimNonRevClaimsTreeRoot: string;\n  issuerClaimNonRevRevTreeRoot: string;\n  issuerClaimNonRevRootsTreeRoot: string;\n  issuerClaimNonRevState: string;\n  issuerClaimNonRevMtp: string[];\n  issuerClaimNonRevMtpAuxHi?: string;\n  issuerClaimNonRevMtpAuxHv?: string;\n  issuerClaimNonRevMtpNoAux: string;\n  claimSchema: string;\n  issuerClaimSignatureR8x: string;\n  issuerClaimSignatureR8y: string;\n  issuerClaimSignatureS: string;\n  issuerAuthClaim?: string[];\n  issuerAuthClaimMtp: string[];\n  issuerAuthClaimNonRevMtp: string[];\n  issuerAuthClaimNonRevMtpAuxHi?: string;\n  issuerAuthClaimNonRevMtpAuxHv?: string;\n  issuerAuthClaimNonRevMtpNoAux: string;\n  issuerAuthClaimsTreeRoot: string;\n  issuerAuthRevTreeRoot: string;\n  issuerAuthRootsTreeRoot: string;\n  isRevocationChecked: number;\n  claimPathNotExists: number;\n  claimPathMtp: string[];\n  claimPathMtpNoAux: string;\n  claimPathMtpAuxHi?: string;\n  claimPathMtpAuxHv?: string;\n  claimPathKey: string;\n  claimPathValue: string;\n  operator: number;\n  slotIndex: number;\n  timestamp: number;\n  value: string[];\n}\n\n/**\n *\n * public signals\n * @public\n * @class AtomicQuerySigV2PubSignals\n * @extends {BaseConfig}\n */\nexport class AtomicQuerySigV2PubSignals extends BaseConfig {\n  requestID!: bigint;\n  userID!: Id;\n  issuerID!: Id;\n  issuerAuthState!: Hash;\n  issuerClaimNonRevState!: Hash;\n  claimSchema!: SchemaHash;\n  slotIndex!: number;\n  operator!: number;\n  value: bigint[] = [];\n  timestamp!: number;\n  merklized!: number;\n  claimPathKey!: bigint;\n  // 0 for inclusion, 1 for non-inclusion\n  claimPathNotExists!: number;\n  // 0 revocation not check, // 1 for check revocation\n  isRevocationChecked!: number;\n\n  //\n  /**\n   *\n   * PubSignalsUnmarshal unmarshal credentialAtomicQuerySig.circom public signals array to AtomicQuerySugPubSignals\n   * @param {Uint8Array} data\n   * @returns AtomicQuerySigV2PubSignals\n   */\n  pubSignalsUnmarshal(data: Uint8Array): AtomicQuerySigV2PubSignals {\n    // expected order:\n    // merklized\n    // userID\n    // issuerAuthState\n    // requestID\n    // issuerID\n    // issuerClaimNonRevState\n    // timestamp\n    // claimSchema\n    // claimPathNotExists\n    // claimPathKey\n    // slotIndex\n    // operator\n    // value\n\n    // 12 is a number of fields in AtomicQuerySigV2PubSignals before values, values is last element in the proof and\n    // it is length could be different base on the circuit configuration. The length could be modified by set value\n    // in ValueArraySize\n    const fieldLength = 13;\n\n    const sVals: string[] = JSON.parse(byteDecoder.decode(data));\n\n    if (sVals.length !== fieldLength + this.getValueArrSize()) {\n      throw new Error(\n        `invalid number of Output values expected ${fieldLength + this.getValueArrSize()} got ${\n          sVals.length\n        }`\n      );\n    }\n\n    let fieldIdx = 0;\n\n    // -- merklized\n    this.merklized = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    //  - userID\n    this.userID = Id.fromBigInt(BigInt(sVals[fieldIdx]));\n    fieldIdx++;\n\n    // - issuerAuthState\n    this.issuerAuthState = Hash.fromString(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - requestID\n    this.requestID = BigInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - issuerID\n    this.issuerID = Id.fromBigInt(BigInt(sVals[fieldIdx]));\n    fieldIdx++;\n\n    // - isRevocationChecked\n    this.isRevocationChecked = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - issuerClaimNonRevState\n    this.issuerClaimNonRevState = Hash.fromString(sVals[fieldIdx]);\n    fieldIdx++;\n\n    //  - timestamp\n    this.timestamp = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    //  - claimSchema\n    this.claimSchema = SchemaHash.newSchemaHashFromInt(BigInt(sVals[fieldIdx]));\n    fieldIdx++;\n\n    // - ClaimPathNotExists\n    this.claimPathNotExists = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - ClaimPathKey\n    this.claimPathKey = BigInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - slotIndex\n    this.slotIndex = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - operator\n    this.operator = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    //  - values\n    for (let index = 0; index < this.getValueArrSize(); index++) {\n      this.value.push(BigInt(sVals[fieldIdx]));\n      fieldIdx++;\n    }\n\n    return this;\n  }\n}\n","import { Claim, Id, SchemaHash } from '@iden3/js-iden3-core';\nimport {\n  BaseConfig,\n  bigIntArrayToStringArray,\n  prepareSiblingsStr,\n  getNodeAuxValue,\n  prepareCircuitArrayValues\n} from './common';\nimport { BJJSignatureProof, CircuitError, MTProof, Query, ValueProof } from './models';\nimport { Hash, Proof, ZERO_HASH } from '@iden3/js-merkletree';\nimport { byteDecoder, byteEncoder } from '../utils';\nimport { ProofType } from '../verifiable';\n\nconst zero = '0';\n\nexport interface ClaimWithSigAndMTPProof {\n  issuerID: Id;\n  claim: Claim;\n  nonRevProof: MTProof;\n  signatureProof?: BJJSignatureProof;\n  incProof?: MTProof;\n}\n/**\n * AtomicQueryV3Inputs ZK private inputs for credentialAtomicQueryV3.circom\n *\n * @beta\n * @class AtomicQueryV3Inputs\n * @extends {BaseConfig}\n */\nexport class AtomicQueryV3Inputs extends BaseConfig {\n  requestID!: bigint;\n  id!: Id;\n  profileNonce!: bigint;\n  claimSubjectProfileNonce!: bigint;\n  claim!: ClaimWithSigAndMTPProof;\n  skipClaimRevocationCheck!: boolean;\n  query!: Query;\n  currentTimeStamp!: number;\n  proofType!: ProofType;\n  linkNonce!: bigint;\n  verifierID?: Id;\n  nullifierSessionID!: bigint;\n\n  validate(): void {\n    if (!this.requestID) {\n      throw new Error(CircuitError.EmptyRequestID);\n    }\n\n    if (!this.claim.nonRevProof.proof) {\n      throw new Error(CircuitError.EmptyClaimNonRevProof);\n    }\n\n    if (!this.query.values) {\n      throw new Error(CircuitError.EmptyQueryValue);\n    }\n\n    this.query.validateValueArraySize(this.getValueArrSize());\n\n    if (!this.proofType) {\n      throw new Error(CircuitError.InvalidProofType);\n    }\n\n    if (this.proofType === ProofType.BJJSignature) {\n      if (!this.claim.signatureProof?.issuerAuthIncProof.proof) {\n        throw new Error(CircuitError.EmptyIssuerAuthClaimProof);\n      }\n\n      if (!this.claim.signatureProof.issuerAuthNonRevProof.proof) {\n        throw new Error(CircuitError.EmptyIssuerAuthClaimNonRevProof);\n      }\n\n      if (!this.claim.signatureProof.signature) {\n        throw new Error(CircuitError.EmptyClaimSignature);\n      }\n    }\n    if (this.proofType === ProofType.Iden3SparseMerkleTreeProof) {\n      if (!this.claim?.incProof?.proof) {\n        throw new Error(CircuitError.EmptyClaimProof);\n      }\n    }\n  }\n\n  fillMTPProofsWithZero(s: Partial<AtomicQueryV3CircuitInputs>) {\n    s.issuerClaimMtp = prepareSiblingsStr(new Proof(), this.getMTLevel());\n    s.issuerClaimClaimsTreeRoot = ZERO_HASH.bigInt().toString();\n    s.issuerClaimRevTreeRoot = ZERO_HASH.bigInt().toString();\n    s.issuerClaimRootsTreeRoot = ZERO_HASH.bigInt().toString();\n    s.issuerClaimIdenState = ZERO_HASH.bigInt().toString();\n  }\n\n  fillSigProofWithZero(s: Partial<AtomicQueryV3CircuitInputs>) {\n    s.issuerClaimSignatureR8x = zero;\n    s.issuerClaimSignatureR8y = zero;\n    s.issuerClaimSignatureS = zero;\n    s.issuerAuthClaim = new Claim().marshalJson();\n    s.issuerAuthClaimMtp = prepareSiblingsStr(new Proof(), this.getMTLevel());\n    s.issuerAuthClaimsTreeRoot = zero;\n    s.issuerAuthRevTreeRoot = zero;\n    s.issuerAuthRootsTreeRoot = zero;\n    s.issuerAuthClaimNonRevMtp = prepareSiblingsStr(new Proof(), this.getMTLevel());\n\n    s.issuerAuthClaimNonRevMtpAuxHi = ZERO_HASH.bigInt().toString();\n    s.issuerAuthClaimNonRevMtpAuxHv = ZERO_HASH.bigInt().toString();\n    s.issuerAuthClaimNonRevMtpNoAux = zero;\n    s.issuerAuthState = zero;\n  }\n\n  // InputsMarshal returns Circom private inputs for credentialAtomicQueryV3.circom\n  inputsMarshal(): Uint8Array {\n    this.validate();\n\n    if (this.query.valueProof) {\n      this.query.validate();\n      this.query.valueProof.validate();\n    }\n\n    let valueProof = this.query.valueProof;\n\n    if (!valueProof) {\n      valueProof = new ValueProof();\n      valueProof.path = 0n;\n      valueProof.value = 0n;\n      valueProof.mtp = new Proof();\n    }\n\n    let treeState = this.claim.nonRevProof.treeState;\n    if (this.proofType === ProofType.BJJSignature && this.skipClaimRevocationCheck) {\n      treeState = this.claim.signatureProof?.issuerAuthNonRevProof.treeState;\n    }\n\n    if (!treeState) {\n      throw new Error(CircuitError.EmptyTreeState);\n    }\n\n    const s: Partial<AtomicQueryV3CircuitInputs> = {\n      requestID: this.requestID.toString(),\n      userGenesisID: this.id.bigInt().toString(),\n      profileNonce: this.profileNonce.toString(),\n      claimSubjectProfileNonce: this.claimSubjectProfileNonce.toString(),\n      issuerID: this.claim.issuerID.bigInt().toString(),\n      issuerClaim: this.claim.claim.marshalJson(),\n\n      issuerClaimNonRevClaimsTreeRoot: treeState.claimsRoot.bigInt().toString(),\n      issuerClaimNonRevRevTreeRoot: treeState.revocationRoot.bigInt().toString(),\n      issuerClaimNonRevRootsTreeRoot: treeState.rootOfRoots.bigInt().toString(),\n      issuerClaimNonRevState: treeState.state.bigInt().toString(),\n      issuerClaimNonRevMtp: prepareSiblingsStr(\n        this.claim.nonRevProof.proof as Proof,\n        this.getMTLevel()\n      ),\n\n      claimSchema: this.claim.claim.getSchemaHash().bigInt().toString(),\n\n      claimPathMtp: prepareSiblingsStr(valueProof.mtp, this.getMTLevelsClaim()),\n      claimPathValue: valueProof.value.toString(),\n      operator: this.query.operator,\n      timestamp: this.currentTimeStamp,\n      // value in this path in merklized json-ld document\n\n      slotIndex: this.query.slotIndex,\n      isRevocationChecked: 1\n    };\n\n    if (this.skipClaimRevocationCheck) {\n      s.isRevocationChecked = 0;\n    }\n\n    if (this.proofType === ProofType.BJJSignature) {\n      const sigProof = this.claim.signatureProof as BJJSignatureProof;\n      s.proofType = '1';\n\n      s.issuerClaimSignatureR8x = sigProof.signature.R8[0].toString();\n      s.issuerClaimSignatureR8y = sigProof.signature.R8[1].toString();\n      s.issuerClaimSignatureS = sigProof.signature.S.toString();\n      s.issuerAuthClaim = sigProof.issuerAuthClaim?.marshalJson();\n      s.issuerAuthClaimMtp = prepareSiblingsStr(\n        sigProof.issuerAuthIncProof.proof as Proof,\n        this.getMTLevel()\n      );\n\n      s.issuerAuthClaimsTreeRoot = sigProof.issuerAuthIncProof.treeState?.claimsRoot\n        .bigInt()\n        .toString();\n      s.issuerAuthRevTreeRoot = sigProof.issuerAuthIncProof.treeState?.revocationRoot\n        .bigInt()\n        .toString();\n      s.issuerAuthRootsTreeRoot = sigProof.issuerAuthIncProof.treeState?.rootOfRoots\n        .bigInt()\n        .toString();\n      s.issuerAuthClaimNonRevMtp = prepareSiblingsStr(\n        sigProof.issuerAuthNonRevProof.proof as Proof,\n        this.getMTLevel()\n      );\n\n      const nodeAuxIssuerAuthNonRev = getNodeAuxValue(sigProof.issuerAuthNonRevProof.proof);\n      s.issuerAuthClaimNonRevMtpAuxHi = nodeAuxIssuerAuthNonRev.key.bigInt().toString();\n      s.issuerAuthClaimNonRevMtpAuxHv = nodeAuxIssuerAuthNonRev.value.bigInt().toString();\n      s.issuerAuthClaimNonRevMtpNoAux = nodeAuxIssuerAuthNonRev.noAux;\n      s.issuerAuthState = sigProof.issuerAuthIncProof.treeState?.state.bigInt().toString();\n\n      this.fillMTPProofsWithZero(s);\n    } else if (this.proofType === ProofType.Iden3SparseMerkleTreeProof) {\n      s.proofType = '2';\n\n      const incProofTreeState = this.claim.incProof?.treeState;\n\n      if (!incProofTreeState) {\n        throw new Error(CircuitError.EmptyTreeState);\n      }\n\n      s.issuerClaimMtp = prepareSiblingsStr(this.claim.incProof?.proof as Proof, this.getMTLevel());\n      s.issuerClaimClaimsTreeRoot = incProofTreeState.claimsRoot.bigInt().toString();\n      s.issuerClaimRevTreeRoot = incProofTreeState.revocationRoot.bigInt().toString();\n      s.issuerClaimRootsTreeRoot = incProofTreeState.rootOfRoots.bigInt().toString();\n      s.issuerClaimIdenState = incProofTreeState.state.bigInt().toString();\n\n      this.fillSigProofWithZero(s);\n    }\n\n    const nodeAuxNonRev = getNodeAuxValue(this.claim.nonRevProof.proof);\n    s.issuerClaimNonRevMtpAuxHi = nodeAuxNonRev.key.bigInt().toString();\n    s.issuerClaimNonRevMtpAuxHv = nodeAuxNonRev.value.bigInt().toString();\n    s.issuerClaimNonRevMtpNoAux = nodeAuxNonRev.noAux;\n\n    const nodAuxJSONLD = getNodeAuxValue(valueProof.mtp);\n    s.claimPathMtpNoAux = nodAuxJSONLD.noAux;\n    s.claimPathMtpAuxHi = nodAuxJSONLD.key.bigInt().toString();\n    s.claimPathMtpAuxHv = nodAuxJSONLD.value.bigInt().toString();\n\n    s.claimPathKey = valueProof.path.toString();\n    s.valueArraySize = this.query.values.length;\n    const values = prepareCircuitArrayValues(this.query.values, this.getValueArrSize());\n    s.value = bigIntArrayToStringArray(values);\n\n    s.linkNonce = this.linkNonce.toString();\n    s.verifierID = this.verifierID?.bigInt().toString() ?? '0';\n    s.nullifierSessionID = this.nullifierSessionID.toString();\n\n    return byteEncoder.encode(JSON.stringify(s));\n  }\n}\n\n/**\n * @beta\n * AtomicQueryV3CircuitInputs type represents credentialAtomicQueryV3.circom private inputs required by prover\n */\ninterface AtomicQueryV3CircuitInputs {\n  requestID: string;\n  // user data\n  userGenesisID: string;\n  profileNonce: string;\n  claimSubjectProfileNonce: string;\n\n  issuerID: string;\n  // Claim\n  issuerClaim: string[];\n  issuerClaimNonRevClaimsTreeRoot: string;\n  issuerClaimNonRevRevTreeRoot: string;\n  issuerClaimNonRevRootsTreeRoot: string;\n  issuerClaimNonRevState: string;\n  issuerClaimNonRevMtp: string[];\n  issuerClaimNonRevMtpAuxHi: string;\n  issuerClaimNonRevMtpAuxHv: string;\n  issuerClaimNonRevMtpNoAux: string;\n  claimSchema: string;\n  issuerClaimSignatureR8x: string;\n  issuerClaimSignatureR8y: string;\n  issuerClaimSignatureS: string;\n  issuerAuthClaim: string[];\n  issuerAuthClaimMtp: string[];\n  issuerAuthClaimNonRevMtp: string[];\n  issuerAuthClaimNonRevMtpAuxHi: string;\n  issuerAuthClaimNonRevMtpAuxHv: string;\n  issuerAuthClaimNonRevMtpNoAux: string;\n  issuerAuthClaimsTreeRoot: string;\n  issuerAuthRevTreeRoot: string;\n  issuerAuthRootsTreeRoot: string;\n  issuerAuthState: string;\n\n  isRevocationChecked: number;\n  // Query\n  // JSON path\n  claimPathMtp: string[];\n  claimPathMtpNoAux: string; // 1 if aux node is empty, 0 if non-empty or for inclusion proofs\n  claimPathMtpAuxHi: string; // 0 for inclusion proof\n  claimPathMtpAuxHv: string; // 0 for inclusion proof\n  claimPathKey: string; // hash of path in merklized json-ld document\n  claimPathValue: string; // value in this path in merklized json-ld document\n\n  operator: number;\n  slotIndex: number;\n  timestamp: number;\n  value: string[];\n  valueArraySize: number;\n\n  issuerClaimMtp: string[];\n  issuerClaimClaimsTreeRoot: string;\n  issuerClaimRevTreeRoot: string;\n  issuerClaimRootsTreeRoot: string;\n  issuerClaimIdenState: string;\n\n  proofType: string;\n\n  // Private random nonce, used to generate LinkID\n  linkNonce: string;\n  verifierID: string;\n  nullifierSessionID: string;\n}\n/**\n * @beta\n * AtomicQueryV3PubSignals public inputs\n */\nexport class AtomicQueryV3PubSignals extends BaseConfig {\n  requestID!: bigint;\n  userID!: Id;\n  issuerID!: Id;\n  issuerState!: Hash;\n  issuerClaimNonRevState!: Hash;\n  claimSchema!: SchemaHash;\n  slotIndex!: number;\n  operator!: number;\n  value: bigint[] = [];\n  valueArraySize!: number;\n  timestamp!: number;\n  merklized!: number;\n  claimPathKey!: bigint;\n  isRevocationChecked!: number;\n  proofType!: number;\n  linkID!: bigint;\n  nullifier!: bigint;\n  operatorOutput!: bigint;\n  verifierID!: Id;\n  nullifierSessionID!: bigint;\n\n  // PubSignalsUnmarshal unmarshal credentialAtomicQueryV3.circom public signals\n  pubSignalsUnmarshal(data: Uint8Array): AtomicQueryV3PubSignals {\n    // expected order:\n    // merklized\n    // userID\n    // issuerState\n    // linkID\n    // nullifier\n    // operatorOutput\n    // proofType\n    // requestID\n    // issuerID\n    // isRevocationChecked\n    // issuerClaimNonRevState\n    // timestamp\n    // claimSchema\n    // claimPathKey\n    // slotIndex\n    // operator\n    // value\n    // valueArraySize\n    // verifierID\n    // nullifierSessionID\n\n    // 19 is a number of fields in AtomicQueryV3PubSignals before values, values is last element in the proof and\n    // it is length could be different base on the circuit configuration. The length could be modified by set value\n    // in ValueArraySize\n    const fieldLength = 19;\n\n    const sVals: string[] = JSON.parse(byteDecoder.decode(data));\n\n    if (sVals.length !== fieldLength + this.getValueArrSize()) {\n      throw new Error(\n        `invalid number of Output values expected ${fieldLength + this.getValueArrSize()} got ${\n          sVals.length\n        }`\n      );\n    }\n\n    let fieldIdx = 0;\n\n    // -- merklized\n    this.merklized = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    //  - userID\n    this.userID = Id.fromBigInt(BigInt(sVals[fieldIdx]));\n    fieldIdx++;\n\n    // - issuerState\n    this.issuerState = Hash.fromString(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - linkID\n    this.linkID = BigInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - nullifier\n    this.nullifier = BigInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - operatorOutput\n    this.operatorOutput = BigInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - proofType\n    this.proofType = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - requestID\n    this.requestID = BigInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - issuerID\n    this.issuerID = Id.fromBigInt(BigInt(sVals[fieldIdx]));\n    fieldIdx++;\n\n    // - isRevocationChecked\n    this.isRevocationChecked = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - issuerClaimNonRevState\n    this.issuerClaimNonRevState = Hash.fromString(sVals[fieldIdx]);\n    fieldIdx++;\n\n    //  - timestamp\n    this.timestamp = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    //  - claimSchema\n    this.claimSchema = SchemaHash.newSchemaHashFromInt(BigInt(sVals[fieldIdx]));\n    fieldIdx++;\n\n    // - ClaimPathKey\n    this.claimPathKey = BigInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - slotIndex\n    this.slotIndex = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - operator\n    this.operator = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    //  - values\n    for (let index = 0; index < this.getValueArrSize(); index++) {\n      this.value.push(BigInt(sVals[fieldIdx]));\n      fieldIdx++;\n    }\n\n    // - valueArraySize\n    this.valueArraySize = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - verifierID\n    if (sVals[fieldIdx] !== '0') {\n      this.verifierID = Id.fromBigInt(BigInt(sVals[fieldIdx]));\n    }\n    fieldIdx++;\n\n    // - nullifierSessionID\n    this.nullifierSessionID = BigInt(sVals[fieldIdx]);\n\n    return this;\n  }\n}\n","import { Claim, Id } from '@iden3/js-iden3-core';\nimport {\n  BaseConfig,\n  bigIntArrayToStringArray,\n  prepareSiblingsStr,\n  getNodeAuxValue,\n  prepareCircuitArrayValues,\n  IStateInfoPubSignals,\n  StatesInfo\n} from './common';\nimport { BJJSignatureProof, CircuitError, GISTProof, Query, TreeState, ValueProof } from './models';\nimport { Hash, Proof, ZERO_HASH } from '@iden3/js-merkletree';\nimport { byteDecoder, byteEncoder } from '../utils';\nimport { ClaimWithSigAndMTPProof } from './atomic-query-v3';\nimport { Signature } from '@iden3/js-crypto';\nimport { ProofType } from '../verifiable';\n\nconst zero = '0';\n\n/**\n * AtomicQueryV3OnChainInputs ZK private inputs for credentialAtomicQueryV3OnChain.circom\n *\n * @beta\n * @class AtomicQueryV3OnChainInputs\n * @extends {BaseConfig}\n */\nexport class AtomicQueryV3OnChainInputs extends BaseConfig {\n  requestID!: bigint;\n  id!: Id;\n  profileNonce!: bigint;\n  claimSubjectProfileNonce!: bigint;\n  claim!: ClaimWithSigAndMTPProof;\n  skipClaimRevocationCheck!: boolean;\n\n  // Auth inputs\n  authClaim!: Claim;\n  authClaimIncMtp!: Proof;\n  authClaimNonRevMtp!: Proof;\n  treeState!: TreeState;\n  gistProof!: GISTProof;\n  signature!: Signature;\n  challenge!: bigint;\n\n  query!: Query;\n  currentTimeStamp!: number;\n  proofType!: ProofType;\n  linkNonce!: bigint;\n  verifierID?: Id;\n  nullifierSessionID!: bigint;\n  isBJJAuthEnabled!: number;\n\n  validate(): void {\n    if (!this.requestID) {\n      throw new Error(CircuitError.EmptyRequestID);\n    }\n\n    if (!this.claim.nonRevProof.proof) {\n      throw new Error(CircuitError.EmptyClaimNonRevProof);\n    }\n\n    if (!this.query.values) {\n      throw new Error(CircuitError.EmptyQueryValue);\n    }\n\n    this.query.validateValueArraySize(this.getValueArrSize());\n\n    if (!this.proofType) {\n      throw new Error(CircuitError.InvalidProofType);\n    }\n\n    if (!this.challenge) {\n      throw new Error(CircuitError.EmptyChallenge);\n    }\n\n    if (this.isBJJAuthEnabled === 1) {\n      if (!this.authClaimIncMtp) {\n        throw new Error(CircuitError.EmptyAuthClaimProof);\n      }\n\n      if (!this.authClaimNonRevMtp) {\n        throw new Error(CircuitError.EmptyAuthClaimNonRevProof);\n      }\n\n      if (!this.signature) {\n        throw new Error(CircuitError.EmptyChallengeSignature);\n      }\n\n      if (!this.gistProof.proof) {\n        throw new Error(CircuitError.EmptyGISTProof);\n      }\n    }\n\n    if (this.proofType === ProofType.BJJSignature) {\n      if (!this.claim.signatureProof?.issuerAuthIncProof.proof) {\n        throw new Error(CircuitError.EmptyIssuerAuthClaimProof);\n      }\n\n      if (!this.claim.signatureProof.issuerAuthNonRevProof.proof) {\n        throw new Error(CircuitError.EmptyIssuerAuthClaimNonRevProof);\n      }\n\n      if (!this.claim.signatureProof.signature) {\n        throw new Error(CircuitError.EmptyClaimSignature);\n      }\n    }\n    if (this.proofType === ProofType.Iden3SparseMerkleTreeProof) {\n      if (!this.claim?.incProof?.proof) {\n        throw new Error(CircuitError.EmptyClaimProof);\n      }\n    }\n  }\n\n  fillMTPProofsWithZero(s: Partial<AtomicQueryV3OnChainCircuitInputs>) {\n    s.issuerClaimMtp = prepareSiblingsStr(new Proof(), this.getMTLevel());\n    s.issuerClaimClaimsTreeRoot = ZERO_HASH.bigInt().toString();\n    s.issuerClaimRevTreeRoot = ZERO_HASH.bigInt().toString();\n    s.issuerClaimRootsTreeRoot = ZERO_HASH.bigInt().toString();\n    s.issuerClaimIdenState = ZERO_HASH.bigInt().toString();\n  }\n\n  fillSigProofWithZero(s: Partial<AtomicQueryV3OnChainCircuitInputs>) {\n    s.issuerClaimSignatureR8x = zero;\n    s.issuerClaimSignatureR8y = zero;\n    s.issuerClaimSignatureS = zero;\n    s.issuerAuthClaim = new Claim().marshalJson();\n    s.issuerAuthClaimMtp = prepareSiblingsStr(new Proof(), this.getMTLevel());\n    s.issuerAuthClaimsTreeRoot = zero;\n    s.issuerAuthRevTreeRoot = zero;\n    s.issuerAuthRootsTreeRoot = zero;\n    s.issuerAuthClaimNonRevMtp = prepareSiblingsStr(new Proof(), this.getMTLevel());\n\n    s.issuerAuthClaimNonRevMtpAuxHi = ZERO_HASH.bigInt().toString();\n    s.issuerAuthClaimNonRevMtpAuxHv = ZERO_HASH.bigInt().toString();\n    s.issuerAuthClaimNonRevMtpNoAux = zero;\n    s.issuerAuthState = zero;\n  }\n\n  fillAuthWithZero(s: Partial<AtomicQueryV3OnChainCircuitInputs>) {\n    s.authClaim = new Claim().marshalJson();\n\n    s.userClaimsTreeRoot = ZERO_HASH.bigInt().toString();\n    s.userRevTreeRoot = ZERO_HASH.bigInt().toString();\n    s.userRootsTreeRoot = ZERO_HASH.bigInt().toString();\n    s.userState = ZERO_HASH.bigInt().toString();\n\n    s.authClaimIncMtp = prepareSiblingsStr(new Proof(), this.getMTLevel());\n    s.authClaimNonRevMtp = prepareSiblingsStr(new Proof(), this.getMTLevel());\n    s.challengeSignatureR8x = zero;\n    s.challengeSignatureR8y = zero;\n    s.challengeSignatureS = zero;\n    s.gistRoot = ZERO_HASH.bigInt().toString();\n    s.gistMtp = prepareSiblingsStr(new Proof(), this.getMTLevelOnChain());\n\n    s.authClaimNonRevMtpAuxHi = ZERO_HASH.bigInt().toString();\n    s.authClaimNonRevMtpAuxHv = ZERO_HASH.bigInt().toString();\n    s.authClaimNonRevMtpNoAux = zero;\n\n    s.gistMtpAuxHi = ZERO_HASH.bigInt().toString();\n    s.gistMtpAuxHv = ZERO_HASH.bigInt().toString();\n    s.gistMtpNoAux = zero;\n  }\n\n  // InputsMarshal returns Circom private inputs for credentialAtomicQueryV3OnChain.circom\n  inputsMarshal(): Uint8Array {\n    this.validate();\n\n    if (this.query.valueProof) {\n      this.query.validate();\n      this.query.valueProof.validate();\n    }\n\n    let valueProof = this.query.valueProof;\n\n    if (!valueProof) {\n      valueProof = new ValueProof();\n      valueProof.path = 0n;\n      valueProof.value = 0n;\n      valueProof.mtp = new Proof();\n    }\n\n    let treeState = this.claim.nonRevProof.treeState;\n    if (this.proofType === ProofType.BJJSignature && this.skipClaimRevocationCheck) {\n      treeState = this.claim.signatureProof?.issuerAuthNonRevProof.treeState;\n    }\n\n    if (!treeState) {\n      throw new Error(CircuitError.EmptyTreeState);\n    }\n\n    const s: Partial<AtomicQueryV3OnChainCircuitInputs> = {\n      requestID: this.requestID.toString(),\n      userGenesisID: this.id.bigInt().toString(),\n      profileNonce: this.profileNonce.toString(),\n      claimSubjectProfileNonce: this.claimSubjectProfileNonce.toString(),\n      issuerID: this.claim.issuerID.bigInt().toString(),\n      issuerClaim: this.claim.claim.marshalJson(),\n\n      issuerClaimNonRevClaimsTreeRoot: treeState.claimsRoot.bigInt().toString(),\n      issuerClaimNonRevRevTreeRoot: treeState.revocationRoot.bigInt().toString(),\n      issuerClaimNonRevRootsTreeRoot: treeState.rootOfRoots.bigInt().toString(),\n      issuerClaimNonRevState: treeState.state.bigInt().toString(),\n      issuerClaimNonRevMtp: prepareSiblingsStr(\n        this.claim.nonRevProof.proof as Proof,\n        this.getMTLevel()\n      ),\n\n      claimSchema: this.claim.claim.getSchemaHash().bigInt().toString(),\n\n      claimPathMtp: prepareSiblingsStr(valueProof.mtp, this.getMTLevelsClaim()),\n      claimPathValue: valueProof.value.toString(),\n      operator: this.query.operator,\n      timestamp: this.currentTimeStamp,\n      // value in this path in merklized json-ld document\n\n      slotIndex: this.query.slotIndex,\n      isRevocationChecked: 1\n    };\n\n    s.challenge = this.challenge?.toString();\n    if (this.isBJJAuthEnabled === 1) {\n      s.authClaim = this.authClaim?.marshalJson();\n      s.userClaimsTreeRoot = this.treeState.claimsRoot?.bigInt().toString();\n      s.userRevTreeRoot = this.treeState.revocationRoot?.bigInt().toString();\n      s.userRootsTreeRoot = this.treeState.rootOfRoots?.bigInt().toString();\n      s.userState = this.treeState.state?.bigInt().toString();\n      s.authClaimIncMtp = prepareSiblingsStr(this.authClaimIncMtp, this.getMTLevel());\n      s.authClaimNonRevMtp = prepareSiblingsStr(this.authClaimNonRevMtp, this.getMTLevel());\n      s.challengeSignatureR8x = this.signature.R8[0].toString();\n      s.challengeSignatureR8y = this.signature.R8[1].toString();\n      s.challengeSignatureS = this.signature.S.toString();\n      s.gistMtp =\n        this.gistProof && prepareSiblingsStr(this.gistProof.proof, this.getMTLevelOnChain());\n      const nodeAuxAuth = getNodeAuxValue(this.authClaimNonRevMtp);\n      s.authClaimNonRevMtpAuxHi = nodeAuxAuth.key.bigInt().toString();\n      s.authClaimNonRevMtpAuxHv = nodeAuxAuth.value.bigInt().toString();\n      s.authClaimNonRevMtpNoAux = nodeAuxAuth.noAux;\n\n      const globalNodeAux = getNodeAuxValue(this.gistProof.proof);\n      s.gistMtpAuxHi = globalNodeAux.key.bigInt().toString();\n      s.gistMtpAuxHv = globalNodeAux.value.bigInt().toString();\n      s.gistMtpNoAux = globalNodeAux.noAux;\n      s.gistRoot = this.gistProof.root.bigInt().toString();\n    } else {\n      this.fillAuthWithZero(s);\n    }\n\n    if (this.skipClaimRevocationCheck) {\n      s.isRevocationChecked = 0;\n    }\n\n    if (this.proofType === ProofType.BJJSignature) {\n      const sigProof = this.claim.signatureProof as BJJSignatureProof;\n      s.proofType = '1';\n\n      s.issuerClaimSignatureR8x = sigProof.signature.R8[0].toString();\n      s.issuerClaimSignatureR8y = sigProof.signature.R8[1].toString();\n      s.issuerClaimSignatureS = sigProof.signature.S.toString();\n      s.issuerAuthClaim = sigProof.issuerAuthClaim?.marshalJson();\n      s.issuerAuthClaimMtp = prepareSiblingsStr(\n        sigProof.issuerAuthIncProof.proof as Proof,\n        this.getMTLevel()\n      );\n      const issuerAuthTreeState = this.claim.nonRevProof.treeState;\n\n      if (!issuerAuthTreeState) {\n        throw new Error(CircuitError.EmptyTreeState);\n      }\n      s.issuerAuthClaimsTreeRoot = sigProof.issuerAuthIncProof.treeState?.claimsRoot\n        .bigInt()\n        .toString();\n      s.issuerAuthRevTreeRoot = sigProof.issuerAuthIncProof.treeState?.revocationRoot\n        .bigInt()\n        .toString();\n      s.issuerAuthRootsTreeRoot = sigProof.issuerAuthIncProof.treeState?.rootOfRoots\n        .bigInt()\n        .toString();\n      s.issuerAuthClaimNonRevMtp = prepareSiblingsStr(\n        sigProof.issuerAuthNonRevProof.proof as Proof,\n        this.getMTLevel()\n      );\n\n      const nodeAuxIssuerAuthNonRev = getNodeAuxValue(sigProof.issuerAuthNonRevProof.proof);\n      s.issuerAuthClaimNonRevMtpAuxHi = nodeAuxIssuerAuthNonRev.key.bigInt().toString();\n      s.issuerAuthClaimNonRevMtpAuxHv = nodeAuxIssuerAuthNonRev.value.bigInt().toString();\n      s.issuerAuthClaimNonRevMtpNoAux = nodeAuxIssuerAuthNonRev.noAux;\n      s.issuerAuthState = sigProof.issuerAuthIncProof.treeState?.state.bigInt().toString();\n\n      this.fillMTPProofsWithZero(s);\n    } else if (this.proofType === ProofType.Iden3SparseMerkleTreeProof) {\n      s.proofType = '2';\n\n      const incProofTreeState = this.claim.incProof?.treeState;\n\n      if (!incProofTreeState) {\n        throw new Error(CircuitError.EmptyTreeState);\n      }\n\n      s.issuerClaimMtp = prepareSiblingsStr(this.claim.incProof?.proof as Proof, this.getMTLevel());\n      s.issuerClaimClaimsTreeRoot = incProofTreeState.claimsRoot.bigInt().toString();\n      s.issuerClaimRevTreeRoot = incProofTreeState.revocationRoot.bigInt().toString();\n      s.issuerClaimRootsTreeRoot = incProofTreeState.rootOfRoots.bigInt().toString();\n      s.issuerClaimIdenState = incProofTreeState.state.bigInt().toString();\n\n      this.fillSigProofWithZero(s);\n    }\n\n    const nodeAuxNonRev = getNodeAuxValue(this.claim.nonRevProof.proof);\n    s.issuerClaimNonRevMtpAuxHi = nodeAuxNonRev.key.bigInt().toString();\n    s.issuerClaimNonRevMtpAuxHv = nodeAuxNonRev.value.bigInt().toString();\n    s.issuerClaimNonRevMtpNoAux = nodeAuxNonRev.noAux;\n\n    const nodAuxJSONLD = getNodeAuxValue(valueProof.mtp);\n    s.claimPathMtpNoAux = nodAuxJSONLD.noAux;\n    s.claimPathMtpAuxHi = nodAuxJSONLD.key.bigInt().toString();\n    s.claimPathMtpAuxHv = nodAuxJSONLD.value.bigInt().toString();\n\n    s.claimPathKey = valueProof.path.toString();\n\n    s.valueArraySize = this.query.values.length;\n    const values = prepareCircuitArrayValues(this.query.values, this.getValueArrSize());\n    s.value = bigIntArrayToStringArray(values);\n\n    s.linkNonce = this.linkNonce.toString();\n    s.verifierID = this.verifierID?.bigInt().toString() ?? '0';\n    s.nullifierSessionID = this.nullifierSessionID.toString();\n\n    s.isBJJAuthEnabled = this.isBJJAuthEnabled.toString();\n\n    return byteEncoder.encode(JSON.stringify(s));\n  }\n}\n\n/**\n * @beta\n * AtomicQueryV3OnChainCircuitInputs type represents credentialAtomicQueryV3OnChain.circom private inputs required by prover\n */\ninterface AtomicQueryV3OnChainCircuitInputs {\n  requestID: string;\n  // user data\n  userGenesisID: string;\n  profileNonce: string;\n  claimSubjectProfileNonce: string;\n\n  issuerID: string;\n  // Claim\n  issuerClaim: string[];\n  issuerClaimNonRevClaimsTreeRoot: string;\n  issuerClaimNonRevRevTreeRoot: string;\n  issuerClaimNonRevRootsTreeRoot: string;\n  issuerClaimNonRevState: string;\n  issuerClaimNonRevMtp: string[];\n  issuerClaimNonRevMtpAuxHi: string;\n  issuerClaimNonRevMtpAuxHv: string;\n  issuerClaimNonRevMtpNoAux: string;\n  claimSchema: string;\n  issuerClaimSignatureR8x: string;\n  issuerClaimSignatureR8y: string;\n  issuerClaimSignatureS: string;\n  issuerAuthClaim: string[];\n  issuerAuthClaimMtp: string[];\n  issuerAuthClaimNonRevMtp: string[];\n  issuerAuthClaimNonRevMtpAuxHi: string;\n  issuerAuthClaimNonRevMtpAuxHv: string;\n  issuerAuthClaimNonRevMtpNoAux: string;\n  issuerAuthClaimsTreeRoot: string;\n  issuerAuthRevTreeRoot: string;\n  issuerAuthRootsTreeRoot: string;\n  issuerAuthState: string;\n\n  isRevocationChecked: number;\n  // Query\n  // JSON path\n  claimPathMtp: string[];\n  claimPathMtpNoAux: string; // 1 if aux node is empty, 0 if non-empty or for inclusion proofs\n  claimPathMtpAuxHi: string; // 0 for inclusion proof\n  claimPathMtpAuxHv: string; // 0 for inclusion proof\n  claimPathKey: string; // hash of path in merklized json-ld document\n  claimPathValue: string; // value in this path in merklized json-ld document\n\n  operator: number;\n  slotIndex: number;\n  timestamp: number;\n  value: string[];\n  valueArraySize: number;\n\n  issuerClaimMtp: string[];\n  issuerClaimClaimsTreeRoot: string;\n  issuerClaimRevTreeRoot: string;\n  issuerClaimRootsTreeRoot: string;\n  issuerClaimIdenState: string;\n\n  proofType: string;\n\n  authClaim?: string[];\n  authClaimIncMtp?: string[];\n  authClaimNonRevMtp: string[];\n  authClaimNonRevMtpAuxHi?: string;\n  authClaimNonRevMtpAuxHv?: string;\n  authClaimNonRevMtpNoAux: string;\n  challenge: string;\n  challengeSignatureR8x: string;\n  challengeSignatureR8y: string;\n  challengeSignatureS: string;\n  userClaimsTreeRoot?: string;\n  userRevTreeRoot?: string;\n  userRootsTreeRoot?: string;\n  userState?: string;\n  gistRoot?: string;\n  gistMtp: string[];\n  gistMtpAuxHi?: string;\n  gistMtpAuxHv?: string;\n  gistMtpNoAux: string;\n\n  // Private random nonce, used to generate LinkID\n  linkNonce: string;\n  verifierID: string;\n  nullifierSessionID: string;\n  isBJJAuthEnabled: string;\n}\n\n/**\n * @beta\n * AtomicQueryV3OnChainPubSignals public inputs\n */\nexport class AtomicQueryV3OnChainPubSignals extends BaseConfig implements IStateInfoPubSignals {\n  requestID!: bigint;\n  userID!: Id;\n  issuerID!: Id;\n  issuerState!: Hash;\n  issuerClaimNonRevState!: Hash;\n  timestamp!: number;\n  circuitQueryHash!: bigint;\n  challenge!: bigint;\n  gistRoot!: Hash;\n  proofType!: number;\n  linkID!: bigint;\n  nullifier!: bigint;\n  operatorOutput!: bigint;\n  isBJJAuthEnabled!: number;\n\n  // PubSignalsUnmarshal unmarshal credentialAtomicQueryV3.circom public signals\n  pubSignalsUnmarshal(data: Uint8Array): AtomicQueryV3OnChainPubSignals {\n    // expected order:\n    // userID\n    // circuitQueryHash\n    // issuerState\n    // linkID\n    // nullifier\n    // operatorOutput\n    // proofType\n    // requestID\n    // challenge\n    // gistRoot\n    // issuerID\n    // issuerClaimNonRevState\n    // timestamp\n    // isBJJAuthEnabled\n\n    const sVals: string[] = JSON.parse(byteDecoder.decode(data));\n\n    let fieldIdx = 0;\n\n    //  - userID\n    this.userID = Id.fromBigInt(BigInt(sVals[fieldIdx]));\n    fieldIdx++;\n\n    // - circuitQueryHash\n    this.circuitQueryHash = BigInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - issuerState\n    this.issuerState = Hash.fromString(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - linkID\n    this.linkID = BigInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - nullifier\n    this.nullifier = BigInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - operatorOutput\n    this.operatorOutput = BigInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - proofType\n    this.proofType = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - requestID\n    this.requestID = BigInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - challenge\n    this.challenge = BigInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - gistRoot\n    this.gistRoot = Hash.fromString(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - issuerID\n    this.issuerID = Id.fromBigInt(BigInt(sVals[fieldIdx]));\n    fieldIdx++;\n\n    // - issuerClaimNonRevState\n    this.issuerClaimNonRevState = Hash.fromString(sVals[fieldIdx]);\n    fieldIdx++;\n\n    //  - timestamp\n    this.timestamp = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - isBJJAuthEnabled\n    this.isBJJAuthEnabled = parseInt(sVals[fieldIdx]);\n\n    return this;\n  }\n\n  /** {@inheritDoc IStateInfoPubSignals.getStatesInfo} */\n  getStatesInfo(): StatesInfo {\n    return {\n      states: [\n        { id: this.issuerID, state: this.issuerState },\n        { id: this.issuerID, state: this.issuerClaimNonRevState }\n      ],\n      gists: [{ id: this.userID, root: this.gistRoot }]\n    };\n  }\n}\n","import { Id, Claim } from '@iden3/js-iden3-core';\nimport { Signature } from '@iden3/js-crypto';\nimport { Query, ValueProof, CircuitError, ClaimWithSigProof, TreeState, GISTProof } from './models';\nimport { Hash, Proof } from '@iden3/js-merkletree';\nimport {\n  BaseConfig,\n  bigIntArrayToStringArray,\n  existenceToInt,\n  getNodeAuxValue,\n  IStateInfoPubSignals,\n  prepareCircuitArrayValues,\n  prepareSiblingsStr,\n  StatesInfo\n} from './common';\nimport { byteDecoder, byteEncoder } from '../utils';\n\n/**\n * AtomicQuerySigV2OnChainInputs ZK private inputs for credentialAtomicQuerySig.circom\n *\n * @public\n * @class AtomicQuerySigV2OnChainInputs\n * @extends {BaseConfig}\n */\nexport class AtomicQuerySigV2OnChainInputs extends BaseConfig {\n  requestID!: bigint;\n  // auth\n  id!: Id;\n  profileNonce!: bigint;\n  claimSubjectProfileNonce!: bigint;\n\n  // claim issued for user\n  claim!: ClaimWithSigProof;\n  skipClaimRevocationCheck!: boolean;\n\n  authClaim!: Claim;\n\n  authClaimIncMtp!: Proof;\n  authClaimNonRevMtp!: Proof;\n  treeState!: TreeState;\n\n  gistProof!: GISTProof;\n\n  signature!: Signature;\n  challenge!: bigint;\n\n  // query\n  query!: Query;\n\n  currentTimeStamp!: number;\n\n  /**\n   *  Validate inputs\n   *\n   *\n   */\n  validate(): void {\n    if (!this.requestID) {\n      throw new Error(CircuitError.EmptyRequestID);\n    }\n    if (!this.claim.nonRevProof?.proof) {\n      throw new Error(CircuitError.EmptyClaimNonRevProof);\n    }\n\n    if (!this.claim.signatureProof?.issuerAuthIncProof.proof) {\n      throw new Error(CircuitError.EmptyIssuerAuthClaimProof);\n    }\n\n    if (!this.claim.signatureProof.issuerAuthNonRevProof.proof) {\n      throw new Error(CircuitError.EmptyIssuerAuthClaimNonRevProof);\n    }\n\n    if (!this.claim.signatureProof.signature) {\n      throw new Error(CircuitError.EmptyClaimSignature);\n    }\n\n    if (!this.query?.values) {\n      throw new Error(CircuitError.EmptyQueryValue);\n    }\n\n    if (!this.authClaimIncMtp) {\n      throw new Error(CircuitError.EmptyAuthClaimProof);\n    }\n\n    if (!this.authClaimNonRevMtp) {\n      throw new Error(CircuitError.EmptyAuthClaimNonRevProof);\n    }\n\n    if (!this.gistProof.proof) {\n      throw new Error(CircuitError.EmptyGISTProof);\n    }\n\n    if (!this.signature) {\n      throw new Error(CircuitError.EmptyChallengeSignature);\n    }\n\n    if (this.challenge === null || this.challenge === undefined) {\n      throw new Error(CircuitError.EmptyChallenge);\n    }\n  }\n\n  /**\n   * marshal inputs\n   *\n   * @returns Uint8Array\n   */\n  inputsMarshal(): Uint8Array {\n    this.validate();\n\n    if (this.query?.valueProof) {\n      this.query.validate();\n      this.query.valueProof.validate();\n    }\n\n    const valueProof = this.query?.valueProof ?? new ValueProof();\n\n    const treeState = this.skipClaimRevocationCheck\n      ? this.claim.signatureProof?.issuerAuthNonRevProof.treeState\n      : this.claim.nonRevProof?.treeState;\n\n    const s: Partial<AtomicQuerySigV2OnChainCircuitInputs> = {\n      requestID: this.requestID.toString(),\n      userGenesisID: this.id.bigInt().toString(),\n      profileNonce: this.profileNonce.toString(),\n      claimSubjectProfileNonce: this.claimSubjectProfileNonce?.toString(),\n      issuerID: this.claim.issuerID?.bigInt().toString(),\n      issuerClaim: this.claim.claim?.marshalJson(),\n      issuerClaimNonRevClaimsTreeRoot: treeState?.claimsRoot?.bigInt().toString(),\n      issuerClaimNonRevRevTreeRoot: treeState?.revocationRoot?.bigInt().toString(),\n      issuerClaimNonRevRootsTreeRoot: treeState?.rootOfRoots?.bigInt().toString(),\n      issuerClaimNonRevState: treeState?.state?.bigInt().toString(),\n      issuerClaimNonRevMtp:\n        this.claim.nonRevProof?.proof &&\n        prepareSiblingsStr(this.claim.nonRevProof.proof, this.getMTLevel()),\n\n      issuerClaimSignatureR8x:\n        this.claim.signatureProof && this.claim.signatureProof.signature.R8[0].toString(),\n      issuerClaimSignatureR8y: this.claim.signatureProof?.signature.R8[1].toString(),\n      issuerClaimSignatureS: this.claim.signatureProof?.signature.S.toString(),\n      issuerAuthClaim: this.claim.signatureProof?.issuerAuthClaim?.marshalJson(),\n      issuerAuthClaimMtp:\n        this.claim.signatureProof?.issuerAuthIncProof?.proof &&\n        prepareSiblingsStr(this.claim.signatureProof.issuerAuthIncProof.proof, this.getMTLevel()),\n      issuerAuthClaimsTreeRoot: this.claim.signatureProof?.issuerAuthIncProof?.treeState?.claimsRoot\n        ?.bigInt()\n        .toString(),\n      issuerAuthRevTreeRoot:\n        this.claim.signatureProof?.issuerAuthIncProof?.treeState?.revocationRoot\n          ?.bigInt()\n          .toString(),\n      issuerAuthRootsTreeRoot: this.claim.signatureProof?.issuerAuthIncProof?.treeState?.rootOfRoots\n        ?.bigInt()\n        .toString(),\n\n      issuerAuthClaimNonRevMtp:\n        this.claim.signatureProof?.issuerAuthNonRevProof?.proof &&\n        prepareSiblingsStr(\n          this.claim.signatureProof.issuerAuthNonRevProof.proof,\n          this.getMTLevel()\n        ),\n      claimSchema: this.claim.claim?.getSchemaHash().bigInt().toString(),\n      claimPathMtp: prepareSiblingsStr(valueProof.mtp, this.getMTLevelsClaim()),\n      claimPathValue: valueProof.value.toString(),\n      operator: this.query.operator,\n      timestamp: this.currentTimeStamp,\n      // value in this path in merklized json-ld document\n      slotIndex: this.query?.slotIndex,\n      isRevocationChecked: 1,\n      authClaim: this.authClaim.marshalJson(),\n      authClaimIncMtp:\n        this.authClaimIncMtp && prepareSiblingsStr(this.authClaimIncMtp, this.getMTLevel()),\n      authClaimNonRevMtp:\n        this.authClaimNonRevMtp && prepareSiblingsStr(this.authClaimNonRevMtp, this.getMTLevel()),\n      challenge: this.challenge?.toString(),\n      challengeSignatureR8x: this.signature.R8[0].toString(),\n      challengeSignatureR8y: this.signature.R8[1].toString(),\n      challengeSignatureS: this.signature.S.toString(),\n      userClaimsTreeRoot: this.treeState.claimsRoot?.string(),\n      userRevTreeRoot: this.treeState.revocationRoot?.string(),\n      userRootsTreeRoot: this.treeState.rootOfRoots?.string(),\n      userState: this.treeState.state?.string(),\n      gistRoot: this.gistProof.root.string(),\n      gistMtp: this.gistProof && prepareSiblingsStr(this.gistProof.proof, this.getMTLevelOnChain())\n    };\n\n    if (this.skipClaimRevocationCheck) {\n      s.isRevocationChecked = 0;\n    }\n    const nodeAuxNonRev = getNodeAuxValue(this.claim.nonRevProof?.proof);\n    s.issuerClaimNonRevMtpAuxHi = nodeAuxNonRev?.key.bigInt().toString();\n    s.issuerClaimNonRevMtpAuxHv = nodeAuxNonRev?.value.bigInt().toString();\n    s.issuerClaimNonRevMtpNoAux = nodeAuxNonRev?.noAux;\n\n    const nodeAuxIssuerAuthNonRev = getNodeAuxValue(\n      this.claim.signatureProof?.issuerAuthNonRevProof.proof\n    );\n    s.issuerAuthClaimNonRevMtpAuxHi = nodeAuxIssuerAuthNonRev?.key.bigInt().toString();\n    s.issuerAuthClaimNonRevMtpAuxHv = nodeAuxIssuerAuthNonRev?.value.bigInt().toString();\n    s.issuerAuthClaimNonRevMtpNoAux = nodeAuxIssuerAuthNonRev?.noAux;\n\n    s.claimPathNotExists = existenceToInt(valueProof.mtp.existence);\n    const nodAuxJSONLD = getNodeAuxValue(valueProof.mtp);\n    s.claimPathMtpNoAux = nodAuxJSONLD.noAux;\n    s.claimPathMtpAuxHi = nodAuxJSONLD.key.bigInt().toString();\n    s.claimPathMtpAuxHv = nodAuxJSONLD.value.bigInt().toString();\n\n    s.claimPathKey = valueProof.path.toString();\n    const values = prepareCircuitArrayValues(this.query.values, this.getValueArrSize());\n    s.value = bigIntArrayToStringArray(values);\n\n    const nodeAuxAuth = getNodeAuxValue(this.authClaimNonRevMtp);\n    s.authClaimNonRevMtpAuxHi = nodeAuxAuth.key.string();\n    s.authClaimNonRevMtpAuxHv = nodeAuxAuth.value.string();\n    s.authClaimNonRevMtpNoAux = nodeAuxAuth.noAux;\n\n    const globalNodeAux = getNodeAuxValue(this.gistProof.proof);\n    s.gistMtpAuxHi = globalNodeAux.key.string();\n    s.gistMtpAuxHv = globalNodeAux.value.string();\n    s.gistMtpNoAux = globalNodeAux.noAux;\n\n    return byteEncoder.encode(JSON.stringify(s));\n  }\n}\n\n/**\n * AtomicQuerySigV2OnChainCircuitInputs type represents credentialAtomicQuerySig.circom private inputs required by prover\n *\n * @public\n * @class AtomicQuerySigV2OnChainCircuitInputs\n */\nexport class AtomicQuerySigV2OnChainCircuitInputs {\n  requestID!: string;\n\n  // user data\n  userGenesisID!: string;\n  profileNonce!: string;\n  claimSubjectProfileNonce!: string;\n\n  issuerID!: string;\n  // Claim\n  issuerClaim!: string[];\n  issuerClaimNonRevClaimsTreeRoot!: string;\n  issuerClaimNonRevRevTreeRoot!: string;\n  issuerClaimNonRevRootsTreeRoot!: string;\n  issuerClaimNonRevState!: string;\n  issuerClaimNonRevMtp!: string[];\n  issuerClaimNonRevMtpAuxHi!: string;\n  issuerClaimNonRevMtpAuxHv!: string;\n  issuerClaimNonRevMtpNoAux!: string;\n  claimSchema!: string;\n  issuerClaimSignatureR8x!: string;\n  issuerClaimSignatureR8y!: string;\n  issuerClaimSignatureS!: string;\n  issuerAuthClaim!: string[];\n  issuerAuthClaimMtp!: string[];\n  issuerAuthClaimNonRevMtp!: string[];\n  issuerAuthClaimNonRevMtpAuxHi!: string;\n  issuerAuthClaimNonRevMtpAuxHv!: string;\n  issuerAuthClaimNonRevMtpNoAux!: string;\n  issuerAuthClaimsTreeRoot!: string;\n  issuerAuthRevTreeRoot!: string;\n  issuerAuthRootsTreeRoot!: string;\n\n  isRevocationChecked!: number;\n  // Query\n  // JSON path\n  claimPathNotExists!: number; // 0 for inclusion, 1 for non-inclusion\n  claimPathMtp!: string[];\n  claimPathMtpNoAux!: string; // 1 if aux node is empty, 0 if non-empty or for inclusion proofs\n  claimPathMtpAuxHi!: string; // 0 for inclusion proof\n  claimPathMtpAuxHv!: string; // 0 for inclusion proof\n  claimPathKey!: string; // hash of path in merklized json-ld document\n  claimPathValue!: string; // value in this path in merklized json-ld document\n\n  operator!: number;\n  slotIndex!: number;\n  timestamp!: number;\n  value!: string[];\n\n  // AuthClaim proof of inclusion\n  authClaim!: string[];\n  authClaimIncMtp!: string[];\n\n  // AuthClaim non revocation proof\n  authClaimNonRevMtp!: string[];\n  authClaimNonRevMtpAuxHi!: string;\n  authClaimNonRevMtpAuxHv!: string;\n  authClaimNonRevMtpNoAux!: string;\n\n  challenge!: string;\n  challengeSignatureR8x!: string;\n  challengeSignatureR8y!: string;\n  challengeSignatureS!: string;\n\n  // User State\n  userClaimsTreeRoot!: string;\n  userRevTreeRoot!: string;\n  userRootsTreeRoot!: string;\n  userState!: string;\n\n  // Global on-cain state\n  gistRoot!: string;\n  gistMtp!: string[];\n  gistMtpAuxHi!: string;\n  gistMtpAuxHv!: string;\n  gistMtpNoAux!: string;\n}\n\n/**\n *\n * public signals\n * @public\n * @class AtomicQuerySigV2OnChainPubSignals\n * @extends {BaseConfig}\n */\nexport class AtomicQuerySigV2OnChainPubSignals extends BaseConfig implements IStateInfoPubSignals {\n  requestID!: bigint;\n  userID!: Id;\n  issuerID!: Id;\n  issuerAuthState!: Hash;\n  issuerClaimNonRevState!: Hash;\n  timestamp!: number;\n  merklized!: number;\n  isRevocationChecked!: number; // 0 revocation not check, // 1 for check revocation\n  circuitQueryHash!: bigint;\n  challenge!: bigint;\n  gistRoot!: Hash;\n\n  //\n  /**\n   *\n   * // PubSignalsUnmarshal unmarshal credentialAtomicQuerySig.circom public signals\n   * @param {Uint8Array} data\n   * @returns AtomicQuerySigV2PubSignals\n   */\n  pubSignalsUnmarshal(data: Uint8Array): AtomicQuerySigV2OnChainPubSignals {\n    // expected order:\n    // merklized\n    // userID\n    // circuitQueryHash\n    // issuerAuthState\n    // requestID\n    // challenge\n    // gistRoot\n    // issuerID\n    // isRevocationChecked\n    // issuerClaimNonRevState\n    // timestamp\n    // claimPathNotExists\n    // claimPathKey\n\n    const sVals: string[] = JSON.parse(byteDecoder.decode(data));\n    let fieldIdx = 0;\n\n    // -- merklized\n    this.merklized = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    //  - userID\n    this.userID = Id.fromBigInt(BigInt(sVals[fieldIdx]));\n    fieldIdx++;\n\n    //  - circuitQueryHash\n    this.circuitQueryHash = BigInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - issuerAuthState\n    this.issuerAuthState = Hash.fromString(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - requestID\n    this.requestID = BigInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - challenge\n    this.challenge = BigInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - gistRoot\n    this.gistRoot = Hash.fromString(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - issuerID\n    this.issuerID = Id.fromBigInt(BigInt(sVals[fieldIdx]));\n    fieldIdx++;\n\n    // - isRevocationChecked\n    this.isRevocationChecked = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - issuerClaimNonRevState\n    this.issuerClaimNonRevState = Hash.fromString(sVals[fieldIdx]);\n    fieldIdx++;\n\n    //  - timestamp\n    this.timestamp = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    return this;\n  }\n\n  /** {@inheritDoc IStateInfoPubSignals.getStatesInfo} */\n  getStatesInfo(): StatesInfo {\n    return {\n      states: [\n        { id: this.issuerID, state: this.issuerAuthState },\n        { id: this.issuerID, state: this.issuerClaimNonRevState }\n      ],\n      gists: [{ id: this.userID, root: this.gistRoot }]\n    };\n  }\n}\n","import { Hash, Proof } from '@iden3/js-merkletree';\nimport { Claim, Id } from '@iden3/js-iden3-core';\nimport { CircuitError, GISTProof, TreeState } from './models';\nimport {\n  BaseConfig,\n  getNodeAuxValue,\n  IStateInfoPubSignals,\n  prepareSiblingsStr,\n  StatesInfo\n} from './common';\nimport { Signature } from '@iden3/js-crypto';\nimport { byteDecoder, byteEncoder } from '../utils';\n\n/**\n * Auth v2 circuit representation\n * Inputs and public signals declaration, marshalling and parsing\n *\n * @public\n * @class AuthV2Inputs\n * @extends {BaseConfig}\n */\nexport class AuthV2Inputs extends BaseConfig {\n  genesisID!: Id;\n  profileNonce!: bigint;\n  authClaim!: Claim;\n  authClaimIncMtp!: Proof;\n  authClaimNonRevMtp!: Proof;\n  treeState!: TreeState;\n  gistProof!: GISTProof;\n  signature!: Signature;\n  challenge!: bigint;\n\n  validate(): void {\n    if (!this.genesisID) {\n      throw new Error(CircuitError.EmptyId);\n    }\n\n    if (!this.authClaimIncMtp) {\n      throw new Error(CircuitError.EmptyAuthClaimProof);\n    }\n\n    if (!this.authClaimNonRevMtp) {\n      throw new Error(CircuitError.EmptyAuthClaimNonRevProof);\n    }\n\n    if (!this.gistProof.proof) {\n      throw new Error(CircuitError.EmptyGISTProof);\n    }\n\n    if (!this.signature) {\n      throw new Error(CircuitError.EmptyChallengeSignature);\n    }\n\n    if (!this.challenge) {\n      throw new Error(CircuitError.EmptyChallenge);\n    }\n  }\n\n  // InputsMarshal returns Circom private inputs for auth.circom\n  inputsMarshal(): Uint8Array {\n    this.validate();\n\n    const s: Partial<AuthV2CircuitInputs> = {\n      genesisID: this.genesisID?.bigInt().toString(),\n      profileNonce: this.profileNonce?.toString(),\n      authClaim: this.authClaim?.marshalJson(),\n      authClaimIncMtp: prepareSiblingsStr(this.authClaimIncMtp, this.getMTLevel()),\n      authClaimNonRevMtp: prepareSiblingsStr(this.authClaimNonRevMtp, this.getMTLevel()),\n      challenge: this.challenge?.toString(),\n      challengeSignatureR8x: this.signature.R8[0].toString(),\n      challengeSignatureR8y: this.signature.R8[1].toString(),\n      challengeSignatureS: this.signature.S.toString(),\n      claimsTreeRoot: this.treeState.claimsRoot?.bigInt().toString(),\n      revTreeRoot: this.treeState.revocationRoot?.bigInt().toString(),\n      rootsTreeRoot: this.treeState.rootOfRoots?.bigInt().toString(),\n      state: this.treeState.state?.bigInt().toString(),\n      gistRoot: this.gistProof.root.bigInt().toString(),\n      gistMtp: this.gistProof && prepareSiblingsStr(this.gistProof.proof, this.getMTLevelOnChain())\n    };\n\n    const nodeAuxAuth = getNodeAuxValue(this.authClaimNonRevMtp);\n    s.authClaimNonRevMtpAuxHi = nodeAuxAuth.key.bigInt().toString();\n    s.authClaimNonRevMtpAuxHv = nodeAuxAuth.value.bigInt().toString();\n    s.authClaimNonRevMtpNoAux = nodeAuxAuth.noAux;\n\n    const globalNodeAux = getNodeAuxValue(this.gistProof.proof);\n    s.gistMtpAuxHi = globalNodeAux.key.bigInt().toString();\n    s.gistMtpAuxHv = globalNodeAux.value.bigInt().toString();\n    s.gistMtpNoAux = globalNodeAux.noAux;\n\n    return byteEncoder.encode(JSON.stringify(s));\n  }\n}\n\ninterface AuthV2CircuitInputs {\n  genesisID: string;\n  profileNonce: string;\n  authClaim?: string[];\n  authClaimIncMtp?: string[];\n  authClaimNonRevMtp: string[];\n  authClaimNonRevMtpAuxHi?: string;\n  authClaimNonRevMtpAuxHv?: string;\n  authClaimNonRevMtpNoAux: string;\n  challenge: string;\n  challengeSignatureR8x: string;\n  challengeSignatureR8y: string;\n  challengeSignatureS: string;\n  claimsTreeRoot?: string;\n  revTreeRoot?: string;\n  rootsTreeRoot?: string;\n  state?: string;\n  gistRoot?: string;\n  gistMtp: string[];\n  gistMtpAuxHi?: string;\n  gistMtpAuxHv?: string;\n  gistMtpNoAux: string;\n}\n\n// AuthV2PubSignals auth.circom public signals\n/**\n * public signals\n *\n * @public\n * @class AuthV2PubSignals\n */\nexport class AuthV2PubSignals implements IStateInfoPubSignals {\n  userID!: Id;\n  challenge!: bigint;\n  GISTRoot!: Hash;\n\n  /**\n   * PubSignalsUnmarshal unmarshal auth.circom public inputs to AuthPubSignals\n   *\n   * @param {Uint8Array} data\n   * @returns AuthV2PubSignals\n   */\n  pubSignalsUnmarshal(data: Uint8Array): AuthV2PubSignals {\n    const len = 3;\n    const sVals: string[] = JSON.parse(byteDecoder.decode(data));\n\n    if (sVals.length !== len) {\n      throw new Error(`invalid number of Output values expected ${len} got ${sVals.length}`);\n    }\n\n    this.userID = Id.fromBigInt(BigInt(sVals[0]));\n\n    this.challenge = BigInt(sVals[1]);\n\n    this.GISTRoot = Hash.fromString(sVals[2]);\n    return this;\n  }\n\n  getStatesInfo(): StatesInfo {\n    return {\n      states: [],\n      gists: [{ id: this.userID, root: this.GISTRoot }]\n    };\n  }\n}\n","import { Signature } from '@iden3/js-crypto';\nimport { Id } from '@iden3/js-iden3-core';\nimport { Hash, Proof } from '@iden3/js-merkletree';\nimport { BaseConfig, getNodeAuxValue, prepareSiblingsStr } from './common';\nimport { ClaimWithMTPProof, TreeState, CircuitError } from './models';\nimport { byteDecoder, byteEncoder } from '../utils';\n\n/**\n * StateTransition circuit representation\n * Inputs and public signals declaration, marshalling and parsing\n *\n * @public\n * @class StateTransitionInputs\n * @extends {BaseConfig}\n */\nexport class StateTransitionInputs extends BaseConfig {\n  id!: Id;\n  oldTreeState!: TreeState;\n  newTreeState!: TreeState;\n\n  isOldStateGenesis!: boolean;\n  authClaim!: ClaimWithMTPProof;\n\n  authClaimNewStateIncProof!: Proof;\n\n  signature!: Signature;\n\n  /**\n   * CircuitInputMarshal returns Circom private inputs for stateTransition.circom\n   *\n   * @returns Uint8Array\n   */\n  inputsMarshal(): Uint8Array {\n    if (!this.authClaim?.incProof?.proof) {\n      throw new Error(CircuitError.EmptyAuthClaimProof);\n    }\n\n    if (!this.authClaimNewStateIncProof) {\n      throw new Error(CircuitError.EmptyAuthClaimProofInTheNewState);\n    }\n\n    if (!this.authClaim.nonRevProof?.proof) {\n      throw new Error(CircuitError.EmptyAuthClaimNonRevProof);\n    }\n\n    const s: Partial<StateTransitionInputsInternal> = {\n      authClaim: this.authClaim?.claim?.marshalJson(),\n      authClaimMtp: prepareSiblingsStr(this.authClaim.incProof.proof, this.getMTLevel()),\n      authClaimNonRevMtp: prepareSiblingsStr(this.authClaim.nonRevProof.proof, this.getMTLevel()),\n      newAuthClaimMtp: prepareSiblingsStr(this.authClaimNewStateIncProof, this.getMTLevel()),\n      userID: this.id?.bigInt().toString(),\n      newUserState: this.newTreeState?.state?.bigInt().toString(),\n      claimsTreeRoot: this.oldTreeState?.claimsRoot?.bigInt().toString(),\n      oldUserState: this.oldTreeState?.state?.bigInt().toString(),\n      revTreeRoot: this.oldTreeState?.revocationRoot?.bigInt().toString(),\n      rootsTreeRoot: this.oldTreeState?.rootOfRoots?.bigInt().toString(),\n      signatureR8x: this.signature.R8[0].toString(),\n      signatureR8y: this.signature.R8[1].toString(),\n      signatureS: this.signature.S.toString(),\n      newClaimsTreeRoot: this.newTreeState?.claimsRoot?.bigInt().toString(),\n      newRootsTreeRoot: this.newTreeState?.rootOfRoots?.bigInt().toString(),\n      newRevTreeRoot: this.newTreeState?.revocationRoot?.bigInt().toString()\n    };\n\n    if (this.isOldStateGenesis) {\n      s.isOldStateGenesis = '1';\n    } else {\n      s.isOldStateGenesis = '0';\n    }\n\n    const nodeAuxAuth = getNodeAuxValue(this.authClaim.nonRevProof.proof);\n    s.authClaimNonRevMtpAuxHi = nodeAuxAuth.key.bigInt().toString();\n    s.authClaimNonRevMtpAuxHv = nodeAuxAuth.value.bigInt().toString();\n    s.authClaimNonRevMtpNoAux = nodeAuxAuth.noAux;\n\n    return byteEncoder.encode(JSON.stringify(s));\n  }\n}\n\ninterface StateTransitionInputsInternal {\n  authClaim: string[];\n  authClaimMtp: string[];\n  authClaimNonRevMtp: string[];\n  authClaimNonRevMtpAuxHi?: string;\n  authClaimNonRevMtpAuxHv?: string;\n  authClaimNonRevMtpNoAux: string;\n  userID: string;\n  newUserState?: string;\n  oldUserState?: string;\n  isOldStateGenesis: string;\n  claimsTreeRoot?: string;\n  revTreeRoot?: string;\n  rootsTreeRoot?: string;\n  signatureR8x: string;\n  signatureR8y: string;\n  signatureS: string;\n  newAuthClaimMtp: string[];\n  newClaimsTreeRoot: string;\n  newRevTreeRoot: string;\n  newRootsTreeRoot: string;\n}\n\n/**\n * Public signals of StateTransition circuit\n *\n * @public\n * @class StateTransitionPubSignals\n */\nexport class StateTransitionPubSignals {\n  userId!: Id;\n  oldUserState!: Hash;\n  newUserState!: Hash;\n  isOldStateGenesis!: boolean;\n\n  /**\n   *\n   *\n   * PubSignalsUnmarshal unmarshal stateTransition.circom public signal\n   * @param {Uint8Array} data\n   * @returns StateTransitionPubSignals\n   */\n  pubSignalsUnmarshal(data: Uint8Array): StateTransitionPubSignals {\n    const sVals = JSON.parse(byteDecoder.decode(data));\n\n    const fieldLength = 4;\n\n    if (sVals.length !== fieldLength) {\n      throw new Error(\n        `invalid number of Output values expected ${fieldLength} got ${sVals.length}`\n      );\n    }\n    this.userId = Id.fromBigInt(BigInt(sVals[0]));\n    this.oldUserState = Hash.fromString(sVals[1]);\n    this.newUserState = Hash.fromString(sVals[2]);\n    this.isOldStateGenesis = BigInt(sVals[3]) === BigInt(1);\n\n    return this;\n  }\n}\n","import { Claim } from '@iden3/js-iden3-core';\nimport { Proof } from '@iden3/js-merkletree';\nimport { byteDecoder, byteEncoder } from '../utils';\nimport {\n  BaseConfig,\n  bigIntArrayToStringArray,\n  getNodeAuxValue,\n  prepareCircuitArrayValues,\n  prepareSiblingsStr\n} from './common';\nimport { Query, ValueProof } from './models';\n\n/**\n * LinkedMultiQuery circuit representation\n * Inputs and public signals declaration, marshalling and parsing\n *\n * @beta\n * @class LinkedMultiQueryInputs\n */\nexport class LinkedMultiQueryInputs extends BaseConfig {\n  static queryCount = 10;\n  linkNonce!: bigint;\n  claim!: Claim;\n  query!: Query[];\n\n  // InputsMarshal returns Circom private inputs for linkedMultiQueryInputs.circom\n  inputsMarshal(): Uint8Array {\n    const claimPathMtp: string[][] = [];\n    const claimPathMtpNoAux: string[] = [];\n    const claimPathMtpAuxHi: string[] = [];\n    const claimPathMtpAuxHv: string[] = [];\n    const claimPathKey: string[] = [];\n    const claimPathValue: string[] = [];\n    const slotIndex: number[] = [];\n    const operator: number[] = [];\n    const value: string[][] = [];\n    const valueArraySize: number[] = [];\n\n    for (let i = 0; i < LinkedMultiQueryInputs.queryCount; i++) {\n      if (!this.query[i]) {\n        claimPathMtp.push(new Array(this.getMTLevelsClaim()).fill('0'));\n\n        claimPathMtpNoAux.push('0');\n        claimPathMtpAuxHi.push('0');\n        claimPathMtpAuxHv.push('0');\n\n        claimPathKey.push('0');\n\n        claimPathValue.push('0');\n\n        slotIndex.push(0);\n        operator.push(0);\n\n        const valuesArr = prepareCircuitArrayValues([], this.getValueArrSize());\n        value.push(bigIntArrayToStringArray(valuesArr));\n        valueArraySize.push(0);\n        continue;\n      }\n      let valueProof = this.query[i].valueProof;\n      if (!valueProof) {\n        valueProof = new ValueProof();\n        valueProof.path = 0n;\n        valueProof.value = 0n;\n        valueProof.mtp = new Proof();\n      }\n      claimPathMtp.push(prepareSiblingsStr(valueProof.mtp, this.getMTLevelsClaim()));\n\n      const nodAuxJSONLD = getNodeAuxValue(valueProof.mtp);\n\n      claimPathMtpNoAux.push(nodAuxJSONLD.noAux);\n      claimPathMtpAuxHi.push(nodAuxJSONLD.key.bigInt().toString());\n      claimPathMtpAuxHv.push(nodAuxJSONLD.value.bigInt().toString());\n\n      claimPathKey.push(valueProof.path.toString());\n\n      claimPathValue.push(valueProof.value.toString());\n\n      slotIndex.push(this.query[i].slotIndex);\n      operator.push(this.query[i].operator);\n\n      valueArraySize.push(this.query[i].values.length);\n      const valuesArr = prepareCircuitArrayValues(this.query[i].values, this.getValueArrSize());\n      value.push(bigIntArrayToStringArray(valuesArr));\n    }\n\n    const s: Partial<LinkedMultiQueryCircuitInputs> = {\n      linkNonce: this.linkNonce.toString(),\n      issuerClaim: this.claim.marshalJson(),\n      claimSchema: this.claim.getSchemaHash().bigInt().toString(),\n      claimPathMtp,\n      claimPathMtpNoAux,\n      claimPathMtpAuxHi,\n      claimPathMtpAuxHv,\n      claimPathKey,\n      claimPathValue,\n      slotIndex,\n      operator,\n      value,\n      valueArraySize\n    };\n\n    return byteEncoder.encode(JSON.stringify(s));\n  }\n}\n\n/**\n * @beta\n */\ninterface LinkedMultiQueryCircuitInputs {\n  linkNonce: string;\n  issuerClaim: string[];\n  claimSchema: string;\n  claimPathMtp: string[][];\n  claimPathMtpNoAux: string[];\n  claimPathMtpAuxHi: string[];\n  claimPathMtpAuxHv: string[];\n  claimPathKey: string[];\n  claimPathValue: string[];\n  slotIndex: number[];\n  operator: number[];\n  value: string[][];\n  valueArraySize: number[];\n}\n\n// LinkedMultiQueryPubSignals linkedMultiQuery10.circom public signals\n/**\n * public signals\n *\n * @beta\n * @class LinkedMultiQueryPubSignals\n */\nexport class LinkedMultiQueryPubSignals {\n  linkID!: bigint;\n  merklized!: number;\n  operatorOutput!: bigint[];\n  circuitQueryHash!: bigint[];\n\n  /**\n   * PubSignalsUnmarshal unmarshal linkedMultiQuery10.circom public inputs to LinkedMultiQueryPubSignals\n   *\n   * @beta\n   * @param {Uint8Array} data\n   * @returns LinkedMultiQueryPubSignals\n   */\n  pubSignalsUnmarshal(data: Uint8Array): LinkedMultiQueryPubSignals {\n    const len = 22;\n    const queryLength = LinkedMultiQueryInputs.queryCount;\n    const sVals: string[] = JSON.parse(byteDecoder.decode(data));\n\n    if (sVals.length !== len) {\n      throw new Error(`invalid number of Output values expected ${len} got ${sVals.length}`);\n    }\n\n    let fieldIdx = 0;\n\n    // -- linkID\n    this.linkID = BigInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // -- merklized\n    this.merklized = parseInt(sVals[fieldIdx]);\n    fieldIdx++;\n\n    // - operatorOutput\n    this.operatorOutput = [];\n    for (let i = 0; i < queryLength; i++) {\n      this.operatorOutput.push(BigInt(sVals[fieldIdx]));\n      fieldIdx++;\n    }\n\n    // - circuitQueryHash\n    this.circuitQueryHash = [];\n    for (let i = 0; i < queryLength; i++) {\n      this.circuitQueryHash.push(BigInt(sVals[fieldIdx]));\n      fieldIdx++;\n    }\n\n    return this;\n  }\n}\n","[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDefaultIdType\",\"outputs\":[{\"internalType\":\"bytes2\",\"name\":\"\",\"type\":\"bytes2\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getGISTProof\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"root\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"existence\",\"type\":\"bool\"},{\"internalType\":\"uint256[64]\",\"name\":\"siblings\",\"type\":\"uint256[64]\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"auxExistence\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"auxIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auxValue\",\"type\":\"uint256\"}],\"internalType\":\"structIState.GistProof\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getGISTProofByBlock\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"root\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"existence\",\"type\":\"bool\"},{\"internalType\":\"uint256[64]\",\"name\":\"siblings\",\"type\":\"uint256[64]\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"auxExistence\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"auxIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auxValue\",\"type\":\"uint256\"}],\"internalType\":\"structIState.GistProof\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"root\",\"type\":\"uint256\"}],\"name\":\"getGISTProofByRoot\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"root\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"existence\",\"type\":\"bool\"},{\"internalType\":\"uint256[64]\",\"name\":\"siblings\",\"type\":\"uint256[64]\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"auxExistence\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"auxIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auxValue\",\"type\":\"uint256\"}],\"internalType\":\"structIState.GistProof\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getGISTProofByTime\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"root\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"existence\",\"type\":\"bool\"},{\"internalType\":\"uint256[64]\",\"name\":\"siblings\",\"type\":\"uint256[64]\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"auxExistence\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"auxIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auxValue\",\"type\":\"uint256\"}],\"internalType\":\"structIState.GistProof\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGISTRoot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"getGISTRootHistory\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"root\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"replacedByRoot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAtTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"replacedAtTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAtBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"replacedAtBlock\",\"type\":\"uint256\"}],\"internalType\":\"structIState.GistRootInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGISTRootHistoryLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"root\",\"type\":\"uint256\"}],\"name\":\"getGISTRootInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"root\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"replacedByRoot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAtTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"replacedAtTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAtBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"replacedAtBlock\",\"type\":\"uint256\"}],\"internalType\":\"structIState.GistRootInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getGISTRootInfoByBlock\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"root\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"replacedByRoot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAtTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"replacedAtTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAtBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"replacedAtBlock\",\"type\":\"uint256\"}],\"internalType\":\"structIState.GistRootInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getGISTRootInfoByTime\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"root\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"replacedByRoot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAtTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"replacedAtTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAtBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"replacedAtBlock\",\"type\":\"uint256\"}],\"internalType\":\"structIState.GistRootInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getStateInfoById\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"state\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"replacedByState\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAtTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"replacedAtTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAtBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"replacedAtBlock\",\"type\":\"uint256\"}],\"internalType\":\"structIState.StateInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"state\",\"type\":\"uint256\"}],\"name\":\"getStateInfoByIdAndState\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"state\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"replacedByState\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAtTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"replacedAtTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAtBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"replacedAtBlock\",\"type\":\"uint256\"}],\"internalType\":\"structIState.StateInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"getStateInfoHistoryById\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"state\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"replacedByState\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAtTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"replacedAtTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAtBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"replacedAtBlock\",\"type\":\"uint256\"}],\"internalType\":\"structIState.StateInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getStateInfoHistoryLengthById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVerifier\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"idExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIStateTransitionVerifier\",\"name\":\"verifierContractAddr\",\"type\":\"address\"},{\"internalType\":\"bytes2\",\"name\":\"defaultIdType\",\"type\":\"bytes2\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes2\",\"name\":\"defaultIdType\",\"type\":\"bytes2\"}],\"name\":\"setDefaultIdType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newVerifierAddr\",\"type\":\"address\"}],\"name\":\"setVerifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"state\",\"type\":\"uint256\"}],\"name\":\"stateExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oldState\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newState\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isOldStateGenesis\",\"type\":\"bool\"},{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"}],\"name\":\"transitState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oldState\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newState\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isOldStateGenesis\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"methodId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"methodParams\",\"type\":\"bytes\"}],\"name\":\"transitStateGeneric\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]\n","import { Block, JsonRpcProvider, Signer, TransactionReceipt, TransactionRequest } from 'ethers';\n\n/**\n * Resend transaction options\n * @type ResendTxnOptions\n */\nexport type ResendTxnOptions = {\n  increasedFeesPercentage?: number;\n};\n\n/**\n * Interface for TransactionService\n * @public\n */\nexport interface ITransactionService {\n  /**\n   * Returns transaction receipt and block by transaction hash\n   *\n   * @param {string} transactionHash - transaction hash.\n   * @returns `Promise<{receipt?: TransactionReceipt , block?: Block}>` - returns transaction receipt and block\n   * @public\n   */\n  getTransactionReceiptAndBlock(\n    transactionHash: string\n  ): Promise<{ receipt?: TransactionReceipt; block?: Block }>;\n\n  /**\n   * Send transaction.\n   *\n   * @param {Signer} signer - transaction signer.\n   * @param {TransactionRequest} request - transaction request.\n   * @returns `Promise<txnHash: string, txnReceipt: TransactionReceipt` - returns txn hash and txn receipt.\n   * @public\n   */\n  sendTransactionRequest(\n    signer: Signer,\n    request: TransactionRequest\n  ): Promise<{ txnHash: string; txnReceipt: TransactionReceipt }>;\n\n  /**\n   * Resend transaction with options. Useful when `transaction underpriced` error thrown on transaction.\n   *\n   * @param {Signer} signer - transaction signer.\n   * @param {TransactionRequest} request - transaction request.\n   * @param {ResendTxnOptions} opts - resend transaction options.\n   * @returns `Promise<{ txnHash: string; txnReceipt: TransactionReceipt }>` -returns txn hash and txn receipt.\n   * @public\n   */\n  resendTransaction(\n    signer: Signer,\n    request: TransactionRequest,\n    opts?: ResendTxnOptions\n  ): Promise<{ txnHash: string; txnReceipt: TransactionReceipt }>;\n}\n\n/**\n * Transaction service to provide interaction with blockchain transactions.\n * allows to: get tx receipt by tx id, send and resend transaction with new fees.\n * @class TransactionService\n * @public\n * @implements ITransactionService interface\n */\nexport class TransactionService implements ITransactionService {\n  /**\n   * Creates an instance of TransactionService.\n   * @param {JsonRpcProvider} - RPC provider\n   */\n  constructor(private readonly _provider: JsonRpcProvider) {}\n\n  /** {@inheritDoc ITransactionService.getTransactionReceiptAndBlock} */\n  async getTransactionReceiptAndBlock(\n    txnHash: string\n  ): Promise<{ receipt?: TransactionReceipt; block?: Block }> {\n    const receipt = await this._provider.getTransactionReceipt(txnHash);\n    const block = await receipt?.getBlock();\n    return { receipt: receipt || undefined, block };\n  }\n\n  /** {@inheritDoc ITransactionService.sendTransactionRequest} */\n  async sendTransactionRequest(\n    signer: Signer,\n    request: TransactionRequest\n  ): Promise<{ txnHash: string; txnReceipt: TransactionReceipt }> {\n    const tx = await signer.sendTransaction(request);\n    const txnReceipt = await tx.wait();\n    if (!txnReceipt) {\n      throw new Error(`transaction: ${tx.hash} failed to mined`);\n    }\n    const status: number | null = txnReceipt.status;\n    const txnHash: string = txnReceipt.hash;\n\n    if (!status) {\n      throw new Error(`transaction: ${txnHash} failed to mined`);\n    }\n\n    return { txnHash, txnReceipt };\n  }\n\n  /** {@inheritDoc ITransactionService.resendTransaction} */\n  async resendTransaction(\n    signer: Signer,\n    request: TransactionRequest,\n    opts?: ResendTxnOptions\n  ): Promise<{ txnHash: string; txnReceipt: TransactionReceipt }> {\n    const feeData = await this._provider.getFeeData();\n    let { maxFeePerGas, maxPriorityFeePerGas, gasPrice } = feeData;\n\n    if (opts?.increasedFeesPercentage) {\n      const multiplyVal = BigInt((opts.increasedFeesPercentage + 100) / 100);\n      maxFeePerGas = maxFeePerGas ? maxFeePerGas * multiplyVal : null;\n      maxPriorityFeePerGas = maxPriorityFeePerGas ? maxPriorityFeePerGas * multiplyVal : null;\n      gasPrice = gasPrice ? gasPrice * multiplyVal : null;\n    }\n\n    request.maxFeePerGas = maxFeePerGas;\n    request.maxPriorityFeePerGas = maxPriorityFeePerGas;\n    request.gasPrice = gasPrice;\n\n    return this.sendTransactionRequest(signer, request);\n  }\n}\n","import { ProofData } from '@iden3/js-jwz';\nimport { ethers } from 'ethers';\n\nexport const packZkpProof = (inputs: string[], a: string[], b: string[][], c: string[]): string => {\n  return new ethers.AbiCoder().encode(\n    ['uint256[] inputs', 'uint256[2]', 'uint256[2][2]', 'uint256[2]'],\n    [inputs, a, b, c]\n  );\n};\n\nexport const prepareZkpProof = (proof: ProofData): { a: string[]; b: string[][]; c: string[] } => {\n  return {\n    a: proof.pi_a.slice(0, 2),\n    b: [\n      [proof.pi_b[0][1], proof.pi_b[0][0]],\n      [proof.pi_b[1][1], proof.pi_b[1][0]]\n    ],\n    c: proof.pi_c.slice(0, 2)\n  };\n};\n","import { InMemoryDB, Merkletree, str2Bytes } from '@iden3/js-merkletree';\nimport { IdentityMerkleTreeMetaInformation, MerkleTreeType } from '../entities/mt';\nimport * as uuid from 'uuid';\n\nimport { IMerkleTreeStorage } from '../interfaces/merkletree';\nimport { MERKLE_TREE_TYPES } from '../utils';\n\nexport interface TreeWithMetaInfo {\n  tree: Merkletree;\n  metaInfo: IdentityMerkleTreeMetaInformation;\n}\n\n/**\n *\n *\n * @public\n * @class InMemoryMerkleTreeStorage\n * @implements implements IMerkleTreeStorage interface\n */\nexport class InMemoryMerkleTreeStorage implements IMerkleTreeStorage {\n  /**\n   * key value storage for trees where key is identifier\n   *\n   * @type {{\n   *     [v in string]: TreeWithMetaInfo[];\n   *   }}\n   */\n  _data: {\n    [v in string]: TreeWithMetaInfo[];\n  };\n  /**\n   * tree depth\n   *\n   * @type {number}\n   */\n  mtDepth: number;\n  /**\n   * Creates an instance of InMemoryMerkleTreeStorage.\n   * @param {number} _mtDepth\n   */\n  constructor(_mtDepth: number) {\n    this.mtDepth = _mtDepth;\n    this._data = {};\n  }\n\n  /** create trees in the  memory*/\n  async createIdentityMerkleTrees(\n    identifier: string\n  ): Promise<IdentityMerkleTreeMetaInformation[]> {\n    if (!identifier) {\n      identifier = `${uuid.v4()}`;\n    }\n    if (this._data[identifier]) {\n      throw new Error(\n        `Present merkle tree meta information in the store for current identifier ${identifier}`\n      );\n    }\n    this._data[identifier] = [];\n\n    const treesMeta: IdentityMerkleTreeMetaInformation[] = [];\n    MERKLE_TREE_TYPES.forEach((t) => {\n      const treeId = identifier.concat('+' + t.toString());\n      const tree = new Merkletree(new InMemoryDB(str2Bytes(treeId)), true, this.mtDepth);\n\n      const metaInfo = { treeId, identifier: identifier, type: t };\n      this._data[identifier].push({ tree, metaInfo });\n\n      treesMeta.push(metaInfo);\n    });\n    return treesMeta;\n  }\n\n  /** get trees meta info from the memory */\n  async getIdentityMerkleTreesInfo(\n    identifier: string\n  ): Promise<IdentityMerkleTreeMetaInformation[]> {\n    return this._data[identifier].map((treeWithInfo) => treeWithInfo.metaInfo);\n  }\n  /** get merkle tree by identifier and type from memory */\n  async getMerkleTreeByIdentifierAndType(\n    identifier: string,\n    mtType: MerkleTreeType\n  ): Promise<Merkletree> {\n    const treeWithMeta = this._data[identifier].find(\n      (treeWithInfo) => treeWithInfo.metaInfo.type == mtType\n    );\n    if (!treeWithMeta) {\n      throw new Error(`Merkle tree not found for identifier ${identifier} and type ${mtType}`);\n    }\n\n    return treeWithMeta.tree;\n  }\n  /** adds entry to merkle tree in the memory */\n  async addToMerkleTree(\n    identifier: string,\n    mtType: MerkleTreeType,\n    hindex: bigint,\n    hvalue: bigint\n  ): Promise<void> {\n    for (let index = 0; index < this._data[identifier].length; index++) {\n      if (this._data[identifier][index].metaInfo.type === mtType) {\n        await this._data[identifier][index].tree.add(hindex, hvalue);\n      }\n    }\n  }\n\n  /** bind merkle tree identifier in memory */\n  async bindMerkleTreeToNewIdentifier(oldIdentifier: string, newIdentifier: string): Promise<void> {\n    this._data[newIdentifier] = [...this._data[oldIdentifier]];\n    delete this._data[oldIdentifier];\n\n    this._data[newIdentifier].forEach((treeWithMeta) => {\n      treeWithMeta.metaInfo.identifier = newIdentifier;\n    });\n  }\n}\n","/**\n * Interface to store metadata about merkle tree\n *\n * @public\n * @interface   IdentityMerkleTreeMetaInformation\n */\nexport interface IdentityMerkleTreeMetaInformation {\n  treeId: string;\n  identifier: string;\n  type: MerkleTreeType;\n}\n\n/**\n * Type of MerkleTree\n *\n * @enum {number}\n */\nexport enum MerkleTreeType {\n  // Claims is merkle tree type for claims tree\n  Claims = 0,\n  // Revocations is merkle tree type for revocations tree\n  Revocations = 1,\n  // Roots is merkle tree type for roots tree\n  Roots = 2\n}\n","import { IdentityMerkleTreeMetaInformation, MerkleTreeType } from './entities';\n\nexport const MERKLE_TREE_TYPES: MerkleTreeType[] = [\n  MerkleTreeType.Claims,\n  MerkleTreeType.Revocations,\n  MerkleTreeType.Roots\n];\n\nexport const createMerkleTreeMetaInfo = (\n  identifier: string\n): IdentityMerkleTreeMetaInformation[] => {\n  const treesMeta: IdentityMerkleTreeMetaInformation[] = [];\n  for (let index = 0; index < MERKLE_TREE_TYPES.length; index++) {\n    const mType = MERKLE_TREE_TYPES[index];\n    const treeId = `${identifier}+${mType}`;\n    treesMeta.push({ treeId, identifier, type: mType });\n  }\n  return treesMeta;\n};\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { StorageErrors } from '../errors';\nimport { IDataSource } from '../interfaces/data-source';\n\n/**\n * Generic Memory Data Source\n *\n * @public\n * @class InMemoryDataSource - class\n * @template Type\n */\nexport class InMemoryDataSource<Type> implements IDataSource<Type> {\n  private _data: Type[] = [];\n\n  /** saves in the memory */\n  async save(key: string, value: Type, keyName = 'id'): Promise<void> {\n    const itemIndex = this._data.findIndex((i: any) => i[keyName] === key);\n    if (itemIndex === -1) {\n      this._data.push(value);\n    } else {\n      this._data[itemIndex] = value;\n    }\n  }\n\n  /** gets value from from the memory */\n  async get(key: string, keyName = 'id'): Promise<Type | undefined> {\n    return this._data.find((t: any) => t[keyName] === key);\n  }\n\n  /** loads from value from the memory */\n  async load(): Promise<Type[]> {\n    return this._data;\n  }\n\n  /** deletes from value from the memory */\n  async delete(key: string, keyName = 'id'): Promise<void> {\n    const newData = this._data.filter((i: any) => i[keyName] !== key);\n\n    if (newData.length === this._data.length) {\n      throw new Error(`${StorageErrors.ItemNotFound} to delete: ${key}`);\n    }\n\n    this._data = newData;\n  }\n}\n","import QuickLRU from 'quick-lru';\n\nexport interface ICache<T> {\n  get(key: string): Promise<T | undefined>;\n  set(key: string, value: T, ttl?: number): Promise<void>;\n  delete(key: string): Promise<void>;\n  clear(): Promise<void>;\n}\n\nexport function createInMemoryCache<T>(params: { ttl?: number; maxSize: number }): ICache<T> {\n  const cache = new QuickLRU<string, T>({ maxSize: params.maxSize, maxAge: params.ttl });\n\n  return {\n    get: async (key: string): Promise<T | undefined> => {\n      return cache.get(key);\n    },\n\n    set: async (key: string, value: T, ttl?: number) => {\n      cache.set(key, value, { maxAge: ttl ?? params.ttl });\n    },\n\n    clear: async () => {\n      cache.clear();\n    },\n\n    delete: async (key: string) => {\n      cache.delete(key);\n    }\n  };\n}\n","import { MediaType } from '../constants';\nimport { BasicMessage, EnvelopeStub, HeaderStub, ProtocolMessage } from '../types';\n\n/**\n * creates empty basic message\n *\n * @returns BasicMessage\n */\nexport const basicMessageFactory = (): BasicMessage => {\n  return {\n    id: '',\n    typ: '' as MediaType,\n    thid: '',\n    type: '' as ProtocolMessage,\n    body: {},\n    from: '',\n    to: ''\n  };\n};\n\n/**\n * create empty envelope stub\n *\n * @returns EnvelopeStub\n */\nexport const envelopeStubFactory = (): EnvelopeStub => {\n  return {\n    protected: ''\n  };\n};\n\n/**\n * create empty header stub\n *\n * @returns {HeaderStub}\n */\nexport const headerStubFactory = (): HeaderStub => {\n  return {\n    typ: '' as MediaType\n  };\n};\n","// Envelope Errors\nexport const ErrNotProtocolMessage = 'the envelope is not a protocol message';\nexport const ErrNotEnvelopeStub = \"the envelope doesn't contain field protected\";\nexport const ErrNotHeaderStub = \"the envelope doesn't contain field typ\";\n\n// Token Errors\nexport const ErrUnknownCircuitID = \"unknown circuit ID. can't verify msg sender\";\nexport const ErrSenderNotUsedTokenCreation = 'sender of message is not used for jwz token creation';\n\n// ZKP-Packer Errors\nexport const ErrPackedWithUnsupportedCircuit = 'message was packed with unsupported circuit';\nexport const ErrProofIsInvalid = 'message proof is invalid';\nexport const ErrStateVerificationFailed = 'message state verification failed';\nexport const ErrNoProvingMethodAlg = 'unknown proving method algorithm';\n","import { BasicMessage, EnvelopeStub, HeaderStub } from '../types';\nimport { basicMessageFactory, envelopeStubFactory, headerStubFactory } from './message';\nimport { ErrNotEnvelopeStub, ErrNotHeaderStub, ErrNotProtocolMessage } from '../errors';\nimport { Token } from '@iden3/js-jwz';\nimport { byteDecoder, byteEncoder } from '../../utils';\n\nconst objectIs = (\n  obj: { [key in string]: any }, //eslint-disable-line @typescript-eslint/no-explicit-any\n  targetObj: { [key in string]: any } //eslint-disable-line @typescript-eslint/no-explicit-any\n): boolean => {\n  Object.keys(targetObj).forEach((prop) => {\n    if (!obj[prop]) {\n      return false;\n    }\n    if (typeof targetObj[prop as keyof typeof targetObj] !== typeof obj[prop as keyof typeof obj]) {\n      return false;\n    }\n  });\n  return true;\n};\n\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isProtocolMessage = (message: { [key in string]: any }): boolean => {\n  const basicMessage = basicMessageFactory();\n  Object.keys(basicMessage).forEach((prop) => {\n    if (!message[prop]) {\n      return false;\n    }\n    if (prop !== 'body') {\n      const res =\n        typeof basicMessage[prop as keyof typeof basicMessage] ===\n        typeof (message[prop as keyof typeof message] as any); //eslint-disable-line @typescript-eslint/no-explicit-any\n      if (!res) {\n        return false;\n      }\n    }\n  });\n\n  return true;\n};\n\n/**\n *\n * @param {Uint8Array} e\n * @returns Promise<BasicMessage>\n */\nexport const envelopeToProtocolMessage = async (e: Uint8Array): Promise<BasicMessage> => {\n  const t = await Token.parse(byteDecoder.decode(e));\n  const pBytes = byteEncoder.encode(t.getPayload());\n  return bytesToProtocolMessage(pBytes);\n};\n\n/**\n * helper function to convert serialized JSON bytes to protocol message\n *\n * @param {Uint8Array} bytes\n * @returns  {BasicMessage}\n */\nexport const bytesToProtocolMessage = (bytes: Uint8Array): BasicMessage => {\n  const str = byteDecoder.decode(bytes);\n  const message = JSON.parse(str);\n  if (!isProtocolMessage(message)) {\n    throw new Error(ErrNotProtocolMessage);\n  }\n  return message as BasicMessage;\n};\n\n/**\n * helper function to convert serialized JSON bytes to envelop stub\n * so we can work with protected field of jwt token\n *\n *\n * @param {Uint8Array} envelope\n * @returns {EnvelopeStub}\n */\nexport const bytesToEnvelopeStub = (envelope: Uint8Array): EnvelopeStub => {\n  const tmpObj = envelopeStubFactory();\n  const str = byteDecoder.decode(envelope);\n  const message = JSON.parse(str);\n  if (!objectIs(message, tmpObj)) {\n    throw new Error(ErrNotEnvelopeStub);\n  }\n  return message as EnvelopeStub;\n};\n\n/**\n * helper function to convert serialized JSON bytes to header stub\n * so we can work with know the media type of the message\n *\n * @param {Uint8Array} envelope\n * @returns {HeaderStub}\n */\nexport const bytesToHeaderStub = (envelope: Uint8Array): HeaderStub => {\n  const tmpObj = headerStubFactory();\n  const str = byteDecoder.decode(envelope);\n  const message = JSON.parse(str);\n  if (!objectIs(message, tmpObj)) {\n    throw new Error(ErrNotHeaderStub);\n  }\n  return message as HeaderStub;\n};\n","import { BasicMessage, IPackageManager, IPacker, PackerParams } from './types';\nimport { bytesToHeaderStub } from './utils/envelope';\nimport { base64 } from 'rfc4648';\nimport { MediaType } from './constants';\nimport { byteDecoder, byteEncoder } from '../utils';\n\n/**\n * Basic package manager for iden3 communication protocol\n *\n * @public\n * @class PackageManager\n * @implements implements IPackageManager interface\n */\nexport class PackageManager implements IPackageManager {\n  packers: Map<MediaType, IPacker>;\n\n  /**\n   * Creates an instance of PackageManager.\n   */\n  constructor() {\n    this.packers = new Map<MediaType, IPacker>();\n  }\n\n  /** {@inheritDoc IPackageManager.getSupportedProfiles} */\n  getSupportedProfiles(): string[] {\n    const acceptProfiles: string[] = [];\n    const mediaTypes = this.getSupportedMediaTypes();\n    for (const mediaType of mediaTypes) {\n      const p = this.packers.get(mediaType);\n      if (p) {\n        acceptProfiles.push(...p.getSupportedProfiles());\n      }\n    }\n    return [...new Set(acceptProfiles)];\n  }\n\n  /** {@inheritDoc IPackageManager.isProfileSupported} */\n  isProfileSupported(mediaType: MediaType, profile: string): boolean {\n    const p = this.packers.get(mediaType);\n    if (!p) {\n      return false;\n    }\n\n    return p.isProfileSupported(profile);\n  }\n\n  /** {@inheritDoc IPackageManager.getSupportedMediaTypes} */\n  getSupportedMediaTypes(): MediaType[] {\n    return [...this.packers.keys()];\n  }\n\n  /** {@inheritDoc IPackageManager.registerPackers} */\n  registerPackers(packers: Array<IPacker>): void {\n    packers.forEach((p) => {\n      this.packers.set(p.mediaType(), p);\n    });\n  }\n\n  /** {@inheritDoc IPackageManager.pack} */\n  async pack(mediaType: MediaType, payload: Uint8Array, params: PackerParams): Promise<Uint8Array> {\n    const p = this.packers.get(mediaType);\n    if (!p) {\n      throw new Error(`packer for media type ${mediaType} not found`);\n    }\n\n    return await p.pack(payload, params);\n  }\n\n  /**\n   * Packs a protocol message using the specified media type and packer parameters.\n   *\n   * @param mediaType - The media type to use for packing the message.\n   * @param protocolMessage - The protocol message to pack.\n   * @param params - The packer parameters.\n   * @returns A promise that resolves to the packed message as a Uint8Array.\n   * @throws An error if the packer for the specified media type is not found.\n   */\n  packMessage(\n    mediaType: MediaType,\n    protocolMessage: BasicMessage,\n    params: PackerParams\n  ): Promise<Uint8Array> {\n    const p = this.packers.get(mediaType);\n    if (!p) {\n      throw new Error(`packer for media type ${mediaType} not found`);\n    }\n\n    return p.packMessage(protocolMessage, params);\n  }\n\n  /** {@inheritDoc IPackageManager.unpack} */\n  async unpack(\n    envelope: Uint8Array\n  ): Promise<{ unpackedMessage: BasicMessage; unpackedMediaType: MediaType }> {\n    const decodedStr = byteDecoder.decode(envelope);\n    const safeEnvelope = decodedStr.trim();\n    const mediaType = this.getMediaType(safeEnvelope);\n    return {\n      unpackedMessage: await this.unpackWithSafeEnvelope(\n        mediaType,\n        byteEncoder.encode(safeEnvelope)\n      ),\n      unpackedMediaType: mediaType\n    };\n  }\n\n  /** {@inheritDoc IPackageManager.unpackWithType} */\n  async unpackWithType(mediaType: MediaType, envelope: Uint8Array): Promise<BasicMessage> {\n    const decoder = new TextDecoder('utf-8');\n    const decodedStr = decoder.decode(envelope);\n    const safeEnvelope = decodedStr.trim();\n    return await this.unpackWithSafeEnvelope(mediaType, byteEncoder.encode(safeEnvelope));\n  }\n\n  private async unpackWithSafeEnvelope(\n    mediaType: MediaType,\n    envelope: Uint8Array\n  ): Promise<BasicMessage> {\n    const p = this.packers.get(mediaType);\n    if (!p) {\n      throw new Error(`packer for media type ${mediaType} not found`);\n    }\n    const msg = await p.unpack(envelope);\n    return msg;\n  }\n\n  /** {@inheritDoc IPackageManager.getMediaType} */\n  getMediaType(envelope: string): MediaType {\n    let base64HeaderBytes: Uint8Array;\n\n    // full serialized\n    if (envelope[0] === '{') {\n      const envelopeStub = JSON.parse(envelope);\n      return envelopeStub.typ as MediaType;\n    } else {\n      const header = envelope.split('.')[0];\n      base64HeaderBytes = base64.parse(header, { loose: true });\n    }\n\n    const header = bytesToHeaderStub(base64HeaderBytes);\n    return header.typ;\n  }\n}\n","import {\n  StateVerificationOpts,\n  AuthDataPrepareFunc,\n  BasicMessage,\n  IPacker,\n  ProvingParams,\n  StateVerificationFunc,\n  VerificationParams,\n  ZKPPackerParams\n} from '../types';\nimport { Token, Header, ProvingMethodAlg, proving } from '@iden3/js-jwz';\nimport { AuthV2PubSignals, CircuitId } from '../../circuits/index';\nimport { BytesHelper, DID } from '@iden3/js-iden3-core';\nimport { bytesToProtocolMessage } from '../utils/envelope';\nimport {\n  ErrNoProvingMethodAlg,\n  ErrPackedWithUnsupportedCircuit,\n  ErrProofIsInvalid,\n  ErrSenderNotUsedTokenCreation,\n  ErrStateVerificationFailed,\n  ErrUnknownCircuitID\n} from '../errors';\nimport { AcceptAuthCircuits, AcceptJwzAlgorithms, MediaType, ProtocolVersion } from '../constants';\nimport { byteDecoder, byteEncoder } from '../../utils';\nimport { DEFAULT_AUTH_VERIFY_DELAY } from '../constants';\nimport { parseAcceptProfile } from '../utils';\n\nconst { getProvingMethod } = proving;\n\n/**\n * Handler to\n *\n * @public\n * @class DataPrepareHandlerFunc\n */\nexport class DataPrepareHandlerFunc {\n  /**\n   * Creates an instance of DataPrepareHandlerFunc.\n   * @param {AuthDataPrepareFunc} dataPrepareFunc - function that produces marshaled inputs for auth circuits\n   */\n  constructor(public readonly dataPrepareFunc: AuthDataPrepareFunc) {}\n\n  /**\n   *\n   *\n   * @param {Uint8Array} hash - challenge that will be signed\n   * @param {DID} did - did of identity that will prepare inputs\n   * @param {CircuitId} circuitId - circuit id\n   * @returns `Promise<Uint8Array>`\n   */\n  prepare(hash: Uint8Array, did: DID, circuitId: CircuitId): Promise<Uint8Array> {\n    return this.dataPrepareFunc(hash, did, circuitId);\n  }\n}\n\n/**\n * Handler to verify public signals of authorization circuits\n *\n * @public\n * @class VerificationHandlerFunc\n */\nexport class VerificationHandlerFunc {\n  /**\n   * Creates an instance of VerificationHandlerFunc.\n   * @param {StateVerificationFunc} stateVerificationFunc - state verification function\n   */\n  constructor(public readonly stateVerificationFunc: StateVerificationFunc) {}\n\n  /**\n   *\n   *\n   * @param {string} id  - id of circuit\n   * @param {Array<string>} pubSignals - signals that must contain user id and state\n   * @returns `Promise<boolean>`\n   */\n  verify(id: string, pubSignals: Array<string>, opts?: StateVerificationOpts): Promise<boolean> {\n    return this.stateVerificationFunc(id, pubSignals, opts);\n  }\n}\n\n/**\n * Packer that can pack message to JWZ token,\n * and unpack and validate JWZ envelope\n * @public\n * @class ZKPPacker\n * @implements implements IPacker interface\n */\nexport class ZKPPacker implements IPacker {\n  private readonly supportedProtocolVersions = [ProtocolVersion.V1];\n  private readonly supportedAlgorithms = [AcceptJwzAlgorithms.Groth16];\n  private readonly supportedCircuitIds = [AcceptAuthCircuits.AuthV2];\n\n  /**\n   * Creates an instance of ZKPPacker.\n   * @param {Map<string, ProvingParams>} provingParamsMap - string is derived by JSON.parse(ProvingMethodAlg)\n   * @param {Map<string, VerificationParams>} verificationParamsMap - string is derived by JSON.parse(ProvingMethodAlg)\n   */\n  constructor(\n    public readonly provingParamsMap: Map<string, ProvingParams>,\n    public readonly verificationParamsMap: Map<string, VerificationParams>,\n    private readonly _opts: StateVerificationOpts = {\n      acceptedStateTransitionDelay: DEFAULT_AUTH_VERIFY_DELAY\n    }\n  ) {}\n\n  /**\n   * Packs a basic message using the specified parameters.\n   * @param msg - The basic message to pack.\n   * @param param - The parameters for the ZKPPacker.\n   * @returns A promise that resolves to a Uint8Array representing the packed message.\n   */\n  packMessage(msg: BasicMessage, param: ZKPPackerParams): Promise<Uint8Array> {\n    return this.pack(byteEncoder.encode(JSON.stringify(msg)), param as ZKPPackerParams);\n  }\n\n  /**\n   * creates JSON Web Zeroknowledge token\n   *\n   * @param {Uint8Array} payload - serialized message\n   * @param {ZKPPackerParams} params - sender id and proving alg are required\n   * @returns `Promise<Uint8Array>`\n   */\n  async pack(payload: Uint8Array, params: ZKPPackerParams): Promise<Uint8Array> {\n    const provingMethod = await getProvingMethod(params.provingMethodAlg);\n    const provingParams = this.provingParamsMap.get(params.provingMethodAlg.toString());\n\n    if (!provingParams) {\n      throw new Error(ErrNoProvingMethodAlg);\n    }\n\n    const token = new Token(\n      provingMethod,\n      byteDecoder.decode(payload),\n      (hash: Uint8Array, circuitId: string) => {\n        return provingParams?.dataPreparer?.prepare(hash, params.senderDID, circuitId as CircuitId);\n      }\n    );\n    token.setHeader(Header.Type, MediaType.ZKPMessage);\n    const tokenStr = await token.prove(provingParams.provingKey, provingParams.wasm);\n    return byteEncoder.encode(tokenStr);\n  }\n\n  /**\n   * validate envelope which is jwz token\n   *\n   * @param {Uint8Array} envelope\n   * @returns `Promise<BasicMessage>`\n   */\n  async unpack(envelope: Uint8Array): Promise<BasicMessage> {\n    const token = await Token.parse(byteDecoder.decode(envelope));\n    const provingMethodAlg = new ProvingMethodAlg(token.alg, token.circuitId);\n    const verificationParams = this.verificationParamsMap.get(provingMethodAlg.toString());\n    if (!verificationParams?.key) {\n      throw new Error(ErrPackedWithUnsupportedCircuit);\n    }\n    const isValid = await token.verify(verificationParams?.key);\n    if (!isValid) {\n      throw new Error(ErrProofIsInvalid);\n    }\n\n    const verificationResult = await verificationParams?.verificationFn?.verify(\n      token.circuitId,\n      token.zkProof.pub_signals,\n      this._opts\n    );\n\n    if (!verificationResult) {\n      throw new Error(ErrStateVerificationFailed);\n    }\n\n    const message = bytesToProtocolMessage(byteEncoder.encode(token.getPayload()));\n\n    // should throw if error\n    verifySender(token, message);\n\n    return message;\n  }\n\n  mediaType(): MediaType {\n    return MediaType.ZKPMessage;\n  }\n\n  /** {@inheritDoc IPacker.getSupportedProfiles} */\n  getSupportedProfiles(): string[] {\n    return this.supportedProtocolVersions.map(\n      (v) =>\n        `${v};env=${this.mediaType()};alg=${this.supportedAlgorithms.join(\n          ','\n        )};circuitIds=${this.supportedCircuitIds.join(',')}`\n    );\n  }\n\n  /** {@inheritDoc IPacker.isProfileSupported} */\n  isProfileSupported(profile: string) {\n    const { protocolVersion, env, circuits, alg } = parseAcceptProfile(profile);\n\n    if (!this.supportedProtocolVersions.includes(protocolVersion)) {\n      return false;\n    }\n\n    if (env !== this.mediaType()) {\n      return false;\n    }\n\n    const supportedCircuitIds = this.supportedCircuitIds;\n    const circuitIdSupported =\n      !circuits?.length || circuits.some((c) => supportedCircuitIds.includes(c));\n\n    const supportedAlgArr = this.supportedAlgorithms;\n    const algSupported =\n      !alg?.length || alg.some((a) => supportedAlgArr.includes(a as AcceptJwzAlgorithms));\n    return algSupported && circuitIdSupported;\n  }\n}\n\nconst verifySender = async (token: Token, msg: BasicMessage): Promise<void> => {\n  switch (token.circuitId) {\n    case CircuitId.AuthV2:\n      {\n        if (!msg.from) {\n          throw new Error(ErrSenderNotUsedTokenCreation);\n        }\n        const authSignals = new AuthV2PubSignals().pubSignalsUnmarshal(\n          byteEncoder.encode(JSON.stringify(token.zkProof.pub_signals))\n        );\n        const did = DID.parseFromId(authSignals.userID);\n\n        const msgHash = await token.getMessageHash();\n        const challenge = BytesHelper.bytesToInt(msgHash.reverse());\n\n        if (challenge !== authSignals.challenge) {\n          throw new Error(ErrSenderNotUsedTokenCreation);\n        }\n\n        if (msg.from !== did.string()) {\n          throw new Error(ErrSenderNotUsedTokenCreation);\n        }\n      }\n      break;\n    default:\n      throw new Error(ErrUnknownCircuitID);\n  }\n};\n","import { AcceptProfile } from './types';\n\nconst IDEN3_PROTOCOL = 'https://iden3-communication.io/';\nconst DIDCOMM_PROTOCOL = 'https://didcomm.org/';\n/**\n * Constants for Iden3 protocol\n */\nexport const PROTOCOL_MESSAGE_TYPE = Object.freeze({\n  // AuthorizationV2RequestMessageType defines auth request type of the communication protocol\n  AUTHORIZATION_REQUEST_MESSAGE_TYPE: `${IDEN3_PROTOCOL}authorization/1.0/request` as const,\n  // AuthorizationResponseMessageType defines auth response type of the communication protocol\n  AUTHORIZATION_RESPONSE_MESSAGE_TYPE: `${IDEN3_PROTOCOL}authorization/1.0/response` as const,\n  // CredentialIssuanceRequestMessageType accepts request for credential creation\n  CREDENTIAL_ISSUANCE_REQUEST_MESSAGE_TYPE:\n    `${IDEN3_PROTOCOL}credentials/1.0/issuance-request` as const,\n  // CredentialFetchRequestMessageType is type for request of credential generation\n  CREDENTIAL_FETCH_REQUEST_MESSAGE_TYPE: `${IDEN3_PROTOCOL}credentials/1.0/fetch-request` as const,\n  // CredentialOfferMessageType is type of message with credential offering\n  CREDENTIAL_OFFER_MESSAGE_TYPE: `${IDEN3_PROTOCOL}credentials/1.0/offer` as const,\n  // CredentialIssuanceResponseMessageType is type for message with a credential issuance\n  CREDENTIAL_ISSUANCE_RESPONSE_MESSAGE_TYPE:\n    `${IDEN3_PROTOCOL}credentials/1.0/issuance-response` as const,\n  // CredentialRefreshMessageType is type for message with a credential issuance\n  CREDENTIAL_REFRESH_MESSAGE_TYPE: `${IDEN3_PROTOCOL}credentials/1.0/refresh` as const,\n  // DeviceRegistrationRequestMessageType defines device registration request type of the communication protocol\n  DEVICE_REGISTRATION_REQUEST_MESSAGE_TYPE: `${IDEN3_PROTOCOL}devices/1.0/registration` as const,\n  // MessageFetMessageFetchRequestMessageType defines message fetch request type of the communication protocol.\n  MESSAGE_FETCH_REQUEST_MESSAGE_TYPE: `${IDEN3_PROTOCOL}messages/1.0/fetch` as const,\n  // ProofGenerationRequestMessageType is type for request of proof generation\n  PROOF_GENERATION_REQUEST_MESSAGE_TYPE: `${IDEN3_PROTOCOL}proofs/1.0/request` as const,\n  // ProofGenerationResponseMessageType is type for response of proof generation\n  PROOF_GENERATION_RESPONSE_MESSAGE_TYPE: `${IDEN3_PROTOCOL}proofs/1.0/response` as const,\n  // RevocationStatusRequestMessageType is type for request of revocation status\n  REVOCATION_STATUS_REQUEST_MESSAGE_TYPE: `${IDEN3_PROTOCOL}revocation/1.0/request-status` as const,\n  // RevocationStatusResponseMessageType is type for response with a revocation status\n  REVOCATION_STATUS_RESPONSE_MESSAGE_TYPE: `${IDEN3_PROTOCOL}revocation/1.0/status` as const,\n  // ContractInvokeRequestMessageType is type for request of contract invoke request\n  CONTRACT_INVOKE_REQUEST_MESSAGE_TYPE:\n    `${IDEN3_PROTOCOL}proofs/1.0/contract-invoke-request` as const,\n  // ContractInvokeResponseMessageType is type for response of contract invoke request\n  CONTRACT_INVOKE_RESPONSE_MESSAGE_TYPE:\n    `${IDEN3_PROTOCOL}proofs/1.0/contract-invoke-response` as const,\n  // CredentialOnchainOfferMessageType is type of message with credential onchain offering\n  CREDENTIAL_ONCHAIN_OFFER_MESSAGE_TYPE: `${IDEN3_PROTOCOL}credentials/1.0/onchain-offer` as const,\n  // ProposalRequestMessageType is type for proposal-request message\n  PROPOSAL_REQUEST_MESSAGE_TYPE: `${IDEN3_PROTOCOL}credentials/0.1/proposal-request` as const,\n  // ProposalMessageType is type for proposal message\n  PROPOSAL_MESSAGE_TYPE: `${IDEN3_PROTOCOL}credentials/0.1/proposal` as const,\n  // PaymentRequestMessageType is type for payment-request message\n  PAYMENT_REQUEST_MESSAGE_TYPE: `${IDEN3_PROTOCOL}credentials/0.1/payment-request` as const,\n  // PaymentMessageType is type for payment message\n  PAYMENT_MESSAGE_TYPE: `${IDEN3_PROTOCOL}credentials/0.1/payment` as const,\n  // DiscoveryProtocolQueriesMessageType is type for didcomm discovery protocol queries\n  DISCOVERY_PROTOCOL_QUERIES_MESSAGE_TYPE:\n    `${DIDCOMM_PROTOCOL}discover-features/2.0/queries` as const,\n  // DiscoveryProtocolDiscloseMessageType is type for didcomm discovery protocol disclose\n  DISCOVERY_PROTOCOL_DISCLOSE_MESSAGE_TYPE:\n    `${DIDCOMM_PROTOCOL}discover-features/2.0/disclose` as const,\n  // ProblemReportMessageType is type for didcomm problem report\n  PROBLEM_REPORT_MESSAGE_TYPE: `${DIDCOMM_PROTOCOL}report-problem/2.0/problem-report` as const\n});\n\n/**\n * Media types for iden3 comm communication protocol\n *\n * @enum {number}\n */\nexport enum MediaType {\n  ZKPMessage = 'application/iden3-zkp-json',\n  PlainMessage = 'application/iden3comm-plain-json',\n  SignedMessage = 'application/iden3comm-signed-json'\n}\n\nexport const SUPPORTED_PUBLIC_KEY_TYPES = {\n  ES256K: [\n    'EcdsaSecp256k1VerificationKey2019',\n    /**\n     * Equivalent to EcdsaSecp256k1VerificationKey2019 when key is an ethereumAddress\n     */\n    'EcdsaSecp256k1RecoveryMethod2020',\n    'JsonWebKey2020'\n  ],\n  'ES256K-R': [\n    'EcdsaSecp256k1VerificationKey2019',\n    /**\n     * Equivalent to EcdsaSecp256k1VerificationKey2019 when key is an ethereumAddress\n     */\n    'EcdsaSecp256k1RecoveryMethod2020',\n    'JsonWebKey2020'\n  ]\n};\n\nexport enum ProtocolVersion {\n  V1 = 'iden3comm/v1'\n}\n\nexport enum AcceptAuthCircuits {\n  AuthV2 = 'authV2',\n  AuthV3 = 'authV3'\n}\n\nexport enum AcceptJwzAlgorithms {\n  Groth16 = 'groth16'\n}\n\nexport enum AcceptJwsAlgorithms {\n  ES256K = 'ES256K',\n  ES256KR = 'ES256K-R'\n}\n\nexport const defaultAcceptProfile: AcceptProfile = {\n  protocolVersion: ProtocolVersion.V1,\n  env: MediaType.ZKPMessage,\n  circuits: [AcceptAuthCircuits.AuthV2],\n  alg: [AcceptJwzAlgorithms.Groth16]\n};\n\nexport const DEFAULT_PROOF_VERIFY_DELAY = 1 * 60 * 60 * 1000; // 1 hour\nexport const DEFAULT_AUTH_VERIFY_DELAY = 5 * 60 * 1000; // 5 minutes\n","import { SUPPORTED_PUBLIC_KEY_TYPES } from '../constants';\nimport { DIDDocument, VerificationMethod } from 'did-resolver';\nimport { secp256k1 as sec } from '@noble/curves/secp256k1';\n\nimport { KmsKeyType } from '../../kms';\nimport { base58ToBytes, base64UrlToBytes, bytesToHex, hexToBytes } from '../../utils';\n\nconst DIDAuthenticationSection = 'authentication';\nexport const resolveVerificationMethods = (didDocument: DIDDocument): VerificationMethod[] => {\n  const vms: VerificationMethod[] = didDocument.verificationMethod || [];\n\n  // prioritize: first verification methods to be chosen are from `authentication` section.\n  const sortedVerificationMethods = (didDocument[DIDAuthenticationSection] || [])\n    .map((verificationMethod) => {\n      if (typeof verificationMethod === 'string') {\n        return vms.find((i) => i.id === verificationMethod);\n      }\n      return verificationMethod as VerificationMethod;\n    })\n    .filter((key) => key) as VerificationMethod[];\n\n  // add all other verification methods\n  for (let index = 0; index < vms.length; index++) {\n    const id = vms[index].id;\n    if (sortedVerificationMethods.findIndex((vm) => vm.id === id) === -1) {\n      sortedVerificationMethods.push(vms[index]);\n    }\n  }\n  return sortedVerificationMethods;\n};\n\nexport const extractPublicKeyBytes = (\n  vm: VerificationMethod\n): { publicKeyBytes: Uint8Array | null; kmsKeyType?: KmsKeyType } => {\n  const isSupportedVmType = Object.keys(SUPPORTED_PUBLIC_KEY_TYPES).some((key) =>\n    SUPPORTED_PUBLIC_KEY_TYPES[key as keyof typeof SUPPORTED_PUBLIC_KEY_TYPES].includes(vm.type)\n  );\n  if (vm.publicKeyBase58 && isSupportedVmType) {\n    return { publicKeyBytes: base58ToBytes(vm.publicKeyBase58), kmsKeyType: KmsKeyType.Secp256k1 };\n  }\n  if (vm.publicKeyBase64 && isSupportedVmType) {\n    return {\n      publicKeyBytes: base64UrlToBytes(vm.publicKeyBase64),\n      kmsKeyType: KmsKeyType.Secp256k1\n    };\n  }\n  if (vm.publicKeyHex && isSupportedVmType) {\n    return { publicKeyBytes: hexToBytes(vm.publicKeyHex), kmsKeyType: KmsKeyType.Secp256k1 };\n  }\n  if (\n    vm.publicKeyJwk &&\n    vm.publicKeyJwk.crv === 'secp256k1' &&\n    vm.publicKeyJwk.x &&\n    vm.publicKeyJwk.y\n  ) {\n    const [xHex, yHex] = [\n      base64UrlToBytes(vm.publicKeyJwk.x),\n      base64UrlToBytes(vm.publicKeyJwk.y)\n    ].map(bytesToHex);\n    const x = xHex.includes('0x') ? BigInt(xHex) : BigInt(`0x${xHex}`);\n    const y = yHex.includes('0x') ? BigInt(yHex) : BigInt(`0x${yHex}`);\n    return {\n      publicKeyBytes: sec.ProjectivePoint.fromAffine({\n        x,\n        y\n      }).toRawBytes(false),\n      kmsKeyType: KmsKeyType.Secp256k1\n    };\n  }\n  return { publicKeyBytes: null };\n};\n","import {\n  MediaType,\n  ProtocolVersion,\n  AcceptAuthCircuits,\n  AcceptJwzAlgorithms,\n  AcceptJwsAlgorithms\n} from '../constants';\nimport { AcceptProfile } from '../types';\n\nfunction isProtocolVersion(value: string): boolean {\n  return Object.values(ProtocolVersion).includes(value as ProtocolVersion);\n}\n\nfunction isMediaType(value: string): boolean {\n  return Object.values(MediaType).includes(value as MediaType);\n}\n\nfunction isAcceptAuthCircuits(value: string): boolean {\n  return Object.values(AcceptAuthCircuits).includes(value as AcceptAuthCircuits);\n}\n\nfunction isAcceptJwsAlgorithms(value: string): boolean {\n  return Object.values(AcceptJwsAlgorithms).includes(value as AcceptJwsAlgorithms);\n}\n\nfunction isAcceptJwzAlgorithms(value: string): boolean {\n  return Object.values(AcceptJwzAlgorithms).includes(value as AcceptJwzAlgorithms);\n}\n\nexport const buildAccept = (profiles: AcceptProfile[]): string[] => {\n  const result = [];\n  for (const profile of profiles) {\n    let accept = `${profile.protocolVersion};env=${profile.env}`;\n    if (profile.circuits?.length) {\n      accept += `;circuitId=${profile.circuits.join(',')}`;\n    }\n    if (profile.alg?.length) {\n      accept += `;alg=${profile.alg.join(',')}`;\n    }\n    result.push(accept);\n  }\n\n  return result;\n};\n\nexport const parseAcceptProfile = (profile: string): AcceptProfile => {\n  const params = profile.split(';');\n\n  if (params.length < 2) {\n    throw new Error('Invalid accept profile');\n  }\n  const protocolVersion = params[0].trim() as ProtocolVersion;\n  if (!isProtocolVersion(protocolVersion)) {\n    throw new Error(`Protocol version '${protocolVersion}' not supported`);\n  }\n\n  const envParam = params[1].split('=');\n  if (envParam.length !== 2) {\n    throw new Error(`Invalid accept profile 'env' parameter`);\n  }\n  const env = params[1].split('=')[1].trim() as MediaType;\n  if (!isMediaType(env)) {\n    throw new Error(`Envelop '${env}' not supported`);\n  }\n\n  const circuitsIndex = params.findIndex((i: string) => i.includes('circuitId='));\n  if (env !== MediaType.ZKPMessage && circuitsIndex > 0) {\n    throw new Error(`Circuits not supported for env '${env}'`);\n  }\n\n  let circuits: AcceptAuthCircuits[] | undefined = undefined;\n  if (circuitsIndex > 0) {\n    circuits = params[circuitsIndex]\n      .split('=')[1]\n      .split(',')\n      .map((i) => i.trim())\n      .map((i) => {\n        if (!isAcceptAuthCircuits(i)) {\n          throw new Error(`Circuit '${i}' not supported`);\n        }\n        return i as AcceptAuthCircuits;\n      });\n  }\n\n  const algIndex = params.findIndex((i: string) => i.includes('alg='));\n  let alg: AcceptJwsAlgorithms[] | AcceptJwzAlgorithms[] | undefined = undefined;\n  if (algIndex > 0) {\n    if (env === MediaType.ZKPMessage) {\n      alg = params[algIndex]\n        .split('=')[1]\n        .split(',')\n        .map((i) => {\n          i = i.trim();\n          if (!isAcceptJwzAlgorithms(i)) {\n            throw new Error(`Algorithm '${i}' not supported for '${env}'`);\n          }\n          return i as AcceptJwzAlgorithms;\n        });\n    } else if (env === MediaType.SignedMessage) {\n      alg = params[algIndex]\n        .split('=')[1]\n        .split(',')\n        .map((i) => {\n          i = i.trim();\n          if (!isAcceptJwsAlgorithms(i)) {\n            throw new Error(`Algorithm '${i}' not supported for '${env}'`);\n          }\n          return i as AcceptJwsAlgorithms;\n        });\n    } else {\n      throw new Error(`Algorithm not supported for '${env}'`);\n    }\n  }\n\n  return {\n    protocolVersion,\n    env,\n    circuits,\n    alg\n  };\n};\n","import { BasicMessage, IPacker } from '../types';\nimport { MediaType, ProtocolVersion } from '../constants';\nimport { byteDecoder, byteEncoder } from '../../utils';\nimport { parseAcceptProfile } from '../utils';\n\n/**\n * Plain packer just serializes bytes to JSON and adds media type\n *\n * @public\n * @class PlainPacker\n * @implements implements IPacker interface\n */\nexport class PlainPacker implements IPacker {\n  private readonly supportedProtocolVersions = [ProtocolVersion.V1];\n\n  /**\n   * Packs a basic message using the specified parameters.\n   *\n   * @param msg - The basic message to pack.\n   * @param param - The packer parameters.\n   * @returns A promise that resolves to a Uint8Array representing the packed message.\n   * @throws An error if the method is not implemented.\n   */\n  packMessage(msg: BasicMessage): Promise<Uint8Array> {\n    msg.typ = MediaType.PlainMessage;\n    return Promise.resolve(byteEncoder.encode(JSON.stringify(msg)));\n  }\n  /**\n   * Pack returns packed message to transport envelope\n   *\n   * @param {Uint8Array} payload - json message serialized\n   * @param {PlainPackerParams} _params - not used here\n   * @returns `Promise<Uint8Array>`\n   */\n  async pack(payload: Uint8Array): Promise<Uint8Array> {\n    const msg = JSON.parse(byteDecoder.decode(payload));\n    msg.typ = MediaType.PlainMessage;\n    return Promise.resolve(byteEncoder.encode(JSON.stringify(msg)));\n  }\n\n  /**\n   * Unpack returns unpacked message from transport envelope\n   *\n   * @param {Uint8Array} envelope - packed envelope (serialized json with media type)\n   * @returns `Promise<BasicMessage>`\n   */\n  async unpack(envelope: Uint8Array): Promise<BasicMessage> {\n    return JSON.parse(byteDecoder.decode(envelope));\n  }\n\n  /**\n   * returns media type for plain message\n   *\n   * @returns MediaType\n   */\n  mediaType(): MediaType {\n    return MediaType.PlainMessage;\n  }\n\n  /** {@inheritDoc IPacker.getSupportedProfiles} */\n  getSupportedProfiles(): string[] {\n    return this.supportedProtocolVersions.map((v) => `${v};env=${this.mediaType()}`);\n  }\n\n  /** {@inheritDoc IPacker.isProfileSupported} */\n  isProfileSupported(profile: string) {\n    const { protocolVersion, env, circuits, alg } = parseAcceptProfile(profile);\n\n    if (!this.supportedProtocolVersions.includes(protocolVersion)) {\n      return false;\n    }\n    if (env !== this.mediaType()) {\n      return false;\n    }\n\n    if (circuits) {\n      throw new Error(`Circuits are not supported for ${env} media type`);\n    }\n\n    if (alg) {\n      throw new Error(`Algorithms are not supported for ${env} media type`);\n    }\n\n    return true;\n  }\n}\n","import { BasicMessage, IPacker, JWSPackerParams } from '../types';\nimport {\n  AcceptJwsAlgorithms,\n  MediaType,\n  ProtocolVersion,\n  SUPPORTED_PUBLIC_KEY_TYPES\n} from '../constants';\nimport { extractPublicKeyBytes, resolveVerificationMethods } from '../utils/did';\nimport { keyPath, KMS } from '../../kms/';\n\nimport { verifyJWS } from 'did-jwt';\nimport { DIDDocument, Resolvable, parse } from 'did-resolver';\nimport { bytesToBase64url } from '../../utils/encoding';\nimport {\n  byteDecoder,\n  byteEncoder,\n  bytesToHex,\n  decodeBase64url,\n  encodeBase64url\n} from '../../utils';\nimport { parseAcceptProfile } from '../utils';\n\n/**\n * Packer that can pack message to JWZ token,\n * and unpack and validate JWZ envelope\n * @public\n * @class ZKPPacker\n * @implements implements IPacker interface\n */\nexport class JWSPacker implements IPacker {\n  private readonly supportedAlgorithms = [AcceptJwsAlgorithms.ES256K, AcceptJwsAlgorithms.ES256KR];\n  private readonly supportedProtocolVersions = [ProtocolVersion.V1];\n\n  /**\n   * Creates an instance of JWSPacker.\n   *\n   * @param {KMS} _kms\n   * @param {Resolvable} _documentResolver\n   * @memberof JWSPacker\n   */\n  constructor(private readonly _kms: KMS, private readonly _documentResolver: Resolvable) {}\n\n  /**\n   * Packs the given payload and returns a promise that resolves to the packed data.\n   *\n   * @param {Uint8Array} payload - The payload to be packed.\n   * @param {PackerParams} param - The packing parameters.\n   * @returns `Promise<Uint8Array>`\n   */\n  packMessage(msg: BasicMessage, param: JWSPackerParams): Promise<Uint8Array> {\n    return this.packInternal(msg, param);\n  }\n  /**\n   * creates JSON Web Signature token\n   *\n   * @param {Uint8Array} payload - serialized message\n   * @param {PackerParams} params - sender id and proving alg are required\n   * @returns `Promise<Uint8Array>`\n   */\n  async pack(payload: Uint8Array, params: JWSPackerParams): Promise<Uint8Array> {\n    const message = JSON.parse(byteDecoder.decode(payload));\n    return this.packInternal(message, params);\n  }\n\n  /**\n   * validate envelope which is jwz token\n   *\n   * @param {Uint8Array} envelope\n   * @returns `Promise<BasicMessage>`\n   */\n  async unpack(envelope: Uint8Array): Promise<BasicMessage> {\n    const jws = byteDecoder.decode(envelope);\n\n    const [headerStr, msgStr] = jws.split('.');\n\n    const header = JSON.parse(decodeBase64url(headerStr));\n    const message = JSON.parse(decodeBase64url(msgStr));\n    const explicitSender = parse(header.kid)?.did;\n    if (explicitSender && explicitSender !== message.from) {\n      throw new Error(`Sender does not match DID in message with kid ${header?.kid}`);\n    }\n\n    const didDocument: DIDDocument = await this.resolveDidDoc(message.from);\n\n    let vms = resolveVerificationMethods(didDocument);\n\n    if (!vms?.length) {\n      throw new Error(`No verification methods defined in the DID document of ${didDocument.id}`);\n    }\n    if (header.kid) {\n      const vm = vms.find((v) => {\n        return v.id === header.kid;\n      });\n      if (!vm) {\n        throw new Error(\n          `verification method with specified kid ${header.kid} is not found in the DID Document`\n        );\n      }\n      vms = [vm];\n    }\n\n    const verificationResponse = verifyJWS(jws, vms);\n\n    if (!verificationResponse) {\n      throw new Error('JWS verification failed');\n    }\n    return message as BasicMessage;\n  }\n\n  mediaType(): MediaType {\n    return MediaType.SignedMessage;\n  }\n\n  /** {@inheritDoc IPacker.getSupportedProfiles} */\n  getSupportedProfiles(): string[] {\n    return this.supportedProtocolVersions.map(\n      (v) => `${v};env=${this.mediaType()};alg=${this.supportedAlgorithms.join(',')}`\n    );\n  }\n\n  /** {@inheritDoc IPacker.isProfileSupported} */\n  isProfileSupported(profile: string) {\n    const { protocolVersion, env, circuits, alg } = parseAcceptProfile(profile);\n\n    if (!this.supportedProtocolVersions.includes(protocolVersion)) {\n      return false;\n    }\n    if (env !== this.mediaType()) {\n      return false;\n    }\n\n    if (circuits) {\n      throw new Error(`Circuits are not supported for ${env} media type`);\n    }\n\n    const algSupported =\n      !alg?.length || alg.some((a) => this.supportedAlgorithms.includes(a as AcceptJwsAlgorithms));\n    return algSupported;\n  }\n\n  private async resolveDidDoc(from: string) {\n    let didDocument: DIDDocument;\n    try {\n      const didResolutionResult = await this._documentResolver.resolve(from);\n      if (!didResolutionResult?.didDocument?.id) {\n        throw new Error(`did document for ${from} is not found in resolution result`);\n      }\n      didDocument = didResolutionResult.didDocument;\n    } catch (err: unknown) {\n      throw new Error(`did document for ${from} is not resolved: ${(err as Error).message}`);\n    }\n    return didDocument;\n  }\n\n  private async packInternal(message: BasicMessage, params: JWSPackerParams): Promise<Uint8Array> {\n    if (!params.alg) {\n      throw new Error('Missing algorithm');\n    }\n\n    const from = message.from ?? '';\n    if (!from) {\n      throw new Error('Missing sender DID');\n    }\n\n    const vmTypes: string[] =\n      SUPPORTED_PUBLIC_KEY_TYPES[params.alg as keyof typeof SUPPORTED_PUBLIC_KEY_TYPES];\n    if (!vmTypes?.length) {\n      throw new Error(`No supported verification methods for algorithm ${params.alg}`);\n    }\n\n    const didDocument: DIDDocument = params.didDocument ?? (await this.resolveDidDoc(from));\n\n    const vms = resolveVerificationMethods(didDocument);\n\n    if (!vms.length) {\n      throw new Error(`No verification methods defined in the DID document of ${didDocument.id}`);\n    }\n\n    // try to find a managed signing key that matches keyRef\n    const vm = params.kid ? vms.find((vm) => vm.id === params.kid) : vms[0];\n\n    if (!vm) {\n      throw new Error(`No key found with id ${params.kid} in DID document of ${didDocument.id}`);\n    }\n\n    const { publicKeyBytes, kmsKeyType } = extractPublicKeyBytes(vm);\n\n    if (!publicKeyBytes && !kmsKeyType) {\n      if ((vm.blockchainAccountId || vm.ethereumAddress) && !params.signer) {\n        throw new Error(`No signer provided for ${vm.blockchainAccountId || vm.ethereumAddress}`);\n      }\n    }\n\n    const kid = vm.id;\n\n    const headerObj = { alg: params.alg, kid, typ: MediaType.SignedMessage };\n    const header = encodeBase64url(JSON.stringify(headerObj));\n    const msg = encodeBase64url(JSON.stringify(message));\n    const signingInput = `${header}.${msg}`;\n    const signingInputBytes = byteEncoder.encode(signingInput);\n    let signatureBase64: string;\n    if (params.signer) {\n      const signature = await params.signer(vm, signingInputBytes);\n      signatureBase64 = bytesToBase64url(signature);\n    } else {\n      if (!publicKeyBytes) {\n        throw new Error('No public key found');\n      }\n\n      if (!kmsKeyType) {\n        throw new Error('No KMS key type found');\n      }\n\n      const signatureBytes = await this._kms.sign(\n        { type: kmsKeyType, id: keyPath(kmsKeyType, bytesToHex(publicKeyBytes)) },\n        signingInputBytes,\n        { alg: params.alg }\n      );\n\n      signatureBase64 = bytesToBase64url(signatureBytes);\n    }\n\n    return byteEncoder.encode(`${signingInput}.${signatureBase64}`);\n  }\n}\n","import { W3CCredential } from '../../../verifiable';\nimport { PROTOCOL_MESSAGE_TYPE } from '../../constants';\nimport { BasicMessage, JsonDocumentObject, RequiredBasicMessage } from '../packer';\nimport { ContractInvokeTransactionData } from './contract-request';\n\n/** CredentialIssuanceRequestMessageBody represents data for credential issuance request */\nexport type CredentialIssuanceRequestMessageBody = {\n  schema: Schema;\n  data: JsonDocumentObject;\n  expiration: number;\n};\n\n/** CredentialIssuanceRequestMessage represent Iden3message for credential request */\nexport type CredentialIssuanceRequestMessage = RequiredBasicMessage & {\n  body: CredentialIssuanceRequestMessageBody;\n  type: typeof PROTOCOL_MESSAGE_TYPE.CREDENTIAL_ISSUANCE_REQUEST_MESSAGE_TYPE;\n};\n\n/** CredentialsOfferMessage represent Iden3message for credential offer */\nexport type CredentialsOfferMessage = RequiredBasicMessage & {\n  body: CredentialsOfferMessageBody;\n  type: typeof PROTOCOL_MESSAGE_TYPE.CREDENTIAL_OFFER_MESSAGE_TYPE;\n};\n\n/** CredentialsOfferMessageBody is struct the represents offer message */\nexport type CredentialsOfferMessageBody = {\n  url: string;\n  credentials: CredentialOffer[];\n};\n\n/** CredentialsOnchainOfferMessage represent Iden3message for credential onchain offer message */\nexport type CredentialsOnchainOfferMessage = RequiredBasicMessage & {\n  body: CredentialsOnchainOfferMessageBody;\n  type: typeof PROTOCOL_MESSAGE_TYPE.CREDENTIAL_ONCHAIN_OFFER_MESSAGE_TYPE;\n};\n\n/** CredentialsOnchainOfferMessageBody is struct the represents onchain offer message body */\nexport type CredentialsOnchainOfferMessageBody = {\n  credentials: CredentialOffer[];\n  transaction_data: ContractInvokeTransactionData;\n};\n\n/** CredentialOfferStatus is list of possible statuses for credential offer message */\nexport enum CredentialOfferStatus {\n  Pending = 'pending',\n  Completed = 'completed',\n  Rejected = 'rejected'\n}\n\n/** CredentialOffer is structure to fetch credential */\nexport type CredentialOffer = {\n  id: string;\n  description: string;\n  status?: CredentialOfferStatus;\n};\n\n/** CredentialIssuanceMessage represent Iden3message for credential issuance */\nexport type CredentialIssuanceMessage = RequiredBasicMessage & {\n  body: IssuanceMessageBody;\n  type: typeof PROTOCOL_MESSAGE_TYPE.CREDENTIAL_ISSUANCE_RESPONSE_MESSAGE_TYPE;\n};\n\n/** IssuanceMessageBody is struct the represents message when credential is issued */\nexport type IssuanceMessageBody = {\n  credential: W3CCredential;\n};\n\n/** CredentialFetchRequestMessage represent Iden3message for credential fetch request */\nexport type CredentialFetchRequestMessage = BasicMessage & {\n  body: CredentialFetchRequestMessageBody;\n  type: typeof PROTOCOL_MESSAGE_TYPE.CREDENTIAL_FETCH_REQUEST_MESSAGE_TYPE;\n};\n\n/** CredentialFetchRequestMessageBody is msg body for fetch request */\nexport type CredentialFetchRequestMessageBody = {\n  id: string;\n};\n\n/** Schema represents location and type where it's stored */\nexport type Schema = {\n  hash?: string;\n  url: string;\n  type: string;\n};\n\n/** CredentialRefreshMessage represent Iden3message for credential refresh request */\nexport type CredentialRefreshMessage = RequiredBasicMessage & {\n  body: CredentialRefreshMessageBody;\n  type: typeof PROTOCOL_MESSAGE_TYPE.CREDENTIAL_REFRESH_MESSAGE_TYPE;\n};\n\n/** CredentialRefreshMessageBody is msg body for refresh request */\nexport type CredentialRefreshMessageBody = {\n  id: string;\n  reason: string;\n};\n","import { GlobalStateUpdate, IdentityStateUpdate } from '../../../storage/entities/state';\nimport { PROTOCOL_MESSAGE_TYPE } from '../../constants';\nimport { BasicMessage } from '../packer';\nimport {\n  DIDDocument,\n  ZeroKnowledgeProofAuthResponse,\n  ZeroKnowledgeProofRequest,\n  ZeroKnowledgeProofResponse\n} from './auth';\nimport { DID } from '@iden3/js-iden3-core';\n\n/** ContractInvokeRequest represents structure of contract invoke request object */\nexport type ContractInvokeRequest = BasicMessage & {\n  body: ContractInvokeRequestBody;\n  type: typeof PROTOCOL_MESSAGE_TYPE.CONTRACT_INVOKE_REQUEST_MESSAGE_TYPE;\n};\n\n/** ContractInvokeRequestBody represents structure of contract invoke request body object */\nexport type ContractInvokeRequestBody = {\n  reason?: string;\n  transaction_data: ContractInvokeTransactionData;\n  scope: Array<ZeroKnowledgeProofRequest>;\n  did_doc?: DIDDocument;\n  accept?: string[];\n};\n\n/** ContractInvokeResponse represents structure of contract invoke response object */\nexport type ContractInvokeResponse = BasicMessage & {\n  body: ContractInvokeResponseBody;\n  type: typeof PROTOCOL_MESSAGE_TYPE.CONTRACT_INVOKE_RESPONSE_MESSAGE_TYPE;\n};\n\n/** ContractInvokeResponseBody represents structure of contract invoke response body object */\nexport type ContractInvokeResponseBody = {\n  scope: Array<OnChainZeroKnowledgeProofResponse>;\n  transaction_data: ContractInvokeTransactionData;\n  did_doc?: DIDDocument;\n  crossChainProof?: CrossChainProof;\n  authProof?: AuthProof;\n};\n\n/** OnChainZeroKnowledgeProofResponse represents structure of onchain zero knowledge proof response */\nexport type OnChainZeroKnowledgeProofResponse = ZeroKnowledgeProofResponse & {\n  txHash?: string;\n};\n\n/** ContractInvokeTransactionData represents structure of contract invoke transaction data object */\nexport type ContractInvokeTransactionData = {\n  contract_address: string;\n  method_id: string;\n  chain_id: number;\n  network?: string;\n  txHash?: string;\n};\n\nexport type AuthProofEthIdentity = {\n  userDid: DID;\n};\nexport type AuthProofZKP = {\n  zkp: ZeroKnowledgeProofAuthResponse;\n};\n\n/** AuthProofResponse represents structure of zkp response */\nexport type AuthProof = {\n  authMethod: AuthMethod;\n} & (AuthProofEthIdentity | AuthProofZKP);\n\nexport type CrossChainProof = {\n  globalStateProofs: GlobalStateUpdate[];\n  identityStateProofs: IdentityStateUpdate[];\n};\n\nexport enum AuthMethod {\n  AUTHV2 = 'authV2',\n  ETH_IDENTITY = 'ethIdentity'\n}\n","import { PROTOCOL_MESSAGE_TYPE } from '../../constants';\nimport { BasicMessage } from '../packer';\n\n/** @beta DiscoverFeatureQueryType is enum for query type fields */\nexport enum DiscoverFeatureQueryType {\n  FeatureType = 'feature-type'\n}\n\n/** @beta DiscoveryProtocolFeatureType is enum for supported feature-types */\nexport enum DiscoveryProtocolFeatureType {\n  Accept = 'accept',\n  Protocol = 'protocol',\n  GoalCode = 'goal-code',\n  Header = 'header'\n}\n\n/** @beta DiscoverFeatureQueriesMessage is struct the represents discover feature queries message */\nexport type DiscoverFeatureQueriesMessage = BasicMessage & {\n  body: DiscoverFeatureQueriesBody;\n  type: typeof PROTOCOL_MESSAGE_TYPE.DISCOVERY_PROTOCOL_QUERIES_MESSAGE_TYPE;\n};\n\n/** @beta DiscoverFeatureQueriesBody is struct the represents discover feature queries body */\nexport type DiscoverFeatureQueriesBody = {\n  queries: DiscoverFeatureQuery[];\n};\n\n/** @beta DiscoverFeatureQuery is struct the represents discover feature query */\nexport type DiscoverFeatureQuery = {\n  [DiscoverFeatureQueryType.FeatureType]: DiscoveryProtocolFeatureType;\n  match?: string;\n};\n\n/** @beta DiscoverFeatureDiscloseMessage is struct the represents discover feature disclose message */\nexport type DiscoverFeatureDiscloseMessage = BasicMessage & {\n  body: DiscoverFeatureDiscloseBody;\n  type: typeof PROTOCOL_MESSAGE_TYPE.DISCOVERY_PROTOCOL_DISCLOSE_MESSAGE_TYPE;\n};\n\n/** @beta DiscoverFeatureDiscloseBody is struct the represents discover feature disclose body */\nexport type DiscoverFeatureDiscloseBody = {\n  disclosures: DiscoverFeatureDisclosure[];\n};\n\n/** @beta DiscoverFeatureDisclosure is struct the represents discover feature disclosure */\nexport type DiscoverFeatureDisclosure = {\n  [DiscoverFeatureQueryType.FeatureType]: DiscoveryProtocolFeatureType;\n  id: string;\n};\n","import { MediaType } from '../constants';\nimport { IProofService } from '../../proof/proof-service';\nimport { PROTOCOL_MESSAGE_TYPE } from '../constants';\n\nimport {\n  StateVerificationOpts,\n  AuthorizationRequestMessage,\n  AuthorizationResponseMessage,\n  BasicMessage,\n  IPackageManager,\n  JWSPackerParams,\n  ZeroKnowledgeProofRequest,\n  JSONObject\n} from '../types';\nimport { DID, getUnixTimestamp } from '@iden3/js-iden3-core';\nimport { proving } from '@iden3/js-jwz';\n\nimport * as uuid from 'uuid';\nimport { ProofQuery } from '../../verifiable';\nimport { byteDecoder, byteEncoder } from '../../utils';\nimport { processZeroKnowledgeProofRequests, verifyExpiresTime } from './common';\nimport { CircuitId } from '../../circuits';\nimport {\n  AbstractMessageHandler,\n  BasicHandlerOptions,\n  IProtocolMessageHandler\n} from './message-handler';\nimport { parseAcceptProfile } from '../utils';\n\n/**\n * Options to pass to createAuthorizationRequest function\n * @public\n */\nexport type AuthorizationRequestCreateOptions = {\n  accept?: string[];\n  scope?: ZeroKnowledgeProofRequest[];\n  expires_time?: Date;\n};\n\n/**\n *  createAuthorizationRequest is a function to create protocol authorization request\n * @param {string} reason - reason to request proof\n * @param {string} sender - sender did\n * @param {string} callbackUrl - callback that user should use to send response\n * @param {AuthorizationRequestCreateOptions} opts - authorization request options\n * @returns `Promise<AuthorizationRequestMessage>`\n */\nexport function createAuthorizationRequest(\n  reason: string,\n  sender: string,\n  callbackUrl: string,\n  opts?: AuthorizationRequestCreateOptions\n): AuthorizationRequestMessage {\n  return createAuthorizationRequestWithMessage(reason, '', sender, callbackUrl, opts);\n}\n/**\n *  createAuthorizationRequestWithMessage is a function to create protocol authorization request with explicit message to sign\n * @param {string} reason - reason to request proof\n * @param {string} message - message to sign in the response\n * @param {string} sender - sender did\n * @param {string} callbackUrl - callback that user should use to send response\n * @param {AuthorizationRequestCreateOptions} opts - authorization request options\n * @returns `Promise<AuthorizationRequestMessage>`\n */\nexport function createAuthorizationRequestWithMessage(\n  reason: string,\n  message: string,\n  sender: string,\n  callbackUrl: string,\n  opts?: AuthorizationRequestCreateOptions\n): AuthorizationRequestMessage {\n  const uuidv4 = uuid.v4();\n  const request: AuthorizationRequestMessage = {\n    id: uuidv4,\n    thid: uuidv4,\n    from: sender,\n    typ: MediaType.PlainMessage,\n    type: PROTOCOL_MESSAGE_TYPE.AUTHORIZATION_REQUEST_MESSAGE_TYPE,\n    body: {\n      accept: opts?.accept,\n      reason: reason,\n      message: message,\n      callbackUrl: callbackUrl,\n      scope: opts?.scope ?? []\n    },\n    created_time: getUnixTimestamp(new Date()),\n    expires_time: opts?.expires_time ? getUnixTimestamp(opts.expires_time) : undefined\n  };\n  return request;\n}\n\n/**\n *\n * Options to pass to auth response handler\n *\n * @public\n */\nexport type AuthResponseHandlerOptions = StateVerificationOpts &\n  BasicHandlerOptions & {\n    // acceptedProofGenerationDelay is the period of time in milliseconds that a generated proof remains valid.\n    acceptedProofGenerationDelay?: number;\n  };\n\n/**\n * Interface that allows the processing of the authorization request in the raw format for given identifier\n *\n * @public\n * @interface IAuthHandler\n */\nexport interface IAuthHandler {\n  /**\n   * unpacks authorization request\n   * @public\n   * @param {Uint8Array} request - raw byte message\n   * @returns `Promise<AuthorizationRequestMessage>`\n   */\n  parseAuthorizationRequest(request: Uint8Array): Promise<AuthorizationRequestMessage>;\n\n  /**\n   * unpacks authorization request\n   * @public\n   * @param {did} did  - sender DID\n   * @param {Uint8Array} request - raw byte message\n   * @returns `Promise<{\n    token: string;\n    authRequest: AuthorizationRequestMessage;\n    authResponse: AuthorizationResponseMessage;\n  }>`\n   */\n  handleAuthorizationRequest(\n    did: DID,\n    request: Uint8Array,\n    opts?: AuthHandlerOptions\n  ): Promise<{\n    token: string;\n    authRequest: AuthorizationRequestMessage;\n    authResponse: AuthorizationResponseMessage;\n  }>;\n\n  /**\n     * handle authorization response\n     * @public\n     * @param {AuthorizationResponseMessage} response  - auth response\n     * @param {AuthorizationRequestMessage} request  - auth request\n     * @param {AuthResponseHandlerOptions} opts - options\n     * @returns `Promise<{\n      request: AuthorizationRequestMessage;\n      response: AuthorizationResponseMessage;\n    }>`\n     */\n  handleAuthorizationResponse(\n    response: AuthorizationResponseMessage,\n    request: AuthorizationRequestMessage,\n    opts?: AuthResponseHandlerOptions\n  ): Promise<{\n    request: AuthorizationRequestMessage;\n    response: AuthorizationResponseMessage;\n  }>;\n}\n\ntype AuthReqOptions = {\n  senderDid: DID;\n  mediaType?: MediaType;\n};\n\ntype AuthRespOptions = {\n  request: AuthorizationRequestMessage;\n  acceptedStateTransitionDelay?: number;\n  acceptedProofGenerationDelay?: number;\n};\n\nexport type AuthMessageHandlerOptions = AuthReqOptions | AuthRespOptions;\n/**\n *\n * Options to pass to auth handler\n *\n * @public\n * @interface AuthHandlerOptions\n */\nexport type AuthHandlerOptions = BasicHandlerOptions & {\n  mediaType: MediaType;\n  packerOptions?: JWSPackerParams;\n};\n\n/**\n *\n * Allows to process AuthorizationRequest protocol message and produce JWZ response.\n *\n * @public\n\n * @class AuthHandler\n * @implements implements IAuthHandler interface\n */\nexport class AuthHandler\n  extends AbstractMessageHandler\n  implements IAuthHandler, IProtocolMessageHandler\n{\n  private readonly _supportedCircuits = [\n    CircuitId.AtomicQueryV3,\n    CircuitId.AtomicQuerySigV2,\n    CircuitId.AtomicQueryMTPV2,\n    CircuitId.LinkedMultiQuery10\n  ];\n  /**\n   * Creates an instance of AuthHandler.\n   * @param {IPackageManager} _packerMgr - package manager to unpack message envelope\n   * @param {IProofService} _proofService -  proof service to verify zk proofs\n   *\n   */\n  constructor(\n    private readonly _packerMgr: IPackageManager,\n    private readonly _proofService: IProofService\n  ) {\n    super();\n  }\n\n  handle(message: BasicMessage, ctx: AuthMessageHandlerOptions): Promise<BasicMessage | null> {\n    switch (message.type) {\n      case PROTOCOL_MESSAGE_TYPE.AUTHORIZATION_REQUEST_MESSAGE_TYPE:\n        return this.handleAuthRequest(\n          message as AuthorizationRequestMessage,\n          ctx as AuthReqOptions\n        );\n      case PROTOCOL_MESSAGE_TYPE.AUTHORIZATION_RESPONSE_MESSAGE_TYPE:\n        return this.handleAuthResponse(\n          message as AuthorizationResponseMessage,\n          ctx as AuthRespOptions\n        );\n      default:\n        return super.handle(message, ctx);\n    }\n  }\n\n  /**\n   * @inheritdoc IAuthHandler#parseAuthorizationRequest\n   */\n  async parseAuthorizationRequest(request: Uint8Array): Promise<AuthorizationRequestMessage> {\n    const { unpackedMessage: message } = await this._packerMgr.unpack(request);\n    const authRequest = message as unknown as AuthorizationRequestMessage;\n    if (message.type !== PROTOCOL_MESSAGE_TYPE.AUTHORIZATION_REQUEST_MESSAGE_TYPE) {\n      throw new Error('Invalid media type');\n    }\n    authRequest.body.scope = authRequest.body.scope || [];\n    return authRequest;\n  }\n\n  private async handleAuthRequest(\n    authRequest: AuthorizationRequestMessage,\n    ctx: AuthReqOptions\n  ): Promise<AuthorizationResponseMessage> {\n    if (authRequest.type !== PROTOCOL_MESSAGE_TYPE.AUTHORIZATION_REQUEST_MESSAGE_TYPE) {\n      throw new Error('Invalid message type for authorization request');\n    }\n    // override sender did if it's explicitly specified in the auth request\n    const to = authRequest.to ? DID.parse(authRequest.to) : ctx.senderDid;\n    const guid = uuid.v4();\n\n    if (!authRequest.from) {\n      throw new Error('auth request should contain from field');\n    }\n\n    const responseType = PROTOCOL_MESSAGE_TYPE.AUTHORIZATION_RESPONSE_MESSAGE_TYPE;\n    const mediaType = this.getSupportedMediaTypeByProfile(\n      ctx,\n      responseType,\n      authRequest.body.accept\n    );\n    const from = DID.parse(authRequest.from);\n\n    const responseScope = await processZeroKnowledgeProofRequests(\n      to,\n      authRequest?.body.scope,\n      from,\n      this._proofService,\n      { mediaType, supportedCircuits: this._supportedCircuits }\n    );\n\n    return {\n      id: guid,\n      typ: mediaType,\n      type: responseType,\n      thid: authRequest.thid ?? guid,\n      body: {\n        message: authRequest?.body?.message,\n        scope: responseScope\n      },\n      from: to.string(),\n      to: authRequest.from\n    };\n  }\n\n  /**\n   * @inheritdoc IAuthHandler#handleAuthorizationRequest\n   */\n  async handleAuthorizationRequest(\n    did: DID,\n    request: Uint8Array,\n    opts?: AuthHandlerOptions\n  ): Promise<{\n    token: string;\n    authRequest: AuthorizationRequestMessage;\n    authResponse: AuthorizationResponseMessage;\n  }> {\n    const authRequest = await this.parseAuthorizationRequest(request);\n    if (!opts?.allowExpiredMessages) {\n      verifyExpiresTime(authRequest);\n    }\n    if (!opts) {\n      opts = {\n        mediaType: MediaType.ZKPMessage\n      };\n    }\n\n    if (opts.mediaType === MediaType.SignedMessage && !opts.packerOptions) {\n      throw new Error(`jws packer options are required for ${MediaType.SignedMessage}`);\n    }\n\n    const authResponse = await this.handleAuthRequest(authRequest, {\n      senderDid: did,\n      mediaType: opts.mediaType\n    });\n\n    const msgBytes = byteEncoder.encode(JSON.stringify(authResponse));\n\n    const packerOpts =\n      opts.mediaType === MediaType.SignedMessage\n        ? opts.packerOptions\n        : {\n            provingMethodAlg: proving.provingMethodGroth16AuthV2Instance.methodAlg\n          };\n\n    const token = byteDecoder.decode(\n      await this._packerMgr.pack(opts.mediaType, msgBytes, {\n        senderDID: did,\n        ...packerOpts\n      })\n    );\n\n    return { authRequest, authResponse, token };\n  }\n\n  private async handleAuthResponse(\n    response: AuthorizationResponseMessage,\n    ctx: AuthRespOptions\n  ): Promise<BasicMessage | null> {\n    const request = ctx.request;\n    if (response.type !== PROTOCOL_MESSAGE_TYPE.AUTHORIZATION_RESPONSE_MESSAGE_TYPE) {\n      throw new Error('Invalid message type for authorization response');\n    }\n    if ((request.body.message ?? '') !== (response.body.message ?? '')) {\n      throw new Error('message for signing from request is not presented in response');\n    }\n\n    if (request.from !== response.to) {\n      throw new Error(\n        `sender of the request is not a target of response - expected ${request.from}, given ${response.to}`\n      );\n    }\n\n    this.verifyAuthRequest(request);\n    const requestScope = request.body.scope || [];\n    const responseScope = response.body.scope || [];\n\n    if (!response.from) {\n      throw new Error(`proof response doesn't contain from field`);\n    }\n\n    const groupIdToLinkIdMap = new Map<number, { linkID: number; requestId: number | string }[]>();\n    // group requests by query group id\n    for (const proofRequest of requestScope) {\n      const groupId = proofRequest.query.groupId as number;\n\n      const proofResp = responseScope.find(\n        (resp) => resp.id.toString() === proofRequest.id.toString()\n      );\n      if (!proofResp) {\n        throw new Error(`proof is not given for requestId ${proofRequest.id}`);\n      }\n\n      const circuitId = proofResp.circuitId;\n      if (circuitId !== proofRequest.circuitId) {\n        throw new Error(\n          `proof is not given for requested circuit expected: ${proofRequest.circuitId}, given ${circuitId}`\n        );\n      }\n\n      const params: JSONObject = proofRequest.params ?? {};\n      params.verifierDid = DID.parse(request.from);\n\n      const opts = [ctx.acceptedProofGenerationDelay, ctx.acceptedStateTransitionDelay].some(\n        (delay) => delay !== undefined\n      )\n        ? {\n            acceptedProofGenerationDelay: ctx.acceptedProofGenerationDelay,\n            acceptedStateTransitionDelay: ctx.acceptedStateTransitionDelay\n          }\n        : undefined;\n\n      const { linkID } = await this._proofService.verifyZKPResponse(proofResp, {\n        query: proofRequest.query as unknown as ProofQuery,\n        sender: response.from,\n        params,\n        opts\n      });\n      // write linkId to the proof response\n      // const pubSig = pubSignals as unknown as { linkID?: number };\n\n      if (linkID && groupId) {\n        groupIdToLinkIdMap.set(groupId, [\n          ...(groupIdToLinkIdMap.get(groupId) ?? []),\n          { linkID: linkID, requestId: proofResp.id }\n        ]);\n      }\n    }\n\n    // verify grouping links\n    for (const [groupId, metas] of groupIdToLinkIdMap.entries()) {\n      // check that all linkIds are the same\n      if (metas.some((meta) => meta.linkID !== metas[0].linkID)) {\n        throw new Error(\n          `Link id validation failed for group ${groupId}, request linkID to requestIds info: ${JSON.stringify(\n            metas\n          )}`\n        );\n      }\n    }\n\n    return response;\n  }\n\n  /**\n   * @inheritdoc IAuthHandler#handleAuthorizationResponse\n   */\n  async handleAuthorizationResponse(\n    response: AuthorizationResponseMessage,\n    request: AuthorizationRequestMessage,\n    opts?: AuthResponseHandlerOptions | undefined\n  ): Promise<{\n    request: AuthorizationRequestMessage;\n    response: AuthorizationResponseMessage;\n  }> {\n    if (!opts?.allowExpiredMessages) {\n      verifyExpiresTime(response);\n    }\n    const authResp = (await this.handleAuthResponse(response, {\n      request,\n      acceptedStateTransitionDelay: opts?.acceptedStateTransitionDelay,\n      acceptedProofGenerationDelay: opts?.acceptedProofGenerationDelay\n    })) as AuthorizationResponseMessage;\n\n    return { request, response: authResp };\n  }\n\n  private verifyAuthRequest(request: AuthorizationRequestMessage) {\n    const groupIdValidationMap: { [k: string]: ZeroKnowledgeProofRequest[] } = {};\n    const requestScope = request.body.scope || [];\n    for (const proofRequest of requestScope) {\n      const groupId = proofRequest.query.groupId as number;\n      if (groupId) {\n        const existingRequests = groupIdValidationMap[groupId] ?? [];\n\n        //validate that all requests in the group have the same schema, issuer and circuit\n        for (const existingRequest of existingRequests) {\n          if (existingRequest.query.type !== proofRequest.query.type) {\n            throw new Error(`all requests in the group should have the same type`);\n          }\n\n          if (existingRequest.query.context !== proofRequest.query.context) {\n            throw new Error(`all requests in the group should have the same context`);\n          }\n\n          const allowedIssuers = proofRequest.query.allowedIssuers as string[];\n          const existingRequestAllowedIssuers = existingRequest.query.allowedIssuers as string[];\n          if (\n            !(\n              allowedIssuers.includes('*') ||\n              allowedIssuers.every((issuer) => existingRequestAllowedIssuers.includes(issuer))\n            )\n          ) {\n            throw new Error(`all requests in the group should have the same issuer`);\n          }\n        }\n        groupIdValidationMap[groupId] = [...(groupIdValidationMap[groupId] ?? []), proofRequest];\n      }\n    }\n  }\n\n  private getSupportedMediaTypeByProfile(\n    ctx: AuthReqOptions,\n    responseType: string,\n    profile?: string[] | undefined\n  ): MediaType {\n    let mediaType: MediaType;\n    if (!profile?.length) {\n      return ctx.mediaType || MediaType.ZKPMessage;\n    }\n    const supportedMediaTypes: MediaType[] = [];\n    for (const acceptProfile of profile) {\n      const { env } = parseAcceptProfile(acceptProfile);\n      if (this._packerMgr.isProfileSupported(env, acceptProfile)) {\n        supportedMediaTypes.push(env);\n      }\n    }\n\n    if (!supportedMediaTypes.length) {\n      throw new Error('no packer with profile which meets `accept` header requirements');\n    }\n\n    mediaType = supportedMediaTypes.includes(MediaType.ZKPMessage)\n      ? MediaType.ZKPMessage\n      : supportedMediaTypes[0];\n    if (ctx.mediaType && supportedMediaTypes.includes(ctx.mediaType)) {\n      mediaType = ctx.mediaType;\n    }\n    return mediaType;\n  }\n}\n","import { getRandomBytes } from '@iden3/js-crypto';\nimport {\n  AcceptProfile,\n  AuthMethod,\n  AuthProof,\n  BasicMessage,\n  JsonDocumentObject,\n  JWSPackerParams,\n  ZeroKnowledgeProofAuthResponse,\n  ZeroKnowledgeProofQuery,\n  ZeroKnowledgeProofRequest,\n  ZeroKnowledgeProofResponse\n} from '../types';\nimport { mergeObjects } from '../../utils';\nimport { RevocationStatus, VerifiableConstants, W3CCredential } from '../../verifiable';\nimport { DID, getUnixTimestamp } from '@iden3/js-iden3-core';\nimport { IProofService } from '../../proof';\nimport { CircuitId } from '../../circuits';\nimport { AcceptJwsAlgorithms, defaultAcceptProfile, MediaType } from '../constants';\nimport { ethers, Signer } from 'ethers';\nimport { packZkpProof, prepareZkpProof } from '../../storage/blockchain/common';\n\n/**\n * Groups the ZeroKnowledgeProofRequest objects based on their groupId.\n * Returns a Map where the key is the groupId and the value is an object containing the query and linkNonce.\n *\n * @param requestScope - An array of ZeroKnowledgeProofRequest objects.\n * @returns A Map<number, { query: ZeroKnowledgeProofQuery; linkNonce: number }> representing the grouped queries.\n */\nconst getGroupedQueries = (\n  requestScope: ZeroKnowledgeProofRequest[]\n): Map<number, { query: ZeroKnowledgeProofQuery; linkNonce: number }> =>\n  requestScope.reduce((acc, proofReq) => {\n    const groupId = proofReq.query.groupId as number | undefined;\n    if (!groupId) {\n      return acc;\n    }\n\n    const existedData = acc.get(groupId);\n    if (!existedData) {\n      const seed = getRandomBytes(12);\n      const dataView = new DataView(seed.buffer);\n      const linkNonce = dataView.getUint32(0);\n      acc.set(groupId, { query: proofReq.query, linkNonce });\n      return acc;\n    }\n\n    const credentialSubject = mergeObjects(\n      existedData.query.credentialSubject as JsonDocumentObject,\n      proofReq.query.credentialSubject as JsonDocumentObject\n    );\n\n    acc.set(groupId, {\n      ...existedData,\n      query: {\n        skipClaimRevocationCheck:\n          existedData.query.skipClaimRevocationCheck || proofReq.query.skipClaimRevocationCheck,\n        ...existedData.query,\n        credentialSubject\n      }\n    });\n\n    return acc;\n  }, new Map<number, { query: ZeroKnowledgeProofQuery; linkNonce: number }>());\n\n/**\n * Processes zero knowledge proof requests.\n *\n * @param to - The identifier of the recipient.\n * @param requests - An array of zero knowledge proof requests.\n * @param from - The identifier of the sender.\n * @param proofService - The proof service.\n * @param opts - Additional options for processing the requests.\n * @returns A promise that resolves to an array of zero knowledge proof responses.\n */\nexport const processZeroKnowledgeProofRequests = async (\n  to: DID,\n  requests: ZeroKnowledgeProofRequest[] | undefined,\n  from: DID | undefined,\n  proofService: IProofService,\n  opts: {\n    mediaType?: MediaType;\n    packerOptions?: JWSPackerParams;\n    supportedCircuits: CircuitId[];\n    ethSigner?: Signer;\n    challenge?: bigint;\n  }\n): Promise<ZeroKnowledgeProofResponse[]> => {\n  const requestScope = requests ?? [];\n\n  const combinedQueries = getGroupedQueries(requestScope);\n\n  const groupedCredentialsCache = new Map<\n    number,\n    { cred: W3CCredential; revStatus?: RevocationStatus }\n  >();\n\n  const zkpResponses = [];\n\n  for (const proofReq of requestScope) {\n    let zkpRes: ZeroKnowledgeProofResponse;\n    try {\n      const isCircuitSupported = opts.supportedCircuits.includes(proofReq.circuitId as CircuitId);\n      if (!isCircuitSupported) {\n        if (proofReq.optional) {\n          continue;\n        }\n        throw new Error(`Circuit ${proofReq.circuitId} is not allowed`);\n      }\n\n      const query = proofReq.query;\n      const groupId = query.groupId as number | undefined;\n      const combinedQueryData = combinedQueries.get(groupId as number);\n\n      if (groupId) {\n        if (!combinedQueryData) {\n          throw new Error(`Invalid group id ${query.groupId}`);\n        }\n        const combinedQuery = combinedQueryData.query;\n\n        if (!groupedCredentialsCache.has(groupId)) {\n          const credWithRevStatus = await proofService.findCredentialByProofQuery(\n            to,\n            combinedQueryData.query\n          );\n          if (!credWithRevStatus.cred) {\n            if (proofReq.optional) {\n              continue;\n            }\n            throw new Error(\n              VerifiableConstants.ERRORS.PROOF_SERVICE_NO_CREDENTIAL_FOR_QUERY +\n                `${JSON.stringify(combinedQuery)}`\n            );\n          }\n\n          groupedCredentialsCache.set(groupId, credWithRevStatus);\n        }\n      }\n\n      const credWithRevStatus = groupedCredentialsCache.get(groupId as number);\n      zkpRes = await proofService.generateProof(proofReq, to, {\n        verifierDid: from,\n        challenge: opts.challenge,\n        skipRevocation: Boolean(query.skipClaimRevocationCheck),\n        credential: credWithRevStatus?.cred,\n        credentialRevocationStatus: credWithRevStatus?.revStatus,\n        linkNonce: combinedQueryData?.linkNonce ? BigInt(combinedQueryData.linkNonce) : undefined\n      });\n    } catch (error: unknown) {\n      const expectedErrors = [\n        VerifiableConstants.ERRORS.PROOF_SERVICE_NO_CREDENTIAL_FOR_IDENTITY_OR_PROFILE,\n        VerifiableConstants.ERRORS.ID_WALLET_NO_CREDENTIAL_SATISFIED_QUERY,\n        VerifiableConstants.ERRORS.CREDENTIAL_WALLET_ALL_CREDENTIALS_ARE_REVOKED\n      ];\n      // handle only errors in case credential is not found and it is optional proof request - otherwise throw\n      if (\n        error instanceof Error &&\n        (expectedErrors.includes(error.message) ||\n          error.message.includes(\n            VerifiableConstants.ERRORS.PROOF_SERVICE_NO_CREDENTIAL_FOR_QUERY\n          )) &&\n        proofReq.optional\n      ) {\n        continue;\n      }\n      throw error;\n    }\n\n    zkpResponses.push(zkpRes);\n  }\n\n  return zkpResponses;\n};\n\n/**\n * Processes auth proof requests.\n *\n * @param to - The identifier of the recipient.\n * @param proofService - The proof service.\n * @param opts - Additional options for processing the requests.\n * @returns A promise that resolves to an auth proof response.\n */\nexport const processProofAuth = async (\n  to: DID,\n  proofService: IProofService,\n  opts: {\n    supportedCircuits: CircuitId[];\n    acceptProfile?: AcceptProfile;\n    senderAddress: string;\n    zkpResponses: ZeroKnowledgeProofResponse[];\n  }\n): Promise<{ authProof: AuthProof }> => {\n  if (!opts.acceptProfile) {\n    opts.acceptProfile = defaultAcceptProfile;\n  }\n\n  switch (opts.acceptProfile.env) {\n    case MediaType.ZKPMessage:\n      if (!opts.acceptProfile.circuits) {\n        throw new Error('Circuit not specified in accept profile');\n      }\n\n      for (const circuitId of opts.acceptProfile.circuits) {\n        if (!opts.supportedCircuits.includes(circuitId as unknown as CircuitId)) {\n          throw new Error(`Circuit ${circuitId} is not supported`);\n        }\n        if (!opts.senderAddress) {\n          throw new Error('Sender address is not provided');\n        }\n        const challengeAuth = calcChallengeAuthV2(opts.senderAddress, opts.zkpResponses);\n\n        const zkpRes: ZeroKnowledgeProofAuthResponse = await proofService.generateAuthProof(\n          circuitId as unknown as CircuitId,\n          to,\n          { challenge: challengeAuth }\n        );\n        return {\n          authProof: {\n            authMethod: AuthMethod.AUTHV2,\n            zkp: zkpRes\n          }\n        };\n      }\n      throw new Error(`Auth method is not supported`);\n    case MediaType.SignedMessage:\n      if (!opts.acceptProfile.alg || opts.acceptProfile.alg.length === 0) {\n        throw new Error('Algorithm not specified');\n      }\n      if (opts.acceptProfile.alg[0] === AcceptJwsAlgorithms.ES256KR) {\n        return {\n          authProof: {\n            authMethod: AuthMethod.ETH_IDENTITY,\n            userDid: to\n          }\n        };\n      }\n      throw new Error(`Algorithm ${opts.acceptProfile.alg[0]} not supported`);\n    default:\n      throw new Error('Accept env not supported');\n  }\n};\n\n/**\n * Processes a ZeroKnowledgeProofResponse object and prepares it for further use.\n * @param zkProof - The ZeroKnowledgeProofResponse object containing the proof data.\n * @returns An object containing the requestId, zkProofEncoded, and metadata.\n */\nexport const processProofResponse = (zkProof: ZeroKnowledgeProofResponse) => {\n  const requestId = zkProof.id;\n  const inputs = zkProof.pub_signals;\n  const emptyBytes = '0x';\n\n  if (inputs.length === 0) {\n    return { requestId, zkProofEncoded: emptyBytes, metadata: emptyBytes };\n  }\n\n  const preparedZkpProof = prepareZkpProof(zkProof.proof);\n  const zkProofEncoded = packZkpProof(\n    inputs,\n    preparedZkpProof.a,\n    preparedZkpProof.b,\n    preparedZkpProof.c\n  );\n\n  const metadata = emptyBytes;\n\n  return { requestId, zkProofEncoded, metadata };\n};\n\n/**\n * Calculates the challenge authentication V2 value.\n * @param senderAddress - The address of the sender.\n * @param zkpResponses - An array of ZeroKnowledgeProofResponse objects.\n * @returns A bigint representing the challenge authentication value.\n */\nexport const calcChallengeAuthV2 = (\n  senderAddress: string,\n  zkpResponses: ZeroKnowledgeProofResponse[]\n): bigint => {\n  const responses = zkpResponses.map((zkpResponse) => {\n    const response = processProofResponse(zkpResponse);\n    return {\n      requestId: response.requestId,\n      proof: response.zkProofEncoded,\n      metadata: response.metadata\n    };\n  });\n\n  return (\n    BigInt(\n      ethers.keccak256(\n        new ethers.AbiCoder().encode(\n          ['address', '(uint256 requestId,bytes proof,bytes metadata)[]'],\n          [senderAddress, responses]\n        )\n      )\n    ) & BigInt('0x0fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff')\n  );\n};\n\n/**\n * Packs metadata into a string format suitable for encoding in a transaction.\n * @param metas - An array of objects containing key-value pairs to be packed.\n * @returns A string representing the packed metadata.\n */\nexport const packMetadatas = (\n  metas: {\n    key: string;\n    value: Uint8Array;\n  }[]\n): string => {\n  return new ethers.AbiCoder().encode(['tuple(' + 'string key,' + 'bytes value' + ')[]'], [metas]);\n};\n\n/**\n * Verifies that the expires_time field of a message is not in the past. Throws an error if it is.\n *\n * @param message - Basic message to verify.\n */\nexport const verifyExpiresTime = (message: BasicMessage) => {\n  if (message?.expires_time && message.expires_time < getUnixTimestamp(new Date())) {\n    throw new Error('Message expired');\n  }\n};\n","import { BasicMessage, IPackageManager } from '../types';\nimport { AuthMessageHandlerOptions } from './auth';\nimport { RevocationStatusMessageHandlerOptions } from './revocation-status';\nimport { ContractMessageHandlerOptions } from './contract-request';\nimport { PaymentHandlerOptions, PaymentRequestMessageHandlerOptions } from './payment';\nimport { MediaType } from '../constants';\nimport { proving } from '@iden3/js-jwz';\nimport { DID } from '@iden3/js-iden3-core';\nimport { verifyExpiresTime } from './common';\n\n/**\n * iden3 Basic protocol message handler options\n */\nexport type BasicHandlerOptions = {\n  allowExpiredMessages?: boolean;\n};\n\n/**\n * iden3  Protocol message handler interface\n */\nexport interface IProtocolMessageHandler {\n  /**\n   * Handel message implementation\n   *\n   * @param {BasicMessage} message\n   * @param {{ [key: string]: unknown }} ctx context\n   * @returns {(Promise<BasicMessage | null>)}\n   * @memberof IProtocolMessageHandler\n   */\n  handle(message: BasicMessage, ctx: { [key: string]: unknown }): Promise<BasicMessage | null>;\n}\n\n/**\n * Base implementation of protocol message handler\n *\n * @export\n * @abstract\n * @class AbstractMessageHandler\n * @implements {IProtocolMessageHandler}\n */\nexport abstract class AbstractMessageHandler implements IProtocolMessageHandler {\n  public nextMessageHandler?: AbstractMessageHandler;\n\n  public setNext(messageHandler: AbstractMessageHandler): AbstractMessageHandler {\n    this.nextMessageHandler = messageHandler;\n    return messageHandler;\n  }\n\n  public async handle(\n    message: BasicMessage,\n    context: { [key: string]: unknown }\n  ): Promise<BasicMessage | null> {\n    if (!context.allowExpiredMessages) {\n      verifyExpiresTime(message);\n    }\n    if (this.nextMessageHandler) return this.nextMessageHandler.handle(message, context);\n    return Promise.reject('Message handler not provided or message not supported');\n  }\n}\n\n/**\n * Protocol message handler entry point\n */\nexport class MessageHandler {\n  private messageHandler?: AbstractMessageHandler;\n\n  /**\n   * Creates an instance of MessageHandler.\n   * @param {{\n   *       messageHandlers: AbstractMessageHandler[];\n   *       packageManager: IPackageManager;\n   *     }} _params\n   * @memberof MessageHandler\n   */\n  constructor(\n    private readonly _params: {\n      messageHandlers: AbstractMessageHandler[];\n      packageManager: IPackageManager;\n    }\n  ) {\n    this.registerHandlers(_params.messageHandlers);\n  }\n\n  /**\n   * Registers a list of message handlers and sets up the chain of responsibility.\n   *\n   * This method takes an array of `AbstractMessageHandler` instances and sets up a chain of responsibility\n   * where each handler is linked to the next one in the array. The first handler in the array becomes the\n   * main message handler for the `MessageHandler` class.\n   *\n   * @param {AbstractMessageHandler[]} handlersList - An array of `AbstractMessageHandler` instances to be registered.\n   * @returns {void}\n   */\n  public registerHandlers(handlersList: AbstractMessageHandler[]): void {\n    if (!handlersList.length) return;\n\n    const [firstMessageHandler, ...restHandlersList] = handlersList;\n\n    const tempHandler = firstMessageHandler;\n    for (const currentHandler of restHandlersList) {\n      let lastHandler = tempHandler;\n      while (lastHandler.nextMessageHandler) {\n        lastHandler = lastHandler.nextMessageHandler;\n      }\n      lastHandler.setNext(currentHandler);\n    }\n\n    if (!this.messageHandler) {\n      this.messageHandler = firstMessageHandler;\n    } else {\n      this.messageHandler.setNext(firstMessageHandler);\n    }\n  }\n\n  /**\n   * Handles a message by unpacking it, passing it to the registered message handler, and packing the response.\n   *\n   * This method takes a Uint8Array of message bytes and a context object that contains information specific to the\n   * type of message being handled (e.g. AuthMessageHandlerOptions, ContractMessageHandlerOptions, etc.).\n   *\n   * The method first unpacks the message using the provided package manager, then passes the unpacked message and\n   * context to the registered message handler. If the message handler returns a response, the method packs the\n   * response using the package manager and returns it. If the message handler does not return a response, the\n   * method returns null.\n   *\n   * @param bytes - A Uint8Array of message bytes to be handled.\n   * @param context - An object containing information specific to the type of message being handled.\n   * @returns A Promise that resolves to a Uint8Array of the packed response, or null if no response was generated.\n   */\n  public async handleMessage(\n    bytes: Uint8Array,\n    context:\n      | AuthMessageHandlerOptions\n      | ContractMessageHandlerOptions\n      | RevocationStatusMessageHandlerOptions\n      | PaymentRequestMessageHandlerOptions\n      | PaymentHandlerOptions\n      | { senderDid?: DID; [key: string]: unknown }\n  ): Promise<Uint8Array | null> {\n    const { unpackedMediaType, unpackedMessage: message } =\n      await this._params.packageManager.unpack(bytes);\n\n    if (!this.messageHandler) {\n      return Promise.reject(new Error('Message handler not provided'));\n    }\n\n    const response = await this.messageHandler.handle(message, context);\n\n    if (!response) {\n      return null;\n    }\n\n    let packerParams = {};\n    const senderDid = (context as { senderDid?: DID })?.senderDid;\n    if (unpackedMediaType === MediaType.ZKPMessage && senderDid) {\n      packerParams = {\n        senderDID: senderDid,\n        provingMethodAlg: proving.provingMethodGroth16AuthV2Instance.methodAlg\n      };\n      return this._params.packageManager.packMessage(unpackedMediaType, response, packerParams);\n    }\n\n    return this._params.packageManager.packMessage(MediaType.PlainMessage, response, packerParams);\n  }\n}\n","import { RevocationStatus, Issuer } from '../../verifiable';\nimport { Contract, JsonRpcProvider, Signer, TransactionReceipt, TransactionRequest } from 'ethers';\nimport { Proof, NodeAuxJSON, Hash } from '@iden3/js-merkletree';\nimport { EthConnectionConfig } from './state';\nimport abi from '../blockchain/abi/CredentialStatusResolver.json';\nimport { ITransactionService, TransactionService } from '../../blockchain';\n\n/**\n * OnChainRevocationStore is a class that allows to interact with the onchain contract\n * and build the revocation status.\n *\n * @public\n * @class OnChainIssuer\n */\nexport class OnChainRevocationStorage {\n  private readonly _contract: Contract;\n  private readonly _provider: JsonRpcProvider;\n  private readonly _transactionService: ITransactionService;\n\n  /**\n   *\n   * Creates an instance of OnChainIssuer.\n   * @public\n   * @param {string} - onchain contract address\n   * @param {string} - rpc url to connect to the blockchain\n   */\n\n  constructor(\n    private readonly _config: EthConnectionConfig,\n    contractAddress: string,\n    private _signer?: Signer\n  ) {\n    this._provider = new JsonRpcProvider(_config.url);\n    let contract = new Contract(contractAddress, abi, this._provider);\n    if (this._signer) {\n      this._signer = this._signer.connect(this._provider);\n      contract = contract.connect(this._signer) as Contract;\n    }\n    this._contract = contract;\n    this._transactionService = new TransactionService(this._provider);\n  }\n\n  /**\n   * Get revocation status by issuerId, issuerState and nonce from the onchain.\n   * @public\n   * @returns Promise<RevocationStatus>\n   */\n  public async getRevocationStatusByIdAndState(\n    issuerID: bigint,\n    state: bigint,\n    nonce: number\n  ): Promise<RevocationStatus> {\n    const response = await this._contract.getRevocationStatusByIdAndState(issuerID, state, nonce);\n\n    const issuer = OnChainRevocationStorage.convertIssuerInfo(response.issuer);\n    const mtp = OnChainRevocationStorage.convertSmtProofToProof(response.mtp);\n\n    return {\n      issuer,\n      mtp\n    };\n  }\n\n  /**\n   * Get revocation status by nonce from the onchain contract.\n   * @public\n   * @returns Promise<RevocationStatus>\n   */\n  public async getRevocationStatus(issuerID: bigint, nonce: number): Promise<RevocationStatus> {\n    const response = await this._contract.getRevocationStatus(issuerID, nonce);\n\n    const issuer = OnChainRevocationStorage.convertIssuerInfo(response.issuer);\n    const mtp = OnChainRevocationStorage.convertSmtProofToProof(response.mtp);\n\n    return {\n      issuer,\n      mtp\n    };\n  }\n\n  public async saveNodes(payload: bigint[][]): Promise<TransactionReceipt> {\n    if (!this._signer) {\n      throw new Error('No signer provided');\n    }\n    const feeData = await this._provider.getFeeData();\n\n    const maxFeePerGas = this._config.maxFeePerGas\n      ? BigInt(this._config.maxFeePerGas)\n      : feeData.maxFeePerGas;\n    const maxPriorityFeePerGas = this._config.maxPriorityFeePerGas\n      ? BigInt(this._config.maxPriorityFeePerGas)\n      : feeData.maxPriorityFeePerGas;\n\n    const gasLimit = await this._contract.saveNodes.estimateGas(payload);\n    const txData = await this._contract.saveNodes.populateTransaction(payload);\n\n    const request: TransactionRequest = {\n      to: txData.to,\n      data: txData.data,\n      gasLimit,\n      maxFeePerGas,\n      maxPriorityFeePerGas\n    };\n\n    const { txnReceipt } = await this._transactionService.sendTransactionRequest(\n      this._signer,\n      request\n    );\n    return txnReceipt;\n  }\n\n  private static convertIssuerInfo(issuer: bigint[]): Issuer {\n    const [state, claimsTreeRoot, revocationTreeRoot, rootOfRoots] = issuer.map((i) =>\n      Hash.fromBigInt(i).hex()\n    );\n    return {\n      state,\n      claimsTreeRoot,\n      revocationTreeRoot,\n      rootOfRoots\n    };\n  }\n\n  private static convertSmtProofToProof(mtp: {\n    existence: boolean;\n    auxIndex: bigint;\n    auxValue: bigint;\n    auxExistence: boolean;\n    siblings: bigint[];\n  }): Proof {\n    let nodeAux: NodeAuxJSON | undefined = undefined;\n    const siblings = mtp.siblings?.map((s) => s.toString());\n\n    if (mtp.auxExistence) {\n      nodeAux = {\n        key: mtp.auxIndex.toString(),\n        value: mtp.auxValue.toString()\n      };\n    }\n\n    return Proof.fromJSON({ existence: mtp.existence, node_aux: nodeAux, siblings });\n  }\n}\n","[{\"inputs\":[],\"name\":\"MAX_SMT_DEPTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"key\",\"type\":\"uint256\"}],\"name\":\"getNode\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"name\":\"getRevocationStatus\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"state\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimsTreeRoot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revocationTreeRoot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rootOfRoots\",\"type\":\"uint256\"}],\"internalType\":\"struct IOnchainCredentialStatusResolver.IdentityStateRoots\",\"name\":\"issuer\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"root\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"existence\",\"type\":\"bool\"},{\"internalType\":\"uint256[]\",\"name\":\"siblings\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"auxExistence\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"auxIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auxValue\",\"type\":\"uint256\"}],\"internalType\":\"struct IOnchainCredentialStatusResolver.Proof\",\"name\":\"mtp\",\"type\":\"tuple\"}],\"internalType\":\"struct IOnchainCredentialStatusResolver.CredentialStatus\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"state\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"name\":\"getRevocationStatusByIdAndState\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"state\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimsTreeRoot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revocationTreeRoot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rootOfRoots\",\"type\":\"uint256\"}],\"internalType\":\"struct IOnchainCredentialStatusResolver.IdentityStateRoots\",\"name\":\"issuer\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"root\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"existence\",\"type\":\"bool\"},{\"internalType\":\"uint256[]\",\"name\":\"siblings\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"auxExistence\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"auxIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auxValue\",\"type\":\"uint256\"}],\"internalType\":\"struct IOnchainCredentialStatusResolver.Proof\",\"name\":\"mtp\",\"type\":\"tuple\"}],\"internalType\":\"struct IOnchainCredentialStatusResolver.CredentialStatus\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[][]\",\"name\":\"nodes\",\"type\":\"uint256[][]\"}],\"name\":\"saveNodes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]\n","import { RevocationStatus, CredentialStatus } from '../../verifiable';\nimport { EthConnectionConfig } from '../../storage/blockchain';\nimport { CredentialStatusResolver, CredentialStatusResolveOptions } from './resolver';\nimport { OnChainRevocationStorage } from '../../storage/blockchain/onchain-revocation';\nimport { DID } from '@iden3/js-iden3-core';\nimport { VerifiableConstants } from '../../verifiable/constants';\nimport { isGenesisState } from '../../utils';\nimport { EthStateStorage, EthStateStorageOptions } from '../../storage/blockchain/state';\nimport { IStateStorage, IOnchainRevocationStore } from '../../storage';\nimport { Hash } from '@iden3/js-merkletree';\n\n/*\n * Options for OnChainResolver\n *\n * @public\n * @typedef {Object} OnChainResolverOptions\n * @property {EthStateStorageOptions} [stateStorageOptions] - options for state storage\n */\nexport type OnChainResolverOptions = {\n  stateStorageOptions?: EthStateStorageOptions;\n};\n\n/**\n * OnChainIssuer is a class that allows to interact with the onchain contract\n * and build the revocation status.\n *\n * @public\n * @class OnChainIssuer\n */\nexport class OnChainResolver implements CredentialStatusResolver {\n  private readonly _stateStorage: IStateStorage;\n  /**\n   *\n   * Creates an instance of OnChainIssuer.\n   * @public\n   * @param {Array<EthConnectionConfig>} _configs - list of ethereum network connections\n   */\n  constructor(private readonly _configs: EthConnectionConfig[], _opts?: OnChainResolverOptions) {\n    this._stateStorage = new EthStateStorage(_configs, _opts?.stateStorageOptions);\n  }\n\n  /**\n   * resolve is a method to resolve a credential status from the blockchain.\n   *\n   * @public\n   * @param {CredentialStatus} credentialStatus -  credential status to resolve\n   * @param {CredentialStatusResolveOptions} credentialStatusResolveOptions -  options for resolver\n   * @returns `{Promise<RevocationStatus>}`\n   */\n  async resolve(\n    credentialStatus: CredentialStatus,\n    credentialStatusResolveOptions?: CredentialStatusResolveOptions\n  ): Promise<RevocationStatus> {\n    if (!credentialStatusResolveOptions?.issuerDID) {\n      throw new Error('IssuerDID is not set in options');\n    }\n    return this.getRevocationOnChain(credentialStatus, credentialStatusResolveOptions.issuerDID);\n  }\n\n  /**\n   * Gets partial revocation status info from onchain issuer contract.\n   *\n   * @param {CredentialStatus} credentialStatus - credential status section of credential\n   * @param {DID} issuerDid - issuer did\n   * @returns `{Promise<RevocationStatus>}`\n   */\n  async getRevocationOnChain(\n    credentialStatus: CredentialStatus,\n    issuer: DID\n  ): Promise<RevocationStatus> {\n    const { contractAddress, chainId, revocationNonce, stateHex } =\n      this.extractCredentialStatusInfo(credentialStatus);\n    if (revocationNonce !== credentialStatus.revocationNonce) {\n      throw new Error('revocationNonce does not match');\n    }\n\n    const issuerId = DID.idFromDID(issuer);\n    let latestIssuerState: bigint;\n    try {\n      const latestStateInfo = await this._stateStorage.getLatestStateById(issuerId.bigInt());\n      if (!latestStateInfo.state) {\n        throw new Error('state contract returned empty state');\n      }\n      latestIssuerState = latestStateInfo.state;\n    } catch (e) {\n      const errMsg = (e as { reason: string })?.reason ?? (e as Error).message ?? (e as string);\n      if (!errMsg.includes(VerifiableConstants.ERRORS.IDENTITY_DOES_NOT_EXIST)) {\n        throw e;\n      }\n\n      if (!stateHex) {\n        throw new Error(\n          'latest state not found and state parameter is not present in credentialStatus.id'\n        );\n      }\n      const stateBigInt = Hash.fromHex(stateHex).bigInt();\n      if (!isGenesisState(issuer, stateBigInt)) {\n        throw new Error(\n          `latest state not found and state parameter ${stateHex} is not genesis state`\n        );\n      }\n      latestIssuerState = stateBigInt;\n    }\n\n    const id = DID.idFromDID(issuer);\n    const onChainCaller = this._getOnChainRevocationStorageForIssuer(chainId, contractAddress);\n    const revocationStatus = await onChainCaller.getRevocationStatusByIdAndState(\n      id.bigInt(),\n      latestIssuerState,\n      revocationNonce\n    );\n    return revocationStatus;\n  }\n\n  /**\n   * Extract information about credential status\n   *\n   * @param {credentialStatus} CredentialStatus - credential status\n   * @returns {{contractAddress: string, chainId: number, revocationNonce: number, issuer: string;}}\n   */\n  extractCredentialStatusInfo(credentialStatus: CredentialStatus): {\n    contractAddress: string;\n    chainId: number;\n    revocationNonce: number;\n    stateHex: string;\n  } {\n    if (!credentialStatus.id) {\n      throw new Error('credentialStatus id is empty');\n    }\n\n    const idParts = credentialStatus.id.split('/');\n    if (idParts.length !== 2) {\n      throw new Error('invalid credentialStatus id');\n    }\n\n    const idURL = new URL(credentialStatus.id);\n    const stateHex = idURL.searchParams.get('state') || '';\n    const contractIdentifier = idURL.searchParams.get('contractAddress');\n    if (!contractIdentifier) {\n      throw new Error('contractAddress not found in credentialStatus.id field');\n    }\n    const parts = contractIdentifier.split(':');\n    if (parts.length != 2) {\n      throw new Error('invalid contract address encoding. should be chainId:contractAddress');\n    }\n    const chainId = parseInt(parts[0], 10);\n    const contractAddress = parts[1];\n\n    // if revocationNonce is not present in id as param, then it should be extract from credentialStatus\n    const rv = idURL.searchParams.get('revocationNonce') || credentialStatus.revocationNonce;\n    if (rv === undefined || rv === null) {\n      throw new Error('revocationNonce not found in credentialStatus id field');\n    }\n    const revocationNonce = typeof rv === 'number' ? rv : parseInt(rv, 10);\n\n    return { contractAddress, chainId, revocationNonce, stateHex };\n  }\n\n  networkByChainId(chainId: number): EthConnectionConfig {\n    const network = this._configs.find((c) => c.chainId === chainId);\n    if (!network) {\n      throw new Error(`chainId \"${chainId}\" not supported`);\n    }\n    return network;\n  }\n\n  private _getOnChainRevocationStorageForIssuer(\n    chainId: number,\n    contractAddress: string\n  ): IOnchainRevocationStore {\n    const networkConfig = this.networkByChainId(chainId);\n    const onChainCaller = new OnChainRevocationStorage(networkConfig, contractAddress);\n    return onChainCaller;\n  }\n}\n","import { buildDIDType, BytesHelper, DID, Id } from '@iden3/js-iden3-core';\n\nimport { Hash, Proof, NodeAux, ZERO_HASH, testBit } from '@iden3/js-merkletree';\nimport { IStateStorage } from '../../storage';\nimport { CredentialStatusResolver, CredentialStatusResolveOptions } from './resolver';\nimport { CredentialStatus, RevocationStatus, State } from '../../verifiable';\nimport { VerifiableConstants, CredentialStatusType } from '../../verifiable/constants';\nimport { isEthereumIdentity, isGenesisState } from '../../utils';\nimport { IssuerResolver } from './sparse-merkle-tree';\n\n/**\n * ProofNode is a partial Reverse Hash Service result\n * it contains the current node hash and its children\n *\n * @public\n * @class ProofNode\n */\nexport class ProofNode {\n  /**\n   *\n   * Creates an instance of ProofNode.\n   * @param {Hash} [hash=ZERO_HASH] - current node hash\n   * @param {Hash[]} [children=[]] -  children of the node\n   */\n  constructor(public hash: Hash = ZERO_HASH, public children: Hash[] = []) {}\n\n  /**\n   * Determination of Node type\n   * Can be: Leaf, Middle or State node\n   *\n   * @returns NodeType\n   */\n  nodeType(): NodeType {\n    if (this.children.length === 2) {\n      return NodeType.Middle;\n    }\n\n    if (this.children.length === 3 && this.children[2].hex() === Hash.fromBigInt(BigInt(1)).hex()) {\n      return NodeType.Leaf;\n    }\n\n    if (this.children.length === 3) {\n      return NodeType.State;\n    }\n\n    return NodeType.Unknown;\n  }\n  /**\n   * JSON Representation of ProofNode with a hex values\n   *\n   * @returns {*} - ProofNode with hexes\n   */\n  toJSON() {\n    return {\n      hash: this.hash.hex(),\n      children: this.children.map((h) => h.hex())\n    };\n  }\n  /**\n   * Creates ProofNode Hashes from hex values\n   *\n   * @static\n   * @param {ProofNodeHex} hexNode\n   * @returns ProofNode\n   */\n  static fromHex(hexNode: ProofNodeHex): ProofNode {\n    return new ProofNode(\n      Hash.fromHex(hexNode.hash),\n      hexNode.children.map((ch) => Hash.fromHex(ch))\n    );\n  }\n}\n\ninterface ProofNodeHex {\n  hash: string;\n  children: string[];\n}\n\ninterface NodeHexResponse {\n  node: ProofNodeHex;\n  status: string;\n}\n\nenum NodeType {\n  Unknown = 0,\n  Middle = 1,\n  Leaf = 2,\n  State = 3\n}\n\n/**\n * RHSResolver is a class that allows to interact with the RHS service to get revocation status.\n *\n * @public\n * @class RHSResolver\n */\nexport class RHSResolver implements CredentialStatusResolver {\n  constructor(private readonly _state: IStateStorage) {}\n\n  /**\n   * resolve is a method to resolve a credential status from the blockchain.\n   *\n   * @public\n   * @param {CredentialStatus} credentialStatus -  credential status to resolve\n   * @param {CredentialStatusResolveOptions} credentialStatusResolveOptions -  options for resolver\n   * @returns `{Promise<RevocationStatus>}`\n   */\n  async resolve(\n    credentialStatus: CredentialStatus,\n    credentialStatusResolveOptions?: CredentialStatusResolveOptions\n  ): Promise<RevocationStatus> {\n    if (!credentialStatusResolveOptions?.issuerDID) {\n      throw new Error('IssuerDID is not set in options');\n    }\n\n    try {\n      return await this.getStatus(\n        credentialStatus,\n        credentialStatusResolveOptions.issuerDID,\n        credentialStatusResolveOptions.issuerData,\n        credentialStatusResolveOptions.issuerGenesisState\n      );\n    } catch (e: unknown) {\n      if (credentialStatus?.statusIssuer?.type === CredentialStatusType.SparseMerkleTreeProof) {\n        try {\n          return await new IssuerResolver().resolve(credentialStatus.statusIssuer);\n        } catch (e) {\n          throw new Error(\n            `can't fetch revocation status from backup endpoint: ${(e as Error)?.message}`\n          );\n        }\n      }\n      throw new Error(`can't fetch revocation status: ${(e as Error)?.message}`);\n    }\n  }\n\n  /**\n   * Gets revocation status from rhs service.\n   * @param {CredentialStatus} credentialStatus\n   * @param {DID} issuerDID\n   * @param {IssuerData} issuerData\n   * @returns Promise<RevocationStatus>\n   */\n  private async getStatus(\n    credentialStatus: CredentialStatus,\n    issuerDID: DID,\n    issuerData?: {\n      state: {\n        rootOfRoots: string;\n        claimsTreeRoot: string;\n        revocationTreeRoot: string;\n        value: string;\n      };\n    },\n    genesisState?: State\n  ): Promise<RevocationStatus> {\n    const issuerId = DID.idFromDID(issuerDID);\n\n    let latestState: bigint;\n    try {\n      const latestStateInfo = await this._state.getLatestStateById(issuerId.bigInt());\n      if (!latestStateInfo.state) {\n        throw new Error('state contract returned empty state');\n      }\n      latestState = latestStateInfo.state;\n    } catch (e) {\n      const errMsg = (e as { reason: string })?.reason ?? (e as Error).message ?? (e as string);\n      if (!errMsg.includes(VerifiableConstants.ERRORS.IDENTITY_DOES_NOT_EXIST)) {\n        throw e;\n      }\n      const stateHex = this.extractState(credentialStatus.id);\n      if (!stateHex) {\n        return this.getRevocationStatusFromIssuerData(issuerDID, issuerData, genesisState);\n      }\n      const currentStateBigInt = Hash.fromHex(stateHex).bigInt();\n\n      const isEthIdentity = isEthereumIdentity(issuerDID);\n\n      if (!isEthIdentity && !isGenesisState(issuerDID, currentStateBigInt)) {\n        throw new Error(\n          `latest state not found and state parameter ${stateHex} is not genesis state`\n        );\n      }\n\n      if (isEthIdentity) {\n        throw new Error(`State must be published for Ethereum based identity`);\n      }\n\n      latestState = currentStateBigInt;\n    }\n\n    const rhsHost = credentialStatus.id.split('/node')[0];\n    const hashedRevNonce = Hash.fromBigInt(BigInt(credentialStatus.revocationNonce ?? 0));\n    const hashedIssuerRoot = Hash.fromBigInt(latestState);\n    return await this.getRevocationStatusFromRHS(hashedRevNonce, hashedIssuerRoot, rhsHost);\n  }\n\n  /**\n   * Extract revocation status from issuer data.\n   * @param {DID} issuerDID\n   * @param {IssuerData} issuerData\n   */\n  private getRevocationStatusFromIssuerData(\n    issuerDID: DID,\n    issuerData?: {\n      state: {\n        rootOfRoots: string;\n        claimsTreeRoot: string;\n        revocationTreeRoot: string;\n        value: string;\n      };\n    },\n    genesisState?: State\n  ): RevocationStatus {\n    if (!!genesisState && isGenesisState(issuerDID, genesisState.value.bigInt())) {\n      return {\n        mtp: new Proof(),\n        issuer: {\n          state: genesisState.value.hex(),\n          revocationTreeRoot: genesisState.revocationTreeRoot.hex(),\n          rootOfRoots: genesisState.rootOfRoots.hex(),\n          claimsTreeRoot: genesisState.claimsTreeRoot.hex()\n        }\n      };\n    }\n\n    // legacy\n    if (!!issuerData && isGenesisState(issuerDID, issuerData.state.value)) {\n      return {\n        mtp: new Proof(),\n        issuer: {\n          state: issuerData.state.value,\n          revocationTreeRoot: issuerData.state.revocationTreeRoot,\n          rootOfRoots: issuerData.state.rootOfRoots,\n          claimsTreeRoot: issuerData.state.claimsTreeRoot\n        }\n      };\n    }\n    throw new Error(`issuer data / genesis state param is empty`);\n  }\n\n  /**\n   * Gets partial revocation status info from rhs service.\n   *\n   * @param {Hash} data - hash to fetch\n   * @param {Hash} issuerRoot - issuer root which is a part of url\n   * @param {string} rhsUrl - base URL for reverse hash service\n   * @returns Promise<RevocationStatus>\n   */\n  private async getRevocationStatusFromRHS(\n    data: Hash,\n    issuerRoot: Hash,\n    rhsUrl: string\n  ): Promise<RevocationStatus> {\n    if (!rhsUrl) throw new Error('HTTP reverse hash service URL is not specified');\n\n    const resp = await fetch(`${rhsUrl}/node/${issuerRoot.hex()}`);\n    const treeRoots = ((await resp.json()) as NodeHexResponse)?.node;\n    if (treeRoots.children.length !== 3) {\n      throw new Error('state should has tree children');\n    }\n\n    const s = issuerRoot.hex();\n    const [cTR, rTR, roTR] = treeRoots.children;\n\n    const rtrHashed = Hash.fromHex(rTR);\n    const nonRevProof = await this.rhsGenerateProof(rtrHashed, data, `${rhsUrl}/node`);\n\n    return {\n      mtp: nonRevProof,\n      issuer: {\n        state: s,\n        claimsTreeRoot: cTR,\n        revocationTreeRoot: rTR,\n        rootOfRoots: roTR\n      }\n    };\n  }\n\n  async rhsGenerateProof(treeRoot: Hash, key: Hash, rhsUrl: string): Promise<Proof> {\n    let existence = false;\n    const siblings: Hash[] = [];\n    let nodeAux: NodeAux;\n\n    const mkProof = () => new Proof({ siblings, existence, nodeAux });\n\n    let nextKey = treeRoot;\n    for (let depth = 0; depth < key.bytes.length * 8; depth++) {\n      if (nextKey.bytes.every((i) => i === 0)) {\n        return mkProof();\n      }\n      const data = await fetch(`${rhsUrl}/${nextKey.hex()}`);\n      const resp = ((await data.json()) as NodeHexResponse)?.node;\n\n      const n = ProofNode.fromHex(resp);\n      switch (n.nodeType()) {\n        case NodeType.Leaf:\n          if (key.bytes.every((b, index) => b === n.children[0].bytes[index])) {\n            existence = true;\n            return mkProof();\n          }\n          // We found a leaf whose entry didn't match hIndex\n          nodeAux = {\n            key: n.children[0],\n            value: n.children[1]\n          };\n          return mkProof();\n        case NodeType.Middle:\n          if (testBit(key.bytes, depth)) {\n            nextKey = n.children[1];\n            siblings.push(n.children[0]);\n          } else {\n            nextKey = n.children[0];\n            siblings.push(n.children[1]);\n          }\n          break;\n        default:\n          throw new Error(`found unexpected node type in tree ${n.hash.hex()}`);\n      }\n    }\n\n    throw new Error('tree depth is too high');\n  }\n\n  /**\n   * Get state param from rhs url\n   * @param {string} id\n   * @returns string | null\n   */\n  private extractState(id: string): string | null {\n    const u = new URL(id);\n    return u.searchParams.get('state');\n  }\n}\n\n/**\n * @deprecated The method should not be used. Use isGenesisState instead.\n * Checks if issuer did is created from given state is genesis\n *\n * @param {string} issuer - did (string)\n * @param {string} state  - hex state\n * @returns boolean\n */\nexport function isIssuerGenesis(issuer: string, state: string): boolean {\n  const did = DID.parse(issuer);\n  const id = DID.idFromDID(did);\n  const { method, blockchain, networkId } = DID.decodePartsFromId(id);\n  const arr = BytesHelper.hexToBytes(state);\n  const stateBigInt = BytesHelper.bytesToInt(arr);\n  const type = buildDIDType(method, blockchain, networkId);\n  return isGenesisStateId(DID.idFromDID(did).bigInt(), stateBigInt, type);\n}\n\n/**\n * @deprecated The method should not be used. Use isGenesisState instead.\n * Checks if id is created from given state and type is genesis\n *\n * @param {bigint} id\n * @param {bigint} state\n * @param {Uint8Array} type\n * @returns boolean - returns if id is genesis\n */\nexport function isGenesisStateId(id: bigint, state: bigint, type: Uint8Array): boolean {\n  const idFromState = Id.idGenesisFromIdenState(type, state);\n  return id.toString() === idFromState.bigInt().toString();\n}\n","import { CredentialStatus, RevocationStatus, Issuer } from '../../verifiable';\nimport { CredentialStatusResolver } from './resolver';\nimport { Proof, ProofJSON } from '@iden3/js-merkletree';\n\n/**\n * IssuerResolver is a class that allows to interact with the issuer's http endpoint to get revocation status.\n *\n * @public\n * @class IssuerResolver\n */\n\nexport class IssuerResolver implements CredentialStatusResolver {\n  /**\n   * resolve is a method to resolve a credential status directly from the issuer.\n   *\n   * @public\n   * @param {CredentialStatus} credentialStatus -  credential status to resolve\n   * @param {CredentialStatusResolveOptions} credentialStatusResolveOptions -  options for resolver\n   * @returns `{Promise<RevocationStatus>}`\n   */\n  async resolve(credentialStatus: CredentialStatus): Promise<RevocationStatus> {\n    const revStatusResp = await fetch(credentialStatus.id);\n    const revStatus = await revStatusResp.json();\n    return toRevocationStatus(revStatus);\n  }\n}\n\n/**\n * RevocationStatusResponse is a response of fetching credential status with type SparseMerkleTreeProof\n *\n * @export\n * @interface RevocationStatusResponse\n */\nexport interface RevocationStatusResponse {\n  issuer: Issuer;\n  mtp: ProofJSON;\n}\n\n/**\n * toRevocationStatus is a result of fetching credential status with type SparseMerkleTreeProof converts to RevocationStatus\n *\n * @param {RevocationStatusResponse} { issuer, mtp }\n * @returns {RevocationStatus} RevocationStatus\n */\nexport const toRevocationStatus = ({ issuer, mtp }: RevocationStatusResponse): RevocationStatus => {\n  return {\n    mtp: Proof.fromJSON(mtp),\n    issuer\n  };\n};\n","import { DID } from '@iden3/js-iden3-core';\nimport { State, RevocationStatus, CredentialStatus, CredentialStatusType } from '../../verifiable';\n\n/**\n * CredentialStatusResolveOptions is a set of options that can be passed to CredentialStatusResolver\n *\n * @public\n * @interface CredentialStatusResolveOptions\n */\nexport interface CredentialStatusResolveOptions {\n  /** \n    @deprecated  it was used only for state in case issuer has a issuerGenesisState state\n  */\n  issuerData?: {\n    state: {\n      rootOfRoots: string;\n      claimsTreeRoot: string;\n      revocationTreeRoot: string;\n      value: string;\n    };\n  };\n\n  issuerGenesisState?: State;\n  issuerDID?: DID;\n  userDID?: DID;\n}\n\n/**\n * CredentialStatusResolver is an interface that allows to interact with different types of credential status\n * to resolve revocation status\n *\n * @public\n * @interface CredentialStatusResolver\n */\nexport interface CredentialStatusResolver {\n  /**\n   * resolve is a method to resolve a credential status from the the specific source.\n   *\n   * @public\n   * @param {CredentialStatus} credentialStatus -  credential status to resolve\n   * @param {CredentialStatusResolveOptions} credentialStatusResolveOptions -  options for resolver\n   * @returns `{Promise<RevocationStatus>}`\n   */\n  resolve(\n    credentialStatus: CredentialStatus,\n    opts?: CredentialStatusResolveOptions\n  ): Promise<RevocationStatus>;\n}\n\n/**\n * CredentialStatusResolverRegistry is a registry of CredentialStatusResolver\n *\n * @public\n * @interface CredentialStatusResolverRegistry\n */\nexport class CredentialStatusResolverRegistry {\n  private resolvers: Map<CredentialStatusType, CredentialStatusResolver> = new Map();\n\n  /**\n   * register is a method to add a credential status resolver for specific credential status type\n   *\n   * @public\n   * @param {CredentialStatusType} type -  one of the credential status types\n   * @param {CredentialStatusResolver} resolver -  resolver\n   */\n  register(type: CredentialStatusType, resolver: CredentialStatusResolver) {\n    this.resolvers.set(type, resolver);\n  }\n\n  /**\n   * resolve is a method to resolve a credential status from the the specific source.\n   *\n   * @public\n   * @param {CredentialStatus} credentialStatus -  credential status to resolve\n   * @param {CredentialStatusResolveOptions} credentialStatusResolveOptions -  options for resolver\n   * @returns `{Promise<RevocationStatus>}`\n   */\n  get(type: CredentialStatusType): CredentialStatusResolver | undefined {\n    return this.resolvers.get(type);\n  }\n}\n","import { CredentialStatus, RevocationStatus } from '../../verifiable';\nimport { CredentialStatusResolver, CredentialStatusResolveOptions } from './resolver';\nimport { RevocationStatusRequestMessage } from '../../iden3comm/types';\nimport { MediaType, PROTOCOL_MESSAGE_TYPE } from '../../iden3comm/constants';\nimport * as uuid from 'uuid';\nimport { toRevocationStatus } from './sparse-merkle-tree';\n\n/**\n * AgentResolver is a class that allows to interact with the issuer's agent to get revocation status.\n *\n * @public\n * @class AgentResolver\n */\nexport class AgentResolver implements CredentialStatusResolver {\n  /**\n   * resolve is a method to resolve a credential status from an agent.\n   *\n   * @public\n   * @param {CredentialStatus} credentialStatus -  credential status to resolve\n   * @param {CredentialStatusResolveOptions} credentialStatusResolveOptions -  options for resolver\n   * @returns `{Promise<RevocationStatus>}`\n   */\n  async resolve(\n    credentialStatus: CredentialStatus,\n    credentialStatusResolveOptions?: CredentialStatusResolveOptions\n  ): Promise<RevocationStatus> {\n    if (!credentialStatusResolveOptions?.issuerDID) {\n      throw new Error('IssuerDID is not set in options');\n    }\n    if (!credentialStatusResolveOptions?.userDID) {\n      throw new Error('UserDID is not set in options');\n    }\n\n    if (typeof credentialStatus.revocationNonce !== 'number') {\n      throw new Error('Revocation nonce is not set in credential status');\n    }\n\n    const from = credentialStatusResolveOptions.userDID.string();\n    const to = credentialStatusResolveOptions.issuerDID.string();\n    const msg = buildRevocationMessageRequest(from, to, credentialStatus.revocationNonce);\n    const response = await fetch(credentialStatus.id, {\n      method: 'POST',\n      body: JSON.stringify(msg),\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n    const agentResponse = await response.json();\n    return toRevocationStatus(agentResponse.body);\n  }\n}\n\nfunction buildRevocationMessageRequest(\n  from: string,\n  to: string,\n  revocationNonce: number\n): RevocationStatusRequestMessage {\n  return {\n    id: uuid.v4(),\n    typ: MediaType.PlainMessage,\n    type: PROTOCOL_MESSAGE_TYPE.REVOCATION_STATUS_REQUEST_MESSAGE_TYPE,\n    body: {\n      revocation_nonce: revocationNonce\n    },\n    thid: uuid.v4(),\n    from: from,\n    to: to\n  };\n}\n","import { TransactionReceipt } from 'ethers';\nimport { JSONObject } from '../../iden3comm';\nimport { OnChainRevocationStorage } from '../../storage';\nimport { CredentialStatusType } from '../../verifiable';\nimport { ProofNode } from './reverse-sparse-merkle-tree';\nimport { MessageBus, SDK_EVENTS } from '../../utils';\nimport { PublishMode } from '../models';\n\n/**\n * Represents a credential status publisher.\n */\nexport interface ICredentialStatusPublisher {\n  /**\n   * Publishes the credential status.\n   * @param params - The parameters for publishing the status.\n   * @returns A promise that resolves when the status is published.\n   */\n  publish(params: JSONObject): Promise<void>;\n}\n\n/**\n * Registry for managing credential status publishers.\n */\nexport class CredentialStatusPublisherRegistry {\n  private _publishers: Map<CredentialStatusType, ICredentialStatusPublisher[]> = new Map();\n\n  /**\n   * Registers one or more credential status publishers for a given type.\n   * @param type - The credential status type.\n   * @param publisher - One or more credential status publishers.\n   */\n  public register(type: CredentialStatusType, ...publisher: ICredentialStatusPublisher[]): void {\n    const publishers = this._publishers.get(type) ?? [];\n    publishers.push(...publisher);\n    this._publishers.set(type, publishers);\n  }\n\n  /**\n   * Retrieves the credential status publishers for a given type.\n   * @param type - The credential status type.\n   * @returns An array of credential status publishers or undefined if none are registered for the given type.\n   */\n  public get(type: CredentialStatusType): ICredentialStatusPublisher[] | undefined {\n    return this._publishers.get(type);\n  }\n}\n\n/**\n * Implementation of the ICredentialStatusPublisher interface for publishing on-chain credential status.\n */\nexport class Iden3OnchainSmtCredentialStatusPublisher implements ICredentialStatusPublisher {\n  constructor(private readonly _storage: OnChainRevocationStorage) {}\n\n  /**\n   * Publishes the credential status to the blockchain.\n   * @param params - The parameters for publishing the credential status.\n   */\n  public async publish(params: {\n    nodes: ProofNode[];\n    credentialStatusType: CredentialStatusType;\n    onChain?: {\n      txCallback?: (tx: TransactionReceipt) => Promise<void>;\n      publishMode?: PublishMode;\n    };\n  }): Promise<void> {\n    if (\n      ![CredentialStatusType.Iden3OnchainSparseMerkleTreeProof2023].includes(\n        params.credentialStatusType\n      )\n    ) {\n      throw new Error(\n        `On-chain publishing is not supported for credential status type ${params.credentialStatusType}`\n      );\n    }\n    const nodesBigInts = params.nodes.map((n) => n.children.map((c) => c.bigInt()));\n\n    const txPromise = this._storage.saveNodes(nodesBigInts);\n\n    let publishMode = params.onChain?.publishMode ?? 'sync';\n    if (params.onChain?.txCallback) {\n      publishMode = 'callback';\n    }\n\n    switch (publishMode) {\n      case 'sync':\n        await txPromise;\n        break;\n      case 'callback': {\n        if (!params.onChain?.txCallback) {\n          throw new Error('txCallback is required for publishMode \"callback\"');\n        }\n        const cb = params.onChain?.txCallback;\n        txPromise.then((receipt) => cb(receipt));\n        break;\n      }\n      case 'async': {\n        const mb = MessageBus.getInstance();\n        txPromise.then((receipt) => mb.publish(SDK_EVENTS.TX_RECEIPT_ACCEPTED, receipt));\n        break;\n      }\n      default:\n        throw new Error(`Invalid publishMode: ${publishMode}`);\n    }\n  }\n}\n\n/**\n * Implementation of the ICredentialStatusPublisher interface for publishing off-chain credential status.\n */\nexport class Iden3SmtRhsCredentialStatusPublisher implements ICredentialStatusPublisher {\n  /**\n   * Publishes the credential status to a specified node URL.\n   * @param params - The parameters for publishing the credential status.\n   * @param params.nodes - The proof nodes to be published.\n   * @param params.rhsUrl - The URL of the node to publish the credential status to.\n   * @returns A promise that resolves when the credential status is successfully published.\n   * @throws An error if the publishing fails.\n   */\n  public async publish(params: {\n    nodes: ProofNode[];\n    credentialStatusType: CredentialStatusType;\n\n    rhsUrl: string;\n  }): Promise<void> {\n    if (\n      ![CredentialStatusType.Iden3ReverseSparseMerkleTreeProof].includes(\n        params.credentialStatusType\n      )\n    ) {\n      throw new Error(\n        `On-chain publishing is not supported for credential status type ${params.credentialStatusType}`\n      );\n    }\n    const nodesJSON = params.nodes.map((n) => n.toJSON());\n    const resp = await fetch(params.rhsUrl + '/node', {\n      method: 'post',\n      body: JSON.stringify(nodesJSON)\n    });\n    if (resp.status !== 200) {\n      throw new Error(`Failed to publish credential status. Status: ${resp.status}`);\n    }\n  }\n}\n","import { CredentialStatus, RevocationStatus } from '../../verifiable';\nimport { CredentialStatusResolveOptions, CredentialStatusResolver } from './resolver';\n\nexport class DidDocumentCredentialStatusResolver implements CredentialStatusResolver {\n  constructor(private readonly didResolverUrl: string) {}\n  async resolve(\n    credentialStatus: CredentialStatus,\n    opts?: CredentialStatusResolveOptions | undefined\n  ): Promise<RevocationStatus> {\n    if (!opts?.issuerDID) {\n      throw new Error('IssuerDID is not set in options');\n    }\n\n    const url = `${this.didResolverUrl}/1.0/credential-status/${encodeURIComponent(\n      opts.issuerDID.string()\n    )}`;\n    const resp = await fetch(url, {\n      method: 'POST',\n      body: JSON.stringify(credentialStatus)\n    });\n    const data = await resp.json();\n    return data;\n  }\n}\n","import { DID } from '@iden3/js-iden3-core';\nimport { IDataStorage } from '../storage/interfaces';\nimport {\n  W3CCredential,\n  ProofQuery,\n  VerifiableConstants,\n  CredentialStatus,\n  RevocationStatus,\n  CredentialStatusType,\n  State,\n  DisplayMethodType\n} from './../verifiable';\n\nimport { JSONSchema } from '../schema-processor';\nimport * as uuid from 'uuid';\nimport { CredentialStatusResolverRegistry } from './status/resolver';\nimport { IssuerResolver } from './status/sparse-merkle-tree';\nimport { AgentResolver } from './status/agent-revocation';\nimport { CredentialStatusResolveOptions } from './status/resolver';\nimport { getUserDIDFromCredential } from './utils';\nimport { CredentialRequest } from './models';\n\n/**\n * Interface to work with credential wallets\n *\n * @public\n * @interface   ICredentialWallet\n */\nexport interface ICredentialWallet {\n  /**\n   * List of W3C Credential\n   *\n   * @returns `Promise<W3CCredential[]`\n   */\n  list(): Promise<W3CCredential[]>;\n  /**\n   * saves W3C credential (upsert)\n   * @param {W3CCredential} credential - credential to save\n   * @returns `Promise<void>`\n   *\n   */\n  save(credential: W3CCredential): Promise<void>;\n  /**\n   * saves the batch of W3C credentials (upsert)\n   * @param {W3CCredential[]} credentials - credentials to save\n   * @returns `Promise<void>`\n   */\n  saveAll(credentials: W3CCredential[]): Promise<void>;\n\n  /**\n   *\n   * removes W3C credentials from data storage\n   * @param {string} id\n   * @returns `Promise<void>`\n   */\n  remove(id: string): Promise<void>;\n  /**\n   * Find credential using iden3 query language\n   *\n   * @param {ProofQuery} query  - protocol query to find credential\n   * @returns `Promise<W3CCredential[]>`\n   */\n  findByQuery(query: ProofQuery): Promise<W3CCredential[]>;\n  /**\n   * Finds the credential by its id\n   *\n   * @param {string} id - id of credential\n   * @returns `Promise<W3CCredential | undefined>`\n   */\n  findById(id: string): Promise<W3CCredential | undefined>;\n  /**\n   * Finds credentials by JSON-LD schema and type\n   *\n   * @param {string} context - the URL of JSON-LD schema where type is defined\n   * @returns `Promise<W3CCredential[]>`\n   */\n  findByContextType(context: string, type: string): Promise<W3CCredential[]>;\n\n  /**\n   * Filters given credentials with given credential subject\n   *\n   * @param {W3CCredential[]} credentials - credentials to filter\n   * @param {DID} subject - credential subject id\n   * @returns `Promise<W3CCredential[]>`\n   */\n  filterByCredentialSubject(credentials: W3CCredential[], subject: DID): Promise<W3CCredential[]>;\n  /**\n   * Finds first non-revoked Auth BJJ credential for given user\n   *\n   * @param {DID} did - the issuer of Auth BJJ credential\n   * @returns `Promise<W3CCredential>` W3CCredential with AuthBJJCredential type\n   */\n  getAuthBJJCredential(did: DID): Promise<W3CCredential>;\n\n  /**\n   * Finds all Auth BJJ credentials for given user\n   *\n   * @param {DID} did - the issuer of Auth BJJ credential\n   * @returns `Promise<W3CCredential[]>` W3CCredentials with AuthBJJCredential type\n   */\n  getAllAuthBJJCredentials(did: DID): Promise<W3CCredential[]>;\n\n  /**\n   * Fetches or Builds a revocation status for a given credential\n   * Supported types for credentialStatus field: SparseMerkleTreeProof, Iden3ReverseSparseMerkleTreeProof\n   *\n   * @param {W3CCredential} cred - credential for which lib should build revocation status\n   * @returns `Promise<RevocationStatus>`\n   */\n  getRevocationStatusFromCredential(cred: W3CCredential): Promise<RevocationStatus>;\n  /**\n   * Fetches Revocation status depended on type\n   *\n   * @param {(CredentialStatus )} credStatus - credentialStatus field of the Verifiable Credential.  Supported types for credentialStatus field: SparseMerkleTreeProof, Iden3ReverseSparseMerkleTreeProof\n   * @param {CredentialStatusResolveOptions} credentialStatusResolveOptions - options to resolve credential status\n   * @returns `Promise<RevocationStatus>`\n   */\n  getRevocationStatus(\n    credStatus: CredentialStatus,\n    credentialStatusResolveOptions?: CredentialStatusResolveOptions\n  ): Promise<RevocationStatus>;\n  /**\n   * Creates a W3C verifiable Credential object\n   *\n   * @param {string} hostUrl - URL that will be used as a prefix for credential identifier\n   * @param {DID} issuer - issuer identity\n   * @param {CredentialRequest} request - specification of claim creation parameters\n   * @param {JSONSchema} schema - JSON schema for W3C Verifiable Credential\n   * @returns W3CCredential\n   */\n  createCredential(issuer: DID, request: CredentialRequest, schema: JSONSchema): W3CCredential;\n\n  /**\n   * Finds non-revoked credential from a given list by resolving their credential status\n   *\n   * @param {W3CCredential[]} creds\n   * @returns `{Promise<{\n   *     cred: W3CCredential;\n   *     revStatus: RevocationStatus;\n   *   }>` not revoked credential and it's revocation status\n   */\n  findNonRevokedCredential(creds: W3CCredential[]): Promise<{\n    cred: W3CCredential;\n    revStatus: RevocationStatus;\n  }>;\n}\n\n/**\n *\n * Wallet instance is a wrapper of CRUD logic for W3C credentials,\n * also it allows to fetch revocation statuses.\n *\n * @public\n * @class CredentialWallet\n * @implements implements ICredentialWallet interface\n */\nexport class CredentialWallet implements ICredentialWallet {\n  /**\n   * Creates an instance of CredentialWallet.\n   * @param {IDataStorage} _storage - data storage to access credential / identity / Merkle tree data\n   * @param {CredentialStatusResolverRegistry} _credentialStatusResolverRegistry - list of credential status resolvers\n   * if _credentialStatusResolverRegistry is not provided, default resolvers will be used\n   */\n  constructor(\n    private readonly _storage: IDataStorage,\n    private readonly _credentialStatusResolverRegistry?: CredentialStatusResolverRegistry\n  ) {\n    // if no credential status resolvers are provided\n    // register default issuer resolver\n    if (!this._credentialStatusResolverRegistry) {\n      this._credentialStatusResolverRegistry = new CredentialStatusResolverRegistry();\n      this._credentialStatusResolverRegistry.register(\n        CredentialStatusType.SparseMerkleTreeProof,\n        new IssuerResolver()\n      );\n      this._credentialStatusResolverRegistry.register(\n        CredentialStatusType.Iden3commRevocationStatusV1,\n        new AgentResolver()\n      );\n    }\n  }\n\n  /**\n   * {@inheritDoc ICredentialWallet.getAuthBJJCredential}\n   */\n  async getAuthBJJCredential(did: DID): Promise<W3CCredential> {\n    // filter where the issuer of auth credential is given did\n\n    const authBJJCredsOfIssuer = await this._storage.credential.findCredentialsByQuery({\n      context: VerifiableConstants.AUTH.AUTH_BJJ_CREDENTIAL_SCHEMA_JSONLD_URL,\n      type: VerifiableConstants.AUTH.AUTH_BJJ_CREDENTIAL_TYPE,\n      allowedIssuers: [did.string()]\n    });\n\n    if (!authBJJCredsOfIssuer.length) {\n      throw new Error(VerifiableConstants.ERRORS.NO_AUTH_CRED_FOUND);\n    }\n\n    for (let index = 0; index < authBJJCredsOfIssuer.length; index++) {\n      const authCred = authBJJCredsOfIssuer[index];\n      const revocationStatus = await this.getRevocationStatusFromCredential(authCred);\n\n      if (!revocationStatus.mtp.existence) {\n        return authCred;\n      }\n    }\n    throw new Error('all auth bjj credentials are revoked');\n  }\n\n  /**\n   * {@inheritDoc ICredentialWallet.getAllAuthBJJCredentials}\n   */\n  async getAllAuthBJJCredentials(did: DID): Promise<W3CCredential[]> {\n    return this._storage.credential.findCredentialsByQuery({\n      context: VerifiableConstants.AUTH.AUTH_BJJ_CREDENTIAL_SCHEMA_JSONLD_URL,\n      type: VerifiableConstants.AUTH.AUTH_BJJ_CREDENTIAL_TYPE,\n      allowedIssuers: [did.string()]\n    });\n  }\n\n  /**\n   * {@inheritDoc ICredentialWallet.getRevocationStatusFromCredential}\n   */\n  async getRevocationStatusFromCredential(cred: W3CCredential): Promise<RevocationStatus> {\n    const mtpProof = cred.getIden3SparseMerkleTreeProof();\n    const sigProof = cred.getBJJSignature2021Proof();\n\n    const stateInfo: State | undefined = mtpProof\n      ? mtpProof.issuerData.state\n      : sigProof?.issuerData.state;\n    const issuerDID = DID.parse(cred.issuer);\n\n    const userDID = getUserDIDFromCredential(issuerDID, cred);\n\n    const opts: CredentialStatusResolveOptions = {\n      issuerGenesisState: stateInfo,\n      issuerDID,\n      userDID\n    };\n\n    return this.getRevocationStatus(cred.credentialStatus, opts);\n  }\n\n  /**\n   * {@inheritDoc ICredentialWallet.getRevocationStatus}\n   */\n  async getRevocationStatus(\n    credStatus: CredentialStatus,\n    credentialStatusResolveOptions?: CredentialStatusResolveOptions\n  ): Promise<RevocationStatus> {\n    const statusResolver = this._credentialStatusResolverRegistry?.get(credStatus.type);\n    if (!statusResolver) {\n      throw new Error(`credential status resolver does not exist for ${credStatus.type} type`);\n    }\n\n    return statusResolver.resolve(credStatus, credentialStatusResolveOptions);\n  }\n  /**\n   * {@inheritDoc ICredentialWallet.createCredential}\n   */\n  createCredential = (\n    issuer: DID,\n    request: CredentialRequest,\n    schema: JSONSchema\n  ): W3CCredential => {\n    if (!schema.$metadata.uris['jsonLdContext']) {\n      throw new Error('jsonLdContext is missing is the schema');\n    }\n    // do copy of request to avoid mutation\n    const r = { ...request };\n    r.context = r.context ?? [];\n    if (\n      r.displayMethod?.type === DisplayMethodType.Iden3BasicDisplayMethodV1 &&\n      !r.context.includes(VerifiableConstants.JSONLD_SCHEMA.IDEN3_DISPLAY_METHOD)\n    ) {\n      r.context.push(VerifiableConstants.JSONLD_SCHEMA.IDEN3_DISPLAY_METHOD);\n    }\n    r.context.push(schema.$metadata.uris['jsonLdContext']);\n    r.expiration = r.expiration ? r.expiration * 1000 : undefined;\n    r.id = r.id ? r.id : `urn:${uuid.v4()}`;\n    r.issuanceDate = r.issuanceDate ? r.issuanceDate * 1000 : Date.now();\n\n    return W3CCredential.fromCredentialRequest(issuer, r);\n  };\n\n  /**\n   * {@inheritDoc ICredentialWallet.findById}\n   */\n  async findById(id: string): Promise<W3CCredential | undefined> {\n    return this._storage.credential.findCredentialById(id);\n  }\n  /**\n   * {@inheritDoc ICredentialWallet.findByContextType}\n   */\n  async findByContextType(context: string, type: string): Promise<W3CCredential[]> {\n    return this._storage.credential.findCredentialsByQuery({ context, type });\n  }\n  /**\n   * {@inheritDoc ICredentialWallet.save}\n   */\n  async save(credential: W3CCredential): Promise<void> {\n    return this._storage.credential.saveCredential(credential);\n  }\n  /**\n   * {@inheritDoc ICredentialWallet.saveAll}\n   */\n  async saveAll(credentials: W3CCredential[]): Promise<void> {\n    return this._storage.credential.saveAllCredentials(credentials);\n  }\n  /**\n   * {@inheritDoc ICredentialWallet.remove}\n   */\n  async remove(id: string): Promise<void> {\n    return this._storage.credential.removeCredential(id);\n  }\n  /**\n   * {@inheritDoc ICredentialWallet.list}\n   */\n  async list(): Promise<W3CCredential[]> {\n    return this._storage.credential.listCredentials();\n  }\n  /**\n   * {@inheritDoc ICredentialWallet.findByQuery}\n   */\n  async findByQuery(query: ProofQuery): Promise<W3CCredential[]> {\n    return this._storage.credential.findCredentialsByQuery(query);\n  }\n\n  /**\n   * {@inheritDoc ICredentialWallet.filterByCredentialSubject}\n   */\n  async filterByCredentialSubject(\n    credentials: W3CCredential[],\n    subject: DID\n  ): Promise<W3CCredential[]> {\n    return credentials.filter((cred: W3CCredential) => {\n      return cred.credentialSubject['id'] === subject.string();\n    });\n  }\n  async findNonRevokedCredential(creds: W3CCredential[]): Promise<{\n    cred: W3CCredential;\n    revStatus: RevocationStatus;\n  }> {\n    for (const cred of creds) {\n      const revStatus = await this.getRevocationStatusFromCredential(cred);\n      if (revStatus.mtp.existence) {\n        continue;\n      }\n      return { cred, revStatus };\n    }\n    throw new Error(VerifiableConstants.ERRORS.CREDENTIAL_WALLET_ALL_CREDENTIALS_ARE_REVOKED);\n  }\n}\n","import { Hash, testBit, Merkletree, NodeLeaf, Siblings } from '@iden3/js-merkletree';\n\nimport { NODE_TYPE_LEAF } from '@iden3/js-merkletree';\nimport { hashElems } from '@iden3/js-merkletree';\nimport { ProofNode } from './status/reverse-sparse-merkle-tree';\nimport { Iden3SmtRhsCredentialStatusPublisher } from './status/credential-status-publisher';\nimport { CredentialStatusType } from '../verifiable';\n/**\n * Interface to unite contains three trees: claim, revocation and rootOfRoots\n * Also contains the current state of identity\n * @public\n * @interface TreesModel\n */\nexport interface TreesModel {\n  claimsTree: Merkletree;\n  revocationTree: Merkletree;\n  rootsTree: Merkletree;\n  state: Hash;\n}\n\n/**\n * Pushes identity state information to a reverse hash service.\n *\n * A reverse hash service (RHS) is a centralized or decentralized service for storing publicly available data about identity.\n * Such data are identity state and state of revocation tree and roots tree root tree.\n *\n * @deprecated Use `pushHashesToReverseHashService` instead.\n * @param {Hash} state - current state of identity\n * @param {TreesModel} trees - current trees of identity (claims, revocation, rootOfRoots )\n * @param {string} rhsUrl - URL of service\n * @param {number[]} [revokedNonces] - revoked nonces since last published info\n * @returns void\n */\nexport async function pushHashesToRHS(\n  state: Hash,\n  trees: TreesModel,\n  rhsUrl: string,\n  revokedNonces?: number[]\n): Promise<void> {\n  const nodes = await getNodesRepresentation(revokedNonces, trees, state);\n  const publisher = new Iden3SmtRhsCredentialStatusPublisher();\n  await publisher.publish({\n    nodes,\n    credentialStatusType: CredentialStatusType.Iden3ReverseSparseMerkleTreeProof,\n    rhsUrl: rhsUrl\n  });\n}\n\n/**\n * Retrieves the representation of nodes for generating a proof.\n *\n * @param revokedNonces - An array of revoked nonces.\n * @param trees - The TreesModel object containing the necessary trees.\n * @param state - The hash of the state.\n * @returns A Promise that resolves to an array of ProofNode objects.\n */\nexport async function getNodesRepresentation(\n  revokedNonces: number[] | undefined,\n  trees: TreesModel,\n  state: Hash\n): Promise<ProofNode[]> {\n  const nb = new NodesBuilder();\n\n  if (revokedNonces) {\n    await addRevocationNode(nb, trees, revokedNonces);\n  }\n\n  await addRoRNode(nb, trees);\n\n  // add new state node\n  if (!state.bytes.every((b) => b === 0)) {\n    nb.addProofNode(\n      new ProofNode(state, [\n        await trees.claimsTree.root(),\n        await trees.revocationTree.root(),\n        await trees.rootsTree.root()\n      ])\n    );\n  }\n\n  return nb.nodes;\n}\n\nasync function addRoRNode(nb: NodesBuilder, trees: TreesModel): Promise<void> {\n  const currentRootsTree = trees.rootsTree;\n  const claimsTree = trees.claimsTree;\n\n  return nb.addKey(currentRootsTree, (await claimsTree.root()).bigInt());\n}\n\nasync function addRevocationNode(\n  nb: NodesBuilder,\n  trees: TreesModel,\n  revokedNonces: number[]\n): Promise<void> {\n  const revocationTree = trees.revocationTree;\n\n  for (const nonce of revokedNonces) {\n    await nb.addKey(revocationTree, BigInt(nonce));\n  }\n}\n\n/**\n * Builder to send state information to Reverse hash Service\n *\n * @public\n * @class NodesBuilder\n */\nclass NodesBuilder {\n  constructor(\n    public readonly nodes: ProofNode[] = [],\n    public readonly seen: Map<string, boolean> = new Map()\n  ) {}\n\n  async addKey(tree: Merkletree, nodeKey: bigint): Promise<void> {\n    const { value: nodeValue, siblings } = await tree.get(nodeKey);\n\n    const nodeKeyHash = Hash.fromBigInt(nodeKey);\n\n    const nodeValueHash = Hash.fromBigInt(nodeValue);\n\n    const node = new NodeLeaf(nodeKeyHash, nodeValueHash);\n    const newNodes: ProofNode[] = await buildNodesUp(siblings, node);\n\n    for (const n of newNodes) {\n      if (!this.seen.get(n.hash.hex())) {\n        this.nodes.push(n);\n        this.seen.set(n.hash.hex(), true);\n      }\n    }\n  }\n\n  addProofNode(node: ProofNode): void {\n    const hex = node.hash.hex();\n    const isSeen = this.seen.get(hex);\n    if (!isSeen) {\n      this.nodes.push(node);\n      this.seen.set(hex, true);\n    }\n  }\n}\n\nasync function buildNodesUp(siblings: Siblings, node: NodeLeaf): Promise<ProofNode[]> {\n  if (node.type !== NODE_TYPE_LEAF) {\n    throw new Error('node is not a leaf');\n  }\n\n  let prevHash = await node.getKey();\n  const sl = siblings.length;\n  const nodes = new Array<ProofNode>(sl + 1);\n  for (let index = 0; index < nodes.length; index++) {\n    nodes[index] = new ProofNode();\n  }\n  nodes[sl].hash = prevHash;\n  const hashOfOne = Hash.fromBigInt(BigInt(1));\n\n  nodes[sl].children = [node.entry[0], node.entry[1], hashOfOne];\n\n  const pathKey: Hash = node.entry[0];\n  for (let i = sl - 1; i >= 0; i--) {\n    const isRight = testBit(pathKey.bytes, i);\n    nodes[i].children = new Array<Hash>(2);\n    if (isRight) {\n      nodes[i].children[0] = siblings[i];\n      nodes[i].children[1] = prevHash;\n    } else {\n      nodes[i].children[0] = prevHash;\n      nodes[i].children[1] = siblings[i];\n    }\n    nodes[i].hash = hashElems([nodes[i].children[0].bigInt(), nodes[i].children[1].bigInt()]);\n\n    prevHash = nodes[i].hash;\n  }\n\n  return nodes;\n}\n","import { MediaType } from '../constants';\nimport { PROTOCOL_MESSAGE_TYPE } from '../constants';\n\nimport {\n  BasicMessage,\n  CredentialFetchRequestMessage,\n  CredentialIssuanceMessage,\n  CredentialsOfferMessage,\n  CredentialsOnchainOfferMessage,\n  IPackageManager,\n  JWSPackerParams,\n  MessageFetchRequestMessage\n} from '../types';\n\nimport { W3CCredential } from '../../verifiable';\nimport { ICredentialWallet, getUserDIDFromCredential } from '../../credentials';\n\nimport { byteDecoder, byteEncoder } from '../../utils';\nimport { proving } from '@iden3/js-jwz';\nimport { DID } from '@iden3/js-iden3-core';\nimport * as uuid from 'uuid';\nimport {\n  AbstractMessageHandler,\n  BasicHandlerOptions,\n  IProtocolMessageHandler\n} from './message-handler';\nimport { verifyExpiresTime } from './common';\nimport { IOnchainIssuer } from '../../storage';\n\n/**\n *\n * Options to pass to fetch handler\n *\n * @public\n * @interface FetchHandlerOptions\n */\nexport type FetchHandlerOptions = BasicHandlerOptions & {\n  mediaType: MediaType;\n  packerOptions?: JWSPackerParams;\n  headers?: {\n    [key: string]: string;\n  };\n};\n\n/**\n *\n * Options to pass to fetch request handler\n *\n * @public\n * @interface FetchRequestOptions\n */\nexport type FetchRequestOptions = BasicHandlerOptions;\n\n/**\n *\n * Options to pass to issuance response handler\n *\n * @public\n * @interface IssuanceResponseOptions\n */\nexport type IssuanceResponseOptions = BasicHandlerOptions;\n\nexport type FetchMessageHandlerOptions = FetchHandlerOptions;\n\n/**\n * Interface that allows the processing of the credential offer in the raw format for given identifier\n *\n * @public\n * @interface IFetchHandler\n */\nexport interface IFetchHandler {\n  /**\n   * unpacks authorization request\n   * @public\n   * @param {Uint8Array} offer - raw byte message\n   * @param {FetchHandlerOptions} opts - FetchHandlerOptions\n   * @returns `Promise<{\n    token: string;\n    authRequest: AuthorizationRequestMessage;\n    authResponse: AuthorizationResponseMessage;\n  }>`\n   */\n  handleCredentialOffer(offer: Uint8Array, opts?: FetchHandlerOptions): Promise<W3CCredential[]>;\n\n  /**\n   * Handles a credential fetch request.\n   *\n   * @param basicMessage - The basic message containing the fetch request.\n   * @returns A promise that resolves to the response message.\n   * @throws An error if the request is invalid or if the credential is not found.\n   */\n  handleCredentialFetchRequest(\n    basicMessage: Uint8Array,\n    opts?: FetchRequestOptions\n  ): Promise<Uint8Array>;\n\n  /**\n   * Handles the issuance response message.\n   *\n   * @param basicMessage - The basic message containing the issuance response.\n   * @returns A promise that resolves to a Uint8Array.\n   * @throws An error if the credential wallet is not provided in the options or if the credential is missing in the issuance response message.\n   */\n  handleIssuanceResponseMessage(\n    basicMessage: Uint8Array,\n    opts?: IssuanceResponseOptions\n  ): Promise<Uint8Array>;\n}\n/**\n *\n * Allows to handle Credential offer protocol message and return fetched credential\n *\n * @public\n\n * @class FetchHandler\n * @implements implements IFetchHandler interface\n */\nexport class FetchHandler\n  extends AbstractMessageHandler\n  implements IFetchHandler, IProtocolMessageHandler\n{\n  /**\n   * Constructs a new instance of the FetchHandler class.\n   *\n   * @param _packerMgr The package manager used for packing and unpacking data.\n   * @param opts Optional configuration options for the FetchHandler.\n   * @param opts.credentialWallet The credential wallet used for managing credentials.\n   */\n  constructor(\n    private readonly _packerMgr: IPackageManager,\n    private readonly opts?: {\n      credentialWallet: ICredentialWallet;\n      onchainIssuer?: IOnchainIssuer;\n    }\n  ) {\n    super();\n  }\n\n  async handle(\n    message: BasicMessage,\n    ctx: FetchMessageHandlerOptions\n  ): Promise<BasicMessage | null> {\n    switch (message.type) {\n      case PROTOCOL_MESSAGE_TYPE.CREDENTIAL_OFFER_MESSAGE_TYPE: {\n        const result = await this.handleOfferMessage(message as CredentialsOfferMessage, ctx);\n        if (Array.isArray(result)) {\n          const credWallet = this.opts?.credentialWallet;\n          if (!credWallet) throw new Error('Credential wallet is not provided');\n          await credWallet.saveAll(result);\n          return null;\n        }\n        return result as BasicMessage;\n      }\n      case PROTOCOL_MESSAGE_TYPE.CREDENTIAL_FETCH_REQUEST_MESSAGE_TYPE:\n        return this.handleFetchRequest(message as CredentialFetchRequestMessage);\n      case PROTOCOL_MESSAGE_TYPE.CREDENTIAL_ISSUANCE_RESPONSE_MESSAGE_TYPE:\n        return this.handleIssuanceResponseMsg(message as CredentialIssuanceMessage);\n      case PROTOCOL_MESSAGE_TYPE.CREDENTIAL_ONCHAIN_OFFER_MESSAGE_TYPE: {\n        const result = await this.handleOnchainOfferMessage(\n          message as CredentialsOnchainOfferMessage\n        );\n        if (Array.isArray(result)) {\n          const credWallet = this.opts?.credentialWallet;\n          if (!credWallet) throw new Error('Credential wallet is not provided');\n          await credWallet.saveAll(result);\n          return null;\n        }\n        return result as BasicMessage;\n      }\n      default:\n        return super.handle(message, ctx);\n    }\n  }\n\n  private async handleOnchainOfferMessage(\n    offerMessage: CredentialsOnchainOfferMessage\n  ): Promise<W3CCredential[]> {\n    if (!this.opts?.onchainIssuer) {\n      throw new Error('onchain issuer is not provided');\n    }\n    const credentials: W3CCredential[] = [];\n    for (const credentialInfo of offerMessage.body.credentials) {\n      const issuerDID = DID.parse(offerMessage.from);\n      const userDID = DID.parse(offerMessage.to);\n      const credential = await this.opts.onchainIssuer.getCredential(\n        issuerDID,\n        userDID,\n        BigInt(credentialInfo.id)\n      );\n      credentials.push(credential);\n    }\n    return credentials;\n  }\n\n  private async handleOfferMessage(\n    offerMessage: CredentialsOfferMessage,\n    ctx: {\n      mediaType?: MediaType;\n      headers?: HeadersInit;\n      packerOptions?: JWSPackerParams;\n    }\n  ): Promise<W3CCredential[] | BasicMessage> {\n    if (!ctx.mediaType) {\n      ctx.mediaType = MediaType.ZKPMessage;\n    }\n\n    const credentials: W3CCredential[] = [];\n\n    for (const credentialInfo of offerMessage.body.credentials) {\n      const guid = uuid.v4();\n      const fetchRequest: MessageFetchRequestMessage = {\n        id: guid,\n        typ: ctx.mediaType,\n        type: PROTOCOL_MESSAGE_TYPE.CREDENTIAL_FETCH_REQUEST_MESSAGE_TYPE,\n        thid: offerMessage.thid ?? guid,\n        body: {\n          id: credentialInfo.id\n        },\n        from: offerMessage.to,\n        to: offerMessage.from\n      };\n\n      const msgBytes = byteEncoder.encode(JSON.stringify(fetchRequest));\n\n      const packerOpts =\n        ctx.mediaType === MediaType.SignedMessage\n          ? ctx.packerOptions\n          : {\n              provingMethodAlg: proving.provingMethodGroth16AuthV2Instance.methodAlg\n            };\n\n      const senderDID = DID.parse(offerMessage.to);\n      const token = byteDecoder.decode(\n        await this._packerMgr.pack(ctx.mediaType, msgBytes, {\n          senderDID,\n          ...packerOpts\n        })\n      );\n      try {\n        if (!offerMessage?.body?.url) {\n          throw new Error(`could not fetch W3C credential, body url is missing`);\n        }\n        const resp = await fetch(offerMessage.body.url, {\n          method: 'post',\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded',\n            ...ctx.headers\n          },\n          body: token\n        });\n        const arrayBuffer = await resp.arrayBuffer();\n        if (!arrayBuffer.byteLength) {\n          throw new Error(`could not fetch , ${credentialInfo?.id}, response is empty`);\n        }\n        const { unpackedMessage: message } = await this._packerMgr.unpack(\n          new Uint8Array(arrayBuffer)\n        );\n        if (message.type !== PROTOCOL_MESSAGE_TYPE.CREDENTIAL_ISSUANCE_RESPONSE_MESSAGE_TYPE) {\n          return message;\n        }\n        credentials.push(\n          W3CCredential.fromJSON((message as CredentialIssuanceMessage).body.credential)\n        );\n      } catch (e: unknown) {\n        throw new Error(\n          `could not fetch protocol message for credential offer id: , ${\n            credentialInfo?.id\n          }, error: ${(e as Error).message ?? e}`\n        );\n      }\n    }\n    return credentials;\n  }\n\n  /**\n   * Handles only messages with credentials/1.0/offer type\n   *\n   * @param {\n   *     offer: Uint8Array; offer - raw offer message\n   *     opts\n   *   }) options how to fetch credential\n   * @returns `Promise<W3CCredential[]>`\n   */\n  async handleCredentialOffer(\n    offer: Uint8Array,\n    opts?: FetchHandlerOptions\n  ): Promise<W3CCredential[]> {\n    if (opts?.mediaType === MediaType.SignedMessage && !opts.packerOptions) {\n      throw new Error(`jws packer options are required for ${MediaType.SignedMessage}`);\n    }\n\n    const offerMessage = await FetchHandler.unpackMessage<CredentialsOfferMessage>(\n      this._packerMgr,\n      offer,\n      PROTOCOL_MESSAGE_TYPE.CREDENTIAL_OFFER_MESSAGE_TYPE\n    );\n    if (!opts?.allowExpiredMessages) {\n      verifyExpiresTime(offerMessage);\n    }\n    const result = await this.handleOfferMessage(offerMessage, {\n      mediaType: opts?.mediaType,\n      headers: opts?.headers,\n      packerOptions: opts?.packerOptions\n    });\n\n    if (Array.isArray(result)) {\n      return result;\n    }\n\n    throw new Error('invalid protocol message response');\n  }\n\n  /**\n   * Handles only messages with credentials/1.0/onchain-offer type\n   * @beta\n   */\n  async handleOnchainOffer(offer: Uint8Array): Promise<W3CCredential[]> {\n    const offerMessage = await FetchHandler.unpackMessage<CredentialsOnchainOfferMessage>(\n      this._packerMgr,\n      offer,\n      PROTOCOL_MESSAGE_TYPE.CREDENTIAL_ONCHAIN_OFFER_MESSAGE_TYPE\n    );\n\n    return this.handleOnchainOfferMessage(offerMessage);\n  }\n\n  private async handleFetchRequest(\n    msgRequest: CredentialFetchRequestMessage\n  ): Promise<CredentialIssuanceMessage> {\n    if (!msgRequest.to) {\n      throw new Error(\"failed request. empty 'to' field\");\n    }\n\n    if (!msgRequest.from) {\n      throw new Error(\"failed request. empty 'from' field\");\n    }\n\n    const issuerDID = DID.parse(msgRequest.to);\n    const userDID = DID.parse(msgRequest.from);\n\n    const credId = msgRequest.body?.id;\n    if (!credId) {\n      throw new Error('invalid credential id in fetch request body');\n    }\n\n    if (!this.opts?.credentialWallet) {\n      throw new Error('please, provide credential wallet in options');\n    }\n\n    const cred = await this.opts.credentialWallet.findById(credId);\n\n    if (!cred) {\n      throw new Error('credential not found');\n    }\n\n    const userToVerifyDID = getUserDIDFromCredential(issuerDID, cred);\n\n    if (userToVerifyDID.string() !== userDID.string()) {\n      throw new Error('credential subject is not a sender DID');\n    }\n\n    return {\n      id: uuid.v4(),\n      type: PROTOCOL_MESSAGE_TYPE.CREDENTIAL_ISSUANCE_RESPONSE_MESSAGE_TYPE,\n      typ: msgRequest.typ ?? MediaType.PlainMessage,\n      thid: msgRequest.thid ?? uuid.v4(),\n      body: { credential: cred },\n      from: msgRequest.to,\n      to: msgRequest.from\n    };\n  }\n  /**\n   * @inheritdoc IFetchHandler#handleCredentialFetchRequest\n   */\n  async handleCredentialFetchRequest(\n    envelope: Uint8Array,\n    opts?: FetchRequestOptions\n  ): Promise<Uint8Array> {\n    const msgRequest = await FetchHandler.unpackMessage<CredentialFetchRequestMessage>(\n      this._packerMgr,\n      envelope,\n      PROTOCOL_MESSAGE_TYPE.CREDENTIAL_FETCH_REQUEST_MESSAGE_TYPE\n    );\n    if (!opts?.allowExpiredMessages) {\n      verifyExpiresTime(msgRequest);\n    }\n    const request = await this.handleFetchRequest(msgRequest);\n\n    return this._packerMgr.pack(\n      MediaType.PlainMessage,\n      byteEncoder.encode(JSON.stringify(request)),\n      {}\n    );\n  }\n\n  private async handleIssuanceResponseMsg(issuanceMsg: CredentialIssuanceMessage): Promise<null> {\n    if (!this.opts?.credentialWallet) {\n      throw new Error('please provide credential wallet in options');\n    }\n\n    if (!issuanceMsg.body?.credential) {\n      throw new Error('credential is missing in issuance response message');\n    }\n\n    await this.opts.credentialWallet.save(W3CCredential.fromJSON(issuanceMsg.body.credential));\n\n    return null;\n  }\n\n  /**\n   * @inheritdoc IFetchHandler#handleIssuanceResponseMessage\n   */\n  async handleIssuanceResponseMessage(\n    envelop: Uint8Array,\n    opts?: IssuanceResponseOptions\n  ): Promise<Uint8Array> {\n    const issuanceMsg = await FetchHandler.unpackMessage<CredentialIssuanceMessage>(\n      this._packerMgr,\n      envelop,\n      PROTOCOL_MESSAGE_TYPE.CREDENTIAL_ISSUANCE_RESPONSE_MESSAGE_TYPE\n    );\n    if (!opts?.allowExpiredMessages) {\n      verifyExpiresTime(issuanceMsg);\n    }\n    await this.handleIssuanceResponseMsg(issuanceMsg);\n    return Uint8Array.from([]);\n  }\n\n  /**\n   * @inheritdoc IFetchHandler#unpackMessage\n   */\n  static async unpackMessage<T>(\n    packerMgr: IPackageManager,\n    envelope: Uint8Array,\n    messageType: string\n  ): Promise<T> {\n    const { unpackedMessage: message } = await packerMgr.unpack(envelope);\n    const msgRequest = message as unknown as T;\n    if (message.type !== messageType) {\n      throw new Error('Invalid message type');\n    }\n    return msgRequest;\n  }\n}\n","import { CircuitId } from '../../circuits/models';\nimport { IProofService } from '../../proof/proof-service';\nimport { defaultAcceptProfile, PROTOCOL_MESSAGE_TYPE, ProtocolVersion } from '../constants';\nimport {\n  AcceptProfile,\n  BasicMessage,\n  IPackageManager,\n  ZeroKnowledgeInvokeResponse,\n  ZeroKnowledgeProofResponse\n} from '../types';\nimport { ContractInvokeRequest, ContractInvokeResponse } from '../types/protocol/contract-request';\nimport { DID, ChainIds, getUnixTimestamp, BytesHelper } from '@iden3/js-iden3-core';\nimport { FunctionSignatures, IOnChainZKPVerifier } from '../../storage';\nimport { Signer } from 'ethers';\nimport { processProofAuth, processZeroKnowledgeProofRequests, verifyExpiresTime } from './common';\nimport {\n  AbstractMessageHandler,\n  BasicHandlerOptions,\n  IProtocolMessageHandler\n} from './message-handler';\nimport { parseAcceptProfile } from '../utils';\nimport { hexToBytes } from '../../utils';\n\n/**\n * Interface that allows the processing of the contract request\n *\n * @beta\n * @interface IContractRequestHandler\n */\nexport interface IContractRequestHandler {\n  /**\n   * unpacks contract invoke request\n   * @beta\n   * @param {Uint8Array} request - raw byte message\n   * @returns `Promise<ContractInvokeRequest>`\n   */\n  parseContractInvokeRequest(request: Uint8Array): Promise<ContractInvokeRequest>;\n\n  /**\n   * handle contract invoke request\n   * @beta\n   * @param {did} did  - sender DID\n   * @param {Uint8Array} request - raw byte message\n   * @param {ContractInvokeHandlerOptions} opts - handler options\n   * @returns {Map<string, ZeroKnowledgeProofResponse>}` -  map of transaction hash - ZeroKnowledgeProofResponse\n   */\n  handleContractInvokeRequest(\n    did: DID,\n    request: Uint8Array,\n    opts?: ContractInvokeHandlerOptions\n  ): Promise<Map<string, ZeroKnowledgeProofResponse>>;\n}\n\n/** ContractInvokeHandlerOptions represents contract invoke handler options */\nexport type ContractInvokeHandlerOptions = BasicHandlerOptions & {\n  ethSigner: Signer;\n  challenge?: bigint;\n};\n\nexport type ContractMessageHandlerOptions = {\n  senderDid: DID;\n  ethSigner: Signer;\n  challenge?: bigint;\n};\n\n/**\n *\n * Allows to process ContractInvokeRequest protocol message\n *\n * @beta\n\n * @class ContractRequestHandler\n * @implements implements IContractRequestHandler interface\n */\nexport class ContractRequestHandler\n  extends AbstractMessageHandler\n  implements IContractRequestHandler, IProtocolMessageHandler\n{\n  private readonly _supportedCircuits = [\n    CircuitId.AuthV2,\n    CircuitId.AtomicQueryMTPV2OnChain,\n    CircuitId.AtomicQuerySigV2OnChain,\n    CircuitId.AtomicQueryV3OnChain,\n    // Now we support off-chain circuits on-chain\n    // TODO: We need to create validators for them\n    CircuitId.AuthV2,\n    CircuitId.AtomicQueryV3,\n    CircuitId.LinkedMultiQuery10\n  ];\n\n  /**\n   * Creates an instance of ContractRequestHandler.\n   * @param {IPackageManager} _packerMgr - package manager to unpack message envelope\n   * @param {IProofService} _proofService -  proof service to verify zk proofs\n   * @param {IOnChainZKPVerifier} _zkpVerifier - zkp verifier to submit response\n   * @param {IOnChainVerifierMultiQuery} _verifierMultiQuery - verifier multi-query to submit response\n   *\n   */\n\n  constructor(\n    private readonly _packerMgr: IPackageManager,\n    private readonly _proofService: IProofService,\n    private readonly _zkpVerifier: IOnChainZKPVerifier\n  ) {\n    super();\n  }\n\n  async handle(\n    message: BasicMessage,\n    ctx: ContractMessageHandlerOptions\n  ): Promise<BasicMessage | null> {\n    switch (message.type) {\n      case PROTOCOL_MESSAGE_TYPE.CONTRACT_INVOKE_REQUEST_MESSAGE_TYPE: {\n        const ciMessage = message as ContractInvokeRequest;\n        const txHashResponsesMap = await this.handleContractInvoke(ciMessage, ctx);\n        return this.createContractInvokeResponse(ciMessage, txHashResponsesMap);\n      }\n      default:\n        return super.handle(message, ctx);\n    }\n  }\n\n  private async handleContractInvoke(\n    message: ContractInvokeRequest,\n    ctx: ContractMessageHandlerOptions\n  ): Promise<Map<string, ZeroKnowledgeInvokeResponse>> {\n    if (message.type !== PROTOCOL_MESSAGE_TYPE.CONTRACT_INVOKE_REQUEST_MESSAGE_TYPE) {\n      throw new Error('Invalid message type for contract invoke request');\n    }\n\n    const { senderDid: did, ethSigner, challenge } = ctx;\n    if (!ctx.ethSigner) {\n      throw new Error(\"Can't sign transaction. Provide Signer in options.\");\n    }\n\n    const { chain_id } = message.body.transaction_data;\n    const networkFlag = Object.keys(ChainIds).find((key) => ChainIds[key] === chain_id);\n\n    if (!networkFlag) {\n      throw new Error(`Invalid chain id ${chain_id}`);\n    }\n    const verifierDid = message.from ? DID.parse(message.from) : undefined;\n\n    const { scope = [] } = message.body;\n\n    const zkpResponses = await processZeroKnowledgeProofRequests(\n      did,\n      scope,\n      verifierDid,\n      this._proofService,\n      {\n        ethSigner,\n        challenge: challenge ?? BytesHelper.bytesToInt(hexToBytes(await ethSigner.getAddress())),\n        supportedCircuits: this._supportedCircuits\n      }\n    );\n\n    const methodId = message.body.transaction_data.method_id.replace('0x', '');\n    switch (methodId) {\n      case FunctionSignatures.SubmitZKPResponseV2: {\n        const txHashZkpResponsesMap = await this._zkpVerifier.submitZKPResponseV2(\n          ethSigner,\n          message.body.transaction_data,\n          zkpResponses\n        );\n\n        const response = new Map<string, ZeroKnowledgeInvokeResponse>();\n        for (const [txHash, zkpResponses] of txHashZkpResponsesMap) {\n          response.set(txHash, { responses: zkpResponses });\n        }\n        // set txHash of the first response\n        message.body.transaction_data.txHash = txHashZkpResponsesMap.keys().next().value;\n        return response;\n      }\n      case FunctionSignatures.SubmitZKPResponseV1: {\n        const txHashZkpResponseMap = await this._zkpVerifier.submitZKPResponse(\n          ethSigner,\n          message.body.transaction_data,\n          zkpResponses\n        );\n        const response = new Map<string, ZeroKnowledgeInvokeResponse>();\n        for (const [txHash, zkpResponse] of txHashZkpResponseMap) {\n          response.set(txHash, { responses: [zkpResponse] });\n        }\n        // set txHash of the first response\n        message.body.transaction_data.txHash = txHashZkpResponseMap.keys().next().value;\n        return response;\n      }\n      case FunctionSignatures.SubmitResponse: {\n        // We need to\n        // 1. Generate auth proof from message.body.accept -> authResponse\n        // 2. Generate proofs for each query in scope -> zkpResponses\n\n        // Build auth response from accept\n        if (!message.to) {\n          throw new Error(`failed message. empty 'to' field`);\n        }\n\n        // Get first supported accept profile and pass it to processProofAuth\n        const acceptProfile = this.getFirstSupportedProfile(\n          PROTOCOL_MESSAGE_TYPE.CONTRACT_INVOKE_REQUEST_MESSAGE_TYPE,\n          message.body.accept\n        );\n\n        const identifier = DID.parse(message.to);\n\n        const { authProof } = await processProofAuth(identifier, this._proofService, {\n          supportedCircuits: this._supportedCircuits,\n          acceptProfile,\n          senderAddress: await ethSigner.getAddress(),\n          zkpResponses: zkpResponses\n        });\n\n        // we return txHash because responsesMap could be empty if there are no queries in scope\n        const txHashZkpResponsesMap = await this._zkpVerifier.submitResponse(\n          ethSigner,\n          message.body.transaction_data,\n          zkpResponses,\n          authProof\n        );\n        message.body.transaction_data.txHash = txHashZkpResponsesMap.keys().next().value;\n\n        return txHashZkpResponsesMap;\n      }\n      default:\n        throw new Error(\n          `Not supported method id. Only '${FunctionSignatures.SubmitZKPResponseV1}, ${FunctionSignatures.SubmitZKPResponseV2} and ${FunctionSignatures.SubmitResponse} are supported.'`\n        );\n    }\n  }\n\n  private getFirstSupportedProfile(\n    responseType: string,\n    profile?: string[] | undefined\n  ): AcceptProfile {\n    if (profile?.length) {\n      for (const acceptProfileString of profile) {\n        // 1. check protocol version\n        const acceptProfile = parseAcceptProfile(acceptProfileString);\n        const responseTypeVersion = Number(responseType.split('/').at(-2));\n        if (\n          acceptProfile.protocolVersion !== ProtocolVersion.V1 ||\n          (acceptProfile.protocolVersion === ProtocolVersion.V1 &&\n            (responseTypeVersion < 1 || responseTypeVersion >= 2))\n        ) {\n          continue;\n        }\n        // 2. check packer support\n        if (this._packerMgr.isProfileSupported(acceptProfile.env, acceptProfileString)) {\n          return acceptProfile;\n        }\n      }\n    }\n\n    // if we don't have supported profiles, we use default\n    return defaultAcceptProfile;\n  }\n\n  /**\n   * unpacks contract-invoke request\n   * @beta\n   * @param {Uint8Array} request - raw byte message\n   * @returns `Promise<ContractInvokeRequest>`\n   */\n  async parseContractInvokeRequest(request: Uint8Array): Promise<ContractInvokeRequest> {\n    const { unpackedMessage: message } = await this._packerMgr.unpack(request);\n    const ciRequest = message as unknown as ContractInvokeRequest;\n    if (message.type !== PROTOCOL_MESSAGE_TYPE.CONTRACT_INVOKE_REQUEST_MESSAGE_TYPE) {\n      throw new Error('Invalid media type');\n    }\n    ciRequest.body.scope = ciRequest.body.scope || [];\n    return ciRequest;\n  }\n\n  /**\n   * creates contract invoke response\n   * @private\n   * @beta\n   * @param {ContractInvokeRequest} request - ContractInvokeRequest\n   * @param { Map<string, ZeroKnowledgeInvokeResponse>} responses - map tx hash to array of ZeroKnowledgeInvokeResponse\n   * @returns `Promise<ContractInvokeResponse>`\n   */\n  private async createContractInvokeResponse(\n    request: ContractInvokeRequest,\n    txHashToZkpResponseMap: Map<string, ZeroKnowledgeInvokeResponse>\n  ): Promise<ContractInvokeResponse> {\n    const contractInvokeResponse: ContractInvokeResponse = {\n      id: request.id,\n      thid: request.thid,\n      type: PROTOCOL_MESSAGE_TYPE.CONTRACT_INVOKE_RESPONSE_MESSAGE_TYPE,\n      from: request.to,\n      to: request.from,\n      body: {\n        transaction_data: request.body.transaction_data,\n        scope: []\n      },\n      created_time: getUnixTimestamp(new Date())\n    };\n    for (const [txHash, zkpResponses] of txHashToZkpResponseMap) {\n      for (const zkpResponse of zkpResponses.responses) {\n        contractInvokeResponse.body.scope.push({\n          txHash,\n          ...zkpResponse\n        });\n      }\n      contractInvokeResponse.body = {\n        ...contractInvokeResponse.body,\n        crossChainProof: zkpResponses.crossChainProof,\n        authProof: zkpResponses.authProof\n      };\n    }\n    return contractInvokeResponse;\n  }\n\n  /**\n   * handle contract invoke request\n   * supports only 0xb68967e2 method id\n   * @beta\n   * @deprecated\n   * @param {did} did  - sender DID\n   * @param {ContractInvokeRequest} request  - contract invoke request\n   * @param {ContractInvokeHandlerOptions} opts - handler options\n   * @returns {Map<string, ZeroKnowledgeProofResponse>}` - map of transaction hash - ZeroKnowledgeProofResponse\n   */\n  async handleContractInvokeRequest(\n    did: DID,\n    request: Uint8Array,\n    opts: ContractInvokeHandlerOptions\n  ): Promise<Map<string, ZeroKnowledgeProofResponse>> {\n    const ciRequest = await this.parseContractInvokeRequest(request);\n    if (!opts.allowExpiredMessages) {\n      verifyExpiresTime(ciRequest);\n    }\n    if (ciRequest.body.transaction_data.method_id !== FunctionSignatures.SubmitZKPResponseV1) {\n      throw new Error(`please use handle method to work with other method ids`);\n    }\n\n    if (ciRequest.type !== PROTOCOL_MESSAGE_TYPE.CONTRACT_INVOKE_REQUEST_MESSAGE_TYPE) {\n      throw new Error('Invalid message type for contract invoke request');\n    }\n\n    const { ethSigner, challenge } = opts;\n    if (!ethSigner) {\n      throw new Error(\"Can't sign transaction. Provide Signer in options.\");\n    }\n\n    const { chain_id } = ciRequest.body.transaction_data;\n    const networkFlag = Object.keys(ChainIds).find((key) => ChainIds[key] === chain_id);\n\n    if (!networkFlag) {\n      throw new Error(`Invalid chain id ${chain_id}`);\n    }\n    const verifierDid = ciRequest.from ? DID.parse(ciRequest.from) : undefined;\n    const zkpResponses = await processZeroKnowledgeProofRequests(\n      did,\n      ciRequest?.body?.scope,\n      verifierDid,\n      this._proofService,\n      { ethSigner, challenge, supportedCircuits: this._supportedCircuits }\n    );\n    return this._zkpVerifier.submitZKPResponse(\n      ethSigner,\n      ciRequest.body.transaction_data,\n      zkpResponses\n    );\n  }\n}\n","import { MediaType } from '../constants';\nimport { PROTOCOL_MESSAGE_TYPE } from '../constants';\n\nimport {\n  CredentialIssuanceMessage,\n  CredentialRefreshMessage,\n  IPackageManager,\n  ZKPPackerParams\n} from '../types';\n\nimport { RefreshServiceType, W3CCredential } from '../../verifiable';\nimport { byteEncoder } from '../../utils';\nimport { proving, ProvingMethodAlg } from '@iden3/js-jwz';\nimport { DID } from '@iden3/js-iden3-core';\nimport { ICredentialWallet } from '../../credentials';\nimport { CircuitId } from '../../circuits';\nimport * as uuid from 'uuid';\n\n/**\n * RefreshHandlerOptions contains options for RefreshHandler\n * @public\n * @interface   RefreshHandlerOptions\n */\nexport interface RefreshHandlerOptions {\n  packageManager: IPackageManager;\n  credentialWallet?: ICredentialWallet;\n}\n\n/**\n *\n * RefreshOptions contains options for refreshCredential call\n *\n * @public\n * @interface RefreshOptions\n */\nexport interface RefreshOptions {\n  reason?: string;\n}\n\n/**\n * Interface to work with credential refresh handler\n *\n * @public\n * @interface IRefreshHandler\n */\nexport interface IRefreshHandler {\n  /**\n   * refresh credential\n   *\n   * @param {W3CCredential} credential - credential to refresh\n   * @param {RefreshOptions} opts - options\n   * @returns {Promise<W3CCredential>}\n   */\n  refreshCredential(credential: W3CCredential, opts?: RefreshOptions): Promise<W3CCredential>;\n}\n/**\n *\n * Allows to refresh credential from refresh service and return refreshed credential\n *\n * @public\n\n * @class RefreshHandler\n * @implements implements RefreshHandler interface\n */\nexport class RefreshHandler implements IRefreshHandler {\n  /**\n   * Creates an instance of RefreshHandler.\n   * @param {RefreshHandlerOptions} _options - refresh handler options\n   */\n  constructor(private readonly _options: RefreshHandlerOptions) {}\n\n  async refreshCredential(\n    credential: W3CCredential,\n    opts?: RefreshOptions\n  ): Promise<W3CCredential> {\n    if (!credential.refreshService) {\n      throw new Error('refreshService not specified for W3CCredential');\n    }\n    if (credential.refreshService.type !== RefreshServiceType.Iden3RefreshService2023) {\n      throw new Error(`refresh service type ${credential.refreshService.type} is not supported`);\n    }\n\n    const otherIdentifier = credential.credentialSubject.id as string;\n\n    if (!otherIdentifier) {\n      throw new Error('self credentials do not support refresh');\n    }\n\n    const senderDID = DID.parse(otherIdentifier);\n\n    const zkpParams: ZKPPackerParams = {\n      senderDID,\n      provingMethodAlg: new ProvingMethodAlg(\n        proving.provingMethodGroth16AuthV2Instance.methodAlg.alg,\n        CircuitId.AuthV2\n      )\n    };\n\n    const refreshMsg: CredentialRefreshMessage = {\n      id: uuid.v4(),\n      typ: MediaType.ZKPMessage,\n      type: PROTOCOL_MESSAGE_TYPE.CREDENTIAL_REFRESH_MESSAGE_TYPE,\n      thid: uuid.v4(),\n      body: {\n        id: credential.id,\n        reason: opts?.reason ?? 'credential is expired'\n      },\n      from: otherIdentifier,\n      to: credential.issuer\n    };\n\n    const msgBytes = byteEncoder.encode(JSON.stringify(refreshMsg));\n    const jwzToken = await this._options.packageManager.pack(\n      MediaType.ZKPMessage,\n      msgBytes,\n      zkpParams\n    );\n    const resp = await fetch(credential.refreshService.id, {\n      method: 'post',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: jwzToken\n    });\n\n    if (resp.status !== 200) {\n      throw new Error(`could not refresh W3C credential, return status ${resp.status}`);\n    }\n\n    const respBody: CredentialIssuanceMessage = await resp.json();\n\n    if (!respBody.body?.credential) {\n      throw new Error('no credential in CredentialIssuanceMessage response');\n    }\n\n    return W3CCredential.fromJSON(respBody.body.credential);\n  }\n}\n","import { PROTOCOL_MESSAGE_TYPE } from '../constants';\nimport { MediaType } from '../constants';\nimport {\n  BasicMessage,\n  IPackageManager,\n  JWSPackerParams,\n  RevocationStatusRequestMessage,\n  RevocationStatusResponseMessage\n} from '../types';\n\nimport { DID } from '@iden3/js-iden3-core';\nimport * as uuid from 'uuid';\nimport { RevocationStatus } from '../../verifiable';\nimport { TreeState } from '../../circuits';\nimport { byteEncoder } from '../../utils';\nimport { proving } from '@iden3/js-jwz';\nimport { IIdentityWallet } from '../../identity';\nimport {\n  AbstractMessageHandler,\n  BasicHandlerOptions,\n  IProtocolMessageHandler\n} from './message-handler';\nimport { verifyExpiresTime } from './common';\n\n/**\n * Defines the options for a RevocationStatusMessageHandler.\n * @property senderDid - The DID (Decentralized Identifier) to be used.\n * @property mediaType - The media type to be used.\n * @property packerOptions - Optional parameters for the JWS packer.\n * @property treeState - Optional tree state to be used.\n */\nexport type RevocationStatusMessageHandlerOptions = {\n  senderDid: DID;\n  mediaType: MediaType;\n  packerOptions?: JWSPackerParams;\n  treeState?: TreeState;\n};\n\n/**\n * Interface that allows the processing of the revocation status\n *\n * @interface IRevocationStatusHandler\n */\nexport interface IRevocationStatusHandler {\n  /**\n   * unpacks revocation status request\n   * @param {Uint8Array} request - raw byte message\n   * @returns `Promise<RevocationStatusRequestMessage>`\n   */\n  parseRevocationStatusRequest(request: Uint8Array): Promise<RevocationStatusRequestMessage>;\n\n  /**\n   * handle revocation status request\n   * @param {did} did  - sender DID\n   * @param {Uint8Array} request - raw byte message\n   * @param {RevocationStatusHandlerOptions} opts - handler options\n   * @returns {Promise<Uint8Array>}` - revocation status response message\n   */\n  handleRevocationStatusRequest(\n    did: DID,\n    request: Uint8Array,\n    opts?: RevocationStatusHandlerOptions\n  ): Promise<Uint8Array>;\n}\n\n/** RevocationStatusHandlerOptions represents revocation status handler options */\nexport type RevocationStatusHandlerOptions = BasicHandlerOptions & {\n  mediaType: MediaType;\n  packerOptions?: JWSPackerParams;\n  treeState?: TreeState;\n};\n\n/**\n *\n * Allows to process RevocationStatusRequest protocol message\n *\n\n * @class RevocationStatusHandler\n * @implements implements IRevocationStatusHandler interface\n */\nexport class RevocationStatusHandler\n  extends AbstractMessageHandler\n  implements IRevocationStatusHandler, IProtocolMessageHandler\n{\n  /**\n   * Creates an instance of RevocationStatusHandler.\n   * @param {IPackageManager} _packerMgr - package manager to unpack message envelope\n   * @param {IIdentityWallet} _identityWallet - identity wallet\n   *\n   */\n  constructor(\n    private readonly _packerMgr: IPackageManager,\n    private readonly _identityWallet: IIdentityWallet\n  ) {\n    super();\n  }\n\n  public handle(\n    message: BasicMessage,\n    context: RevocationStatusMessageHandlerOptions\n  ): Promise<BasicMessage | null> {\n    if (!context.senderDid) {\n      throw new Error('DID is required');\n    }\n\n    if (!context.mediaType) {\n      throw new Error('mediaType is required');\n    }\n\n    switch (message.type) {\n      case PROTOCOL_MESSAGE_TYPE.REVOCATION_STATUS_REQUEST_MESSAGE_TYPE:\n        return this.handleRevocationStatusRequestMessage(\n          message as RevocationStatusRequestMessage,\n          context\n        );\n      default:\n        return super.handle(message, context);\n    }\n  }\n\n  private async handleRevocationStatusRequestMessage(\n    rsRequest: RevocationStatusRequestMessage,\n    context: RevocationStatusMessageHandlerOptions\n  ): Promise<BasicMessage | null> {\n    if (!rsRequest.to) {\n      throw new Error(`failed request. empty 'to' field`);\n    }\n\n    if (!rsRequest.from) {\n      throw new Error(`failed request. empty 'from' field`);\n    }\n\n    if (!rsRequest.body?.revocation_nonce) {\n      throw new Error(`failed request. empty 'revocation_nonce' field`);\n    }\n\n    const issuerDID = DID.parse(rsRequest.to);\n\n    const mtpWithTreeState = await this._identityWallet.generateNonRevocationMtpWithNonce(\n      issuerDID,\n      BigInt(rsRequest.body.revocation_nonce),\n      context.treeState\n    );\n    const treeState = mtpWithTreeState.treeState;\n    const revStatus: RevocationStatus = {\n      issuer: {\n        state: treeState?.state.string(),\n        claimsTreeRoot: treeState.claimsRoot.string(),\n        revocationTreeRoot: treeState.revocationRoot.string(),\n        rootOfRoots: treeState.rootOfRoots.string()\n      },\n      mtp: mtpWithTreeState.proof\n    };\n\n    const guid = uuid.v4();\n\n    const response: RevocationStatusResponseMessage = {\n      id: guid,\n      typ: MediaType.PlainMessage,\n      type: PROTOCOL_MESSAGE_TYPE.REVOCATION_STATUS_RESPONSE_MESSAGE_TYPE,\n      thid: rsRequest.thid ?? guid,\n      body: revStatus,\n      from: context.senderDid.string(),\n      to: rsRequest.from\n    };\n\n    return response as BasicMessage;\n  }\n\n  /**\n   * @inheritdoc IRevocationStatusHandler#parseRevocationStatusRequest\n   */\n  async parseRevocationStatusRequest(request: Uint8Array): Promise<RevocationStatusRequestMessage> {\n    const { unpackedMessage: message } = await this._packerMgr.unpack(request);\n    const ciRequest = message as unknown as RevocationStatusRequestMessage;\n    if (message.type !== PROTOCOL_MESSAGE_TYPE.REVOCATION_STATUS_REQUEST_MESSAGE_TYPE) {\n      throw new Error('Invalid media type');\n    }\n    return ciRequest;\n  }\n\n  /**\n   * @inheritdoc IRevocationStatusHandler#handleRevocationStatusRequest\n   */\n  async handleRevocationStatusRequest(\n    did: DID,\n    request: Uint8Array,\n    opts?: RevocationStatusHandlerOptions\n  ): Promise<Uint8Array> {\n    if (!opts) {\n      opts = {\n        mediaType: MediaType.PlainMessage\n      };\n    }\n\n    if (opts.mediaType === MediaType.SignedMessage && !opts.packerOptions) {\n      throw new Error(`jws packer options are required for ${MediaType.SignedMessage}`);\n    }\n\n    const rsRequest = await this.parseRevocationStatusRequest(request);\n    if (!opts.allowExpiredMessages) {\n      verifyExpiresTime(rsRequest);\n    }\n    const response = await this.handleRevocationStatusRequestMessage(rsRequest, {\n      senderDid: did,\n      mediaType: opts.mediaType,\n      packerOptions: opts.packerOptions,\n      treeState: opts.treeState\n    });\n\n    const packerOpts =\n      opts.mediaType === MediaType.SignedMessage\n        ? opts.packerOptions\n        : {\n            provingMethodAlg: proving.provingMethodGroth16AuthV2Instance.methodAlg\n          };\n\n    if (!rsRequest.to) {\n      throw new Error(`failed request. empty 'to' field`);\n    }\n\n    const senderDID = DID.parse(rsRequest.to);\n    return this._packerMgr.pack(opts.mediaType, byteEncoder.encode(JSON.stringify(response)), {\n      senderDID,\n      ...packerOpts\n    });\n  }\n}\n","import { PROTOCOL_MESSAGE_TYPE, MediaType } from '../constants';\nimport {\n  BasicMessage,\n  CredentialOffer,\n  CredentialsOfferMessage,\n  DIDDocument,\n  IPackageManager,\n  PackerParams\n} from '../types';\n\nimport { DID, getUnixTimestamp } from '@iden3/js-iden3-core';\nimport * as uuid from 'uuid';\nimport { proving } from '@iden3/js-jwz';\nimport {\n  Proposal,\n  ProposalRequestCredential,\n  ProposalRequestMessage,\n  ProposalMessage\n} from '../types/protocol/proposal-request';\nimport { IIdentityWallet } from '../../identity';\nimport { byteEncoder } from '../../utils';\nimport { W3CCredential } from '../../verifiable';\nimport {\n  AbstractMessageHandler,\n  BasicHandlerOptions,\n  IProtocolMessageHandler\n} from './message-handler';\nimport { verifyExpiresTime } from './common';\n\n/** @beta ProposalRequestCreationOptions represents proposal-request creation options */\nexport type ProposalRequestCreationOptions = {\n  credentials: ProposalRequestCredential[];\n  did_doc?: DIDDocument;\n  expires_time?: Date;\n};\n\n/** @beta ProposalCreationOptions represents proposal creation options */\nexport type ProposalCreationOptions = {\n  expires_time?: Date;\n};\n\n/**\n * @beta\n * createProposalRequest is a function to create protocol proposal-request protocol message\n * @param {DID} sender - sender did\n * @param {DID} receiver - receiver did\n * @param {ProposalRequestCreationOptions} opts - creation options\n * @returns `Promise<ProposalRequestMessage>`\n */\nexport function createProposalRequest(\n  sender: DID,\n  receiver: DID,\n  opts: ProposalRequestCreationOptions\n): ProposalRequestMessage {\n  const uuidv4 = uuid.v4();\n  const request: ProposalRequestMessage = {\n    id: uuidv4,\n    thid: uuidv4,\n    from: sender.string(),\n    to: receiver.string(),\n    typ: MediaType.PlainMessage,\n    type: PROTOCOL_MESSAGE_TYPE.PROPOSAL_REQUEST_MESSAGE_TYPE,\n    body: opts,\n    created_time: getUnixTimestamp(new Date()),\n    expires_time: opts?.expires_time ? getUnixTimestamp(opts.expires_time) : undefined\n  };\n  return request;\n}\n\n/**\n * @beta\n * createProposal is a function to create protocol proposal protocol message\n * @param {DID} sender - sender did\n * @param {DID} receiver - receiver did\n * @param {Proposal[]} proposals - proposals\n * @returns `Promise<ProposalRequestMessage>`\n */\nexport function createProposal(\n  sender: DID,\n  receiver: DID,\n  proposals?: Proposal[],\n  opts?: ProposalCreationOptions\n): ProposalMessage {\n  const uuidv4 = uuid.v4();\n  const request: ProposalMessage = {\n    id: uuidv4,\n    thid: uuidv4,\n    from: sender.string(),\n    to: receiver.string(),\n    typ: MediaType.PlainMessage,\n    type: PROTOCOL_MESSAGE_TYPE.PROPOSAL_MESSAGE_TYPE,\n    body: {\n      proposals: proposals || []\n    },\n    created_time: getUnixTimestamp(new Date()),\n    expires_time: opts?.expires_time ? getUnixTimestamp(opts.expires_time) : undefined\n  };\n  return request;\n}\n\n/**\n * @beta\n * Interface that allows the processing of the proposal-request\n *\n * @interface ICredentialProposalHandler\n */\nexport interface ICredentialProposalHandler {\n  /**\n   * @beta\n   * unpacks proposal-request\n   * @param {Uint8Array} request - raw byte message\n   * @returns `Promise<ProposalRequestMessage>`\n   */\n  parseProposalRequest(request: Uint8Array): Promise<ProposalRequestMessage>;\n\n  /**\n   *  @beta\n   * handle proposal-request\n   * @param {Uint8Array} request - raw byte message\n   * @param {ProposalRequestHandlerOptions} opts - handler options\n   * @returns {Promise<Uint8Array>}` - proposal response message\n   */\n  handleProposalRequest(\n    request: Uint8Array,\n    opts?: ProposalRequestHandlerOptions\n  ): Promise<Uint8Array>;\n\n  /**\n     * @beta\n     * handle proposal protocol message\n     * @param {ProposalMessage} proposal  - proposal message\n     * @param {ProposalHandlerOptions} opts - options\n     * @returns `Promise<{\n      proposal: ProposalMessage;\n    }>`\n     */\n  handleProposal(\n    proposal: ProposalMessage,\n    opts?: ProposalHandlerOptions\n  ): Promise<{\n    proposal: ProposalMessage;\n  }>;\n}\n\n/** @beta ProposalRequestHandlerOptions represents proposal-request handler options */\nexport type ProposalRequestHandlerOptions = BasicHandlerOptions;\n\n/** @beta ProposalHandlerOptions represents proposal handler options */\nexport type ProposalHandlerOptions = BasicHandlerOptions & {\n  proposalRequest?: ProposalRequestMessage;\n};\n\n/** @beta CredentialProposalHandlerParams represents credential proposal handler params */\nexport type CredentialProposalHandlerParams = {\n  agentUrl: string;\n  proposalResolverFn: (context: string, type: string) => Promise<Proposal>;\n  packerParams: PackerParams;\n};\n\n/**\n *\n * Allows to process ProposalRequest protocol message\n * @beta\n * @class CredentialProposalHandler\n * @implements implements ICredentialProposalHandler interface\n */\nexport class CredentialProposalHandler\n  extends AbstractMessageHandler\n  implements ICredentialProposalHandler, IProtocolMessageHandler\n{\n  /**\n   * @beta Creates an instance of CredentialProposalHandler.\n   * @param {IPackageManager} _packerMgr - package manager to unpack message envelope\n   * @param {IIdentityWallet} _identityWallet - identity wallet\n   * @param {CredentialProposalHandlerParams} _params - credential proposal handler params\n   *\n   */\n\n  constructor(\n    private readonly _packerMgr: IPackageManager,\n    private readonly _identityWallet: IIdentityWallet,\n    private readonly _params: CredentialProposalHandlerParams\n  ) {\n    super();\n  }\n\n  public async handle(\n    message: BasicMessage,\n    context: ProposalRequestHandlerOptions\n  ): Promise<BasicMessage | null> {\n    switch (message.type) {\n      case PROTOCOL_MESSAGE_TYPE.PROPOSAL_REQUEST_MESSAGE_TYPE:\n        return (await this.handleProposalRequestMessage(\n          message as unknown as ProposalRequestMessage,\n          context\n        )) as BasicMessage;\n      default:\n        return super.handle(message, context as { [key: string]: unknown });\n    }\n  }\n\n  /**\n   * @inheritdoc ICredentialProposalHandler#parseProposalRequest\n   */\n  async parseProposalRequest(request: Uint8Array): Promise<ProposalRequestMessage> {\n    const { unpackedMessage: message } = await this._packerMgr.unpack(request);\n    const proposalRequest = message as unknown as ProposalRequestMessage;\n    if (message.type !== PROTOCOL_MESSAGE_TYPE.PROPOSAL_REQUEST_MESSAGE_TYPE) {\n      throw new Error('Invalid media type');\n    }\n    return proposalRequest;\n  }\n\n  private async handleProposalRequestMessage(\n    proposalRequest: ProposalRequestMessage,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ctx?: ProposalRequestHandlerOptions\n  ): Promise<ProposalMessage | CredentialsOfferMessage | undefined> {\n    if (!proposalRequest.to) {\n      throw new Error(`failed request. empty 'to' field`);\n    }\n\n    if (!proposalRequest.from) {\n      throw new Error(`failed request. empty 'from' field`);\n    }\n\n    if (!proposalRequest.body?.credentials?.length) {\n      throw new Error(`failed request. no 'credentials' in body`);\n    }\n\n    let credOfferMessage: CredentialsOfferMessage | undefined = undefined;\n    let proposalMessage: ProposalMessage | undefined = undefined;\n\n    for (let i = 0; i < proposalRequest.body.credentials.length; i++) {\n      const cred = proposalRequest.body.credentials[i];\n\n      // check if there is credentials in the wallet\n      let credsFromWallet: W3CCredential[] = [];\n\n      try {\n        credsFromWallet = await this._identityWallet.credentialWallet.findByQuery({\n          credentialSubject: {\n            id: {\n              $eq: proposalRequest.from\n            }\n          },\n          type: cred.type,\n          context: cred.context,\n          allowedIssuers: [proposalRequest.to]\n        });\n      } catch (e) {\n        if ((e as Error).message !== 'no credential satisfied query') {\n          throw e;\n        }\n      }\n\n      if (credsFromWallet.length) {\n        const guid = uuid.v4();\n        if (!credOfferMessage) {\n          credOfferMessage = {\n            id: guid,\n            typ: this._params.packerParams.mediaType,\n            type: PROTOCOL_MESSAGE_TYPE.CREDENTIAL_OFFER_MESSAGE_TYPE,\n            thid: proposalRequest.thid ?? guid,\n            body: {\n              url: this._params.agentUrl,\n              credentials: []\n            },\n            from: proposalRequest.to,\n            to: proposalRequest.from\n          };\n        }\n\n        credOfferMessage.body.credentials.push(\n          ...credsFromWallet.map<CredentialOffer>((c) => ({\n            id: c.id,\n            description: ''\n          }))\n        );\n        continue;\n      }\n\n      // credential not found in the wallet, prepare proposal protocol message\n      const proposal = await this._params.proposalResolverFn(cred.context, cred.type);\n      if (!proposal) {\n        throw new Error(`can't resolve Proposal for type: ${cred.type}, context: ${cred.context}`);\n      }\n      if (!proposalMessage) {\n        const guid = uuid.v4();\n        proposalMessage = {\n          id: guid,\n          typ: this._params.packerParams.mediaType,\n          type: PROTOCOL_MESSAGE_TYPE.PROPOSAL_MESSAGE_TYPE,\n          thid: proposalRequest.thid ?? guid,\n          body: {\n            proposals: []\n          },\n          from: proposalRequest.to,\n          to: proposalRequest.from\n        };\n      }\n      proposalMessage.body?.proposals.push(proposal);\n    }\n\n    return proposalMessage ?? credOfferMessage;\n  }\n\n  /**\n   * @inheritdoc ICredentialProposalHandler#handleProposalRequest\n   */\n  async handleProposalRequest(\n    request: Uint8Array,\n    //eslint-disable-next-line @typescript-eslint/no-unused-vars\n    opts?: ProposalRequestHandlerOptions\n  ): Promise<Uint8Array> {\n    if (\n      this._params.packerParams.mediaType === MediaType.SignedMessage &&\n      !this._params.packerParams.packerOptions\n    ) {\n      throw new Error(`jws packer options are required for ${MediaType.SignedMessage}`);\n    }\n\n    const proposalRequest = await this.parseProposalRequest(request);\n    if (!proposalRequest.from) {\n      throw new Error(`failed request. empty 'from' field`);\n    }\n    if (!opts?.allowExpiredMessages) {\n      verifyExpiresTime(proposalRequest);\n    }\n\n    const senderDID = DID.parse(proposalRequest.from);\n    const message = await this.handleProposalRequestMessage(proposalRequest);\n    const response = byteEncoder.encode(JSON.stringify(message));\n\n    const packerOpts =\n      this._params.packerParams.mediaType === MediaType.SignedMessage\n        ? this._params.packerParams.packerOptions\n        : {\n            provingMethodAlg: proving.provingMethodGroth16AuthV2Instance.methodAlg\n          };\n\n    return this._packerMgr.pack(this._params.packerParams.mediaType, response, {\n      senderDID,\n      ...packerOpts\n    });\n  }\n\n  /**\n   * @inheritdoc ICredentialProposalHandler#handleProposal\n   */\n  async handleProposal(proposal: ProposalMessage, opts?: ProposalHandlerOptions) {\n    if (!opts?.allowExpiredMessages) {\n      verifyExpiresTime(proposal);\n    }\n    if (opts?.proposalRequest && opts.proposalRequest.from !== proposal.to) {\n      throw new Error(\n        `sender of the request is not a target of response - expected ${opts.proposalRequest.from}, given ${proposal.to}`\n      );\n    }\n    return { proposal };\n  }\n}\n","import { PROTOCOL_MESSAGE_TYPE } from '../constants';\nimport { MediaType } from '../constants';\nimport { BasicMessage, IPackageManager, PackerParams } from '../types';\n\nimport { DID, getUnixTimestamp } from '@iden3/js-iden3-core';\nimport * as uuid from 'uuid';\nimport { proving } from '@iden3/js-jwz';\nimport { byteEncoder } from '../../utils';\nimport {\n  AbstractMessageHandler,\n  BasicHandlerOptions,\n  IProtocolMessageHandler\n} from './message-handler';\nimport {\n  EthereumEip712Signature2021,\n  Iden3PaymentCryptoV1,\n  Iden3PaymentRailsERC20RequestV1,\n  Iden3PaymentRailsERC20V1,\n  Iden3PaymentRailsRequestV1,\n  Iden3PaymentRailsV1,\n  Iden3PaymentRequestCryptoV1,\n  MultiChainPaymentConfig,\n  PaymentMessage,\n  PaymentRequestInfo,\n  PaymentRequestMessage,\n  PaymentRequestTypeUnion,\n  PaymentTypeUnion\n} from '../types/protocol/payment';\nimport {\n  PaymentFeatures,\n  PaymentRequestDataType,\n  PaymentType,\n  SupportedPaymentProofType\n} from '../../verifiable';\nimport { Signer, ethers } from 'ethers';\nimport { Resolvable } from 'did-resolver';\nimport { verifyExpiresTime } from './common';\n\n/** @beta PaymentRequestCreationOptions represents payment-request creation options */\nexport type PaymentRequestCreationOptions = {\n  expires_time?: Date;\n};\n\n/** @beta PaymentCreationOptions represents payment creation options */\nexport type PaymentCreationOptions = {\n  expires_time?: Date;\n};\n\n/**\n * @beta\n * createPaymentRequest is a function to create protocol payment-request message\n * @param {DID} sender - sender did\n * @param {DID} receiver - receiver did\n * @param {string} agent - agent URL\n * @param {PaymentRequestInfo[]} payments - payments\n * @returns `PaymentRequestMessage`\n */\nexport function createPaymentRequest(\n  sender: DID,\n  receiver: DID,\n  agent: string,\n  payments: PaymentRequestInfo[],\n  opts?: PaymentRequestCreationOptions\n): PaymentRequestMessage {\n  const uuidv4 = uuid.v4();\n  const request: PaymentRequestMessage = {\n    id: uuidv4,\n    thid: uuidv4,\n    from: sender.string(),\n    to: receiver.string(),\n    typ: MediaType.PlainMessage,\n    type: PROTOCOL_MESSAGE_TYPE.PAYMENT_REQUEST_MESSAGE_TYPE,\n    body: {\n      agent,\n      payments\n    },\n    created_time: getUnixTimestamp(new Date()),\n    expires_time: opts?.expires_time ? getUnixTimestamp(opts.expires_time) : undefined\n  };\n  return request;\n}\n\nexport async function verifyEIP712TypedData(\n  data: Iden3PaymentRailsRequestV1 | Iden3PaymentRailsERC20RequestV1,\n  resolver: Resolvable\n): Promise<string> {\n  const paymentData =\n    data.type === PaymentRequestDataType.Iden3PaymentRailsRequestV1\n      ? {\n          recipient: data.recipient,\n          amount: data.amount,\n          expirationDate: getUnixTimestamp(new Date(data.expirationDate)),\n          nonce: data.nonce,\n          metadata: '0x'\n        }\n      : {\n          tokenAddress: data.tokenAddress,\n          recipient: data.recipient,\n          amount: data.amount,\n          expirationDate: getUnixTimestamp(new Date(data.expirationDate)),\n          nonce: data.nonce,\n          metadata: '0x'\n        };\n  const proof = Array.isArray(data.proof) ? data.proof[0] : data.proof;\n  const typesFetchResult = await fetch(proof.eip712.types);\n  const types = await typesFetchResult.json();\n  delete types.EIP712Domain;\n  const recovered = ethers.verifyTypedData(\n    proof.eip712.domain,\n    types,\n    paymentData,\n    proof.proofValue\n  );\n\n  const { didDocument } = await resolver.resolve(proof.verificationMethod);\n  if (didDocument?.verificationMethod) {\n    for (const verificationMethod of didDocument.verificationMethod) {\n      if (\n        verificationMethod.blockchainAccountId?.split(':').slice(-1)[0].toLowerCase() ===\n        recovered.toLowerCase()\n      ) {\n        return recovered;\n      }\n    }\n  } else {\n    throw new Error('failed request. issuer DIDDocument does not contain any verificationMethods');\n  }\n\n  throw new Error(`failed request. no matching verificationMethod`);\n}\n\n/**\n * @beta\n * PaymentRailsInfo represents payment info for payment rails\n */\nexport type PaymentRailsInfo = {\n  credentials: {\n    type: string;\n    context: string;\n  }[];\n  description?: string;\n  options: PaymentRailsOptionInfo[];\n};\n\n/**\n * @beta\n * PaymentRailsOptionInfo represents option info for payment rails\n */\nexport type PaymentRailsOptionInfo = {\n  optionId: string;\n  chainId: string;\n  nonce: bigint;\n  amount: string;\n  expirationDate?: Date;\n};\n\n/**\n * @beta\n * createPayment is a function to create protocol payment message\n * @param {DID} sender - sender did\n * @param {DID} receiver - receiver did\n * @param {PaymentMessageBody} body - payments\n * @returns `PaymentMessage`\n */\nexport function createPayment(\n  sender: DID,\n  receiver: DID,\n  payments: PaymentTypeUnion[],\n  opts?: PaymentCreationOptions\n): PaymentMessage {\n  const uuidv4 = uuid.v4();\n  const request: PaymentMessage = {\n    id: uuidv4,\n    thid: uuidv4,\n    from: sender.string(),\n    to: receiver.string(),\n    typ: MediaType.PlainMessage,\n    type: PROTOCOL_MESSAGE_TYPE.PAYMENT_MESSAGE_TYPE,\n    body: {\n      payments\n    },\n    created_time: getUnixTimestamp(new Date()),\n    expires_time: opts?.expires_time ? getUnixTimestamp(opts.expires_time) : undefined\n  };\n  return request;\n}\n\n/**\n * @beta\n * Interface that allows the processing of the payment-request and payment protocol messages\n *\n * @interface IPaymentHandler\n */\nexport interface IPaymentHandler {\n  /**\n   * @beta\n   * unpacks payment-request\n   * @param {Uint8Array} request - raw byte message\n   * @returns `Promise<PaymentRequestMessage>`\n   */\n  parsePaymentRequest(request: Uint8Array): Promise<PaymentRequestMessage>;\n\n  /**\n   *  @beta\n   * handle payment-request\n   * @param {Uint8Array} request - raw byte message\n   * @param {PaymentRequestMessageHandlerOptions} opts - handler options\n   * @returns {Promise<Uint8Array>} - agent message or null\n   */\n  handlePaymentRequest(\n    request: Uint8Array,\n    opts: PaymentRequestMessageHandlerOptions\n  ): Promise<Uint8Array | null>;\n\n  /**\n   * @beta\n   * handle payment protocol message\n   * @param {PaymentMessage} payment  - payment message\n   * @param {PaymentHandlerOptions} opts - options\n   * @returns `Promise<void>`\n   */\n  handlePayment(payment: PaymentMessage, opts: PaymentHandlerOptions): Promise<void>;\n\n  /**\n   * @beta\n   * createPaymentRailsV1 is a function to create protocol payment message\n   * @param {DID} sender - sender did\n   * @param {DID} receiver - receiver did\n   * @param {string} agent - agent URL\n   * @param {Signer} signer - receiver did\n   * @param payments - payment options\n   * @returns {Promise<PaymentRequestMessage>}\n   */\n  createPaymentRailsV1(\n    sender: DID,\n    receiver: DID,\n    agent: string,\n    signer: Signer,\n    payments: PaymentRailsInfo[]\n  ): Promise<PaymentRequestMessage>;\n}\n\n/** @beta PaymentRequestMessageHandlerOptions represents payment-request handler options */\nexport type PaymentRequestMessageHandlerOptions = BasicHandlerOptions & {\n  paymentHandler: (data: PaymentRequestTypeUnion) => Promise<string>;\n  /*\n   selected payment nonce (for Iden3PaymentRequestCryptoV1 type it should be equal to Payment id field)\n  */\n  nonce: string;\n  erc20TokenApproveHandler?: (data: Iden3PaymentRailsERC20RequestV1) => Promise<string>;\n};\n\n/** @beta PaymentHandlerOptions represents payment handler options */\nexport type PaymentHandlerOptions = BasicHandlerOptions & {\n  paymentRequest: PaymentRequestMessage;\n  paymentValidationHandler: (txId: string, data: PaymentRequestTypeUnion) => Promise<void>;\n};\n\n/** @beta PaymentHandlerParams represents payment handler params */\nexport type PaymentHandlerParams = {\n  packerParams: PackerParams;\n  documentResolver: Resolvable;\n  multiChainPaymentConfig?: MultiChainPaymentConfig[];\n  /*\n   * allowed signers for payment request (if not provided, any signer is allowed)\n   */\n  allowedSigners?: string[];\n};\n\n/**\n *\n * Allows to process PaymentRequest protocol message\n * @beta\n * @class PaymentHandler\n * @implements implements IPaymentHandler interface\n */\nexport class PaymentHandler\n  extends AbstractMessageHandler\n  implements IPaymentHandler, IProtocolMessageHandler\n{\n  /**\n   * @beta Creates an instance of PaymentHandler.\n   * @param {IPackageManager} _packerMgr - package manager to unpack message envelope\n   * @param {PaymentHandlerParams} _params - payment handler params\n   *\n   */\n\n  constructor(\n    private readonly _packerMgr: IPackageManager,\n    private readonly _params: PaymentHandlerParams\n  ) {\n    super();\n  }\n\n  public async handle(\n    message: BasicMessage,\n    context: PaymentRequestMessageHandlerOptions | PaymentHandlerOptions\n  ): Promise<BasicMessage | null> {\n    switch (message.type) {\n      case PROTOCOL_MESSAGE_TYPE.PAYMENT_REQUEST_MESSAGE_TYPE:\n        return await this.handlePaymentRequestMessage(\n          message as PaymentRequestMessage,\n          context as PaymentRequestMessageHandlerOptions\n        );\n      case PROTOCOL_MESSAGE_TYPE.PAYMENT_MESSAGE_TYPE:\n        await this.handlePayment(message as PaymentMessage, context as PaymentHandlerOptions);\n        return null;\n      default:\n        return super.handle(message, context as { [key: string]: unknown });\n    }\n  }\n\n  /**\n   * @inheritdoc IPaymentHandler#parsePaymentRequest\n   */\n  async parsePaymentRequest(request: Uint8Array): Promise<PaymentRequestMessage> {\n    const { unpackedMessage: message } = await this._packerMgr.unpack(request);\n    const paymentRequest = message as PaymentRequestMessage;\n    if (message.type !== PROTOCOL_MESSAGE_TYPE.PAYMENT_REQUEST_MESSAGE_TYPE) {\n      throw new Error('Invalid media type');\n    }\n    return paymentRequest;\n  }\n\n  private async handlePaymentRequestMessage(\n    paymentRequest: PaymentRequestMessage,\n    ctx: PaymentRequestMessageHandlerOptions\n  ): Promise<BasicMessage | null> {\n    if (!paymentRequest.to) {\n      throw new Error(`failed request. empty 'to' field`);\n    }\n\n    if (!paymentRequest.from) {\n      throw new Error(`failed request. empty 'from' field`);\n    }\n\n    if (!paymentRequest.body.payments?.length) {\n      throw new Error(`failed request. no 'payments' in body`);\n    }\n\n    if (!ctx.paymentHandler) {\n      throw new Error(`please provide payment handler in context`);\n    }\n\n    const senderDID = DID.parse(paymentRequest.to);\n    const receiverDID = DID.parse(paymentRequest.from);\n\n    const payments: PaymentTypeUnion[] = [];\n    for (let i = 0; i < paymentRequest.body.payments.length; i++) {\n      const { data } = paymentRequest.body.payments[i];\n      const selectedPayment = Array.isArray(data)\n        ? data.find((p) => {\n            return p.type === PaymentRequestDataType.Iden3PaymentRequestCryptoV1\n              ? p.id === ctx.nonce\n              : p.nonce === ctx.nonce;\n          })\n        : data;\n\n      if (!selectedPayment) {\n        throw new Error(`failed request. no payment in request for nonce ${ctx.nonce}`);\n      }\n\n      switch (selectedPayment.type) {\n        case PaymentRequestDataType.Iden3PaymentRequestCryptoV1:\n          payments.push(\n            await this.handleIden3PaymentRequestCryptoV1(selectedPayment, ctx.paymentHandler)\n          );\n          break;\n        case PaymentRequestDataType.Iden3PaymentRailsRequestV1:\n          payments.push(\n            await this.handleIden3PaymentRailsRequestV1(selectedPayment, ctx.paymentHandler)\n          );\n          break;\n        case PaymentRequestDataType.Iden3PaymentRailsERC20RequestV1:\n          payments.push(\n            await this.handleIden3PaymentRailsERC20RequestV1(\n              selectedPayment,\n              ctx.paymentHandler,\n              ctx.erc20TokenApproveHandler\n            )\n          );\n          break;\n      }\n    }\n\n    const paymentMessage = createPayment(senderDID, receiverDID, payments);\n    const response = await this.packMessage(paymentMessage, senderDID);\n\n    const agentResult = await fetch(paymentRequest.body.agent, {\n      method: 'POST',\n      body: response,\n      headers: {\n        'Content-Type':\n          this._params.packerParams.mediaType === MediaType.PlainMessage\n            ? 'application/json'\n            : 'application/octet-stream'\n      }\n    });\n\n    const arrayBuffer = await agentResult.arrayBuffer();\n    if (!arrayBuffer.byteLength) {\n      return null;\n    }\n    const { unpackedMessage } = await this._packerMgr.unpack(new Uint8Array(arrayBuffer));\n    return unpackedMessage;\n  }\n\n  /**\n   * @inheritdoc IPaymentHandler#handlePaymentRequest\n   */\n  async handlePaymentRequest(\n    request: Uint8Array,\n    opts: PaymentRequestMessageHandlerOptions\n  ): Promise<Uint8Array | null> {\n    if (\n      this._params.packerParams.mediaType === MediaType.SignedMessage &&\n      !this._params.packerParams.packerOptions\n    ) {\n      throw new Error(`jws packer options are required for ${MediaType.SignedMessage}`);\n    }\n\n    const paymentRequest = await this.parsePaymentRequest(request);\n    if (!paymentRequest.from) {\n      throw new Error(`failed request. empty 'from' field`);\n    }\n\n    if (!paymentRequest.to) {\n      throw new Error(`failed request. empty 'to' field`);\n    }\n    if (!opts?.allowExpiredMessages) {\n      verifyExpiresTime(paymentRequest);\n    }\n    const agentMessage = await this.handlePaymentRequestMessage(paymentRequest, opts);\n    if (!agentMessage) {\n      return null;\n    }\n\n    const senderDID = DID.parse(paymentRequest.to);\n    return this.packMessage(agentMessage, senderDID);\n  }\n\n  /**\n   * @inheritdoc IPaymentHandler#handlePayment\n   */\n  async handlePayment(payment: PaymentMessage, params: PaymentHandlerOptions) {\n    if (!params?.allowExpiredMessages) {\n      verifyExpiresTime(payment);\n    }\n    if (params.paymentRequest.from !== payment.to) {\n      throw new Error(\n        `sender of the request is not a target of response - expected ${params.paymentRequest.from}, given ${payment.to}`\n      );\n    }\n\n    if (!payment.body.payments.length) {\n      throw new Error(`failed request. empty 'payments' field in body`);\n    }\n\n    if (!params.paymentValidationHandler) {\n      throw new Error(`please provide payment validation handler in options`);\n    }\n\n    for (let i = 0; i < payment.body.payments.length; i++) {\n      const p = payment.body.payments[i];\n      const nonce = p.type === PaymentType.Iden3PaymentCryptoV1 ? p.id : p.nonce;\n      const requestDataArr = params.paymentRequest.body.payments\n        .map((r) => (Array.isArray(r.data) ? r.data : [r.data]))\n        .flat();\n      const requestData = requestDataArr.find((r) =>\n        r.type === PaymentRequestDataType.Iden3PaymentRequestCryptoV1\n          ? r.id === nonce\n          : r.nonce === nonce\n      );\n      if (!requestData) {\n        throw new Error(\n          `can't find payment request for payment ${\n            p.type === PaymentType.Iden3PaymentCryptoV1 ? 'id' : 'nonce'\n          } ${nonce}`\n        );\n      }\n      await params.paymentValidationHandler(p.paymentData.txId, requestData);\n    }\n  }\n\n  /**\n   * @inheritdoc IPaymentHandler#createPaymentRailsV1\n   */\n  async createPaymentRailsV1(\n    sender: DID,\n    receiver: DID,\n    agent: string,\n    signer: Signer,\n    payments: PaymentRailsInfo[]\n  ): Promise<PaymentRequestMessage> {\n    const paymentRequestInfo: PaymentRequestInfo[] = [];\n    for (let i = 0; i < payments.length; i++) {\n      const { credentials, description } = payments[i];\n      const dataArr: (Iden3PaymentRailsRequestV1 | Iden3PaymentRailsERC20RequestV1)[] = [];\n      for (let j = 0; j < payments[i].options.length; j++) {\n        const { nonce, amount, chainId, optionId, expirationDate } = payments[i].options[j];\n\n        const multiChainConfig = this._params.multiChainPaymentConfig?.find(\n          (c) => c.chainId === chainId\n        );\n        if (!multiChainConfig) {\n          throw new Error(`failed request. no config for chain ${chainId}`);\n        }\n        const { recipient, paymentRails, options } = multiChainConfig;\n\n        const option = options.find((t) => t.id === optionId);\n        if (!option) {\n          throw new Error(`failed request. no option for id ${optionId}`);\n        }\n        if (\n          option.type === PaymentRequestDataType.Iden3PaymentRailsERC20RequestV1 &&\n          !option.contractAddress\n        ) {\n          throw new Error(`failed request. no token address for option id ${optionId}`);\n        }\n        const expirationDateRequired =\n          expirationDate ?? new Date(new Date().setHours(new Date().getHours() + 1));\n        const typeUrl = `https://schema.iden3.io/core/json/${option.type}.json`;\n        const typesFetchResult = await fetch(typeUrl);\n        const types = await typesFetchResult.json();\n        delete types.EIP712Domain;\n\n        const paymentData =\n          option.type === PaymentRequestDataType.Iden3PaymentRailsRequestV1\n            ? {\n                recipient,\n                amount: amount,\n                expirationDate: getUnixTimestamp(expirationDateRequired),\n                nonce,\n                metadata: '0x'\n              }\n            : {\n                tokenAddress: option.contractAddress,\n                recipient,\n                amount: amount,\n                expirationDate: getUnixTimestamp(expirationDateRequired),\n                nonce,\n                metadata: '0x'\n              };\n\n        const domain = {\n          name: 'MCPayment',\n          version: '1.0.0',\n          chainId,\n          verifyingContract: paymentRails\n        };\n        const signature = await signer.signTypedData(domain, types, paymentData);\n        const proof: EthereumEip712Signature2021[] = [\n          {\n            type: SupportedPaymentProofType.EthereumEip712Signature2021,\n            proofPurpose: 'assertionMethod',\n            proofValue: signature,\n            verificationMethod: `did:pkh:eip155:${chainId}:${await signer.getAddress()}`,\n            created: new Date().toISOString(),\n            eip712: {\n              types: typeUrl,\n              primaryType: 'Iden3PaymentRailsRequestV1',\n              domain\n            }\n          }\n        ];\n\n        const d: Iden3PaymentRailsRequestV1 = {\n          type: PaymentRequestDataType.Iden3PaymentRailsRequestV1,\n          '@context': [\n            `https://schema.iden3.io/core/jsonld/payment.jsonld#${option.type}`,\n            'https://w3id.org/security/suites/eip712sig-2021/v1'\n          ],\n          recipient,\n          amount: amount.toString(),\n          expirationDate: expirationDateRequired.toISOString(),\n          nonce: nonce.toString(),\n          metadata: '0x',\n          proof\n        };\n        dataArr.push(\n          option.type === PaymentRequestDataType.Iden3PaymentRailsRequestV1\n            ? d\n            : {\n                ...d,\n                type: option.type,\n                tokenAddress: option.contractAddress || '',\n                features: option.features || []\n              }\n        );\n      }\n      paymentRequestInfo.push({\n        data: dataArr,\n        credentials,\n        description\n      });\n    }\n    return createPaymentRequest(sender, receiver, agent, paymentRequestInfo);\n  }\n\n  private async packMessage(message: BasicMessage, senderDID: DID): Promise<Uint8Array> {\n    const responseEncoded = byteEncoder.encode(JSON.stringify(message));\n    const packerOpts =\n      this._params.packerParams.mediaType === MediaType.SignedMessage\n        ? this._params.packerParams.packerOptions\n        : {\n            provingMethodAlg: proving.provingMethodGroth16AuthV2Instance.methodAlg\n          };\n    return await this._packerMgr.pack(this._params.packerParams.mediaType, responseEncoded, {\n      senderDID,\n      ...packerOpts\n    });\n  }\n\n  private async handleIden3PaymentRequestCryptoV1(\n    data: Iden3PaymentRequestCryptoV1,\n    paymentHandler: (data: Iden3PaymentRequestCryptoV1) => Promise<string>\n  ): Promise<Iden3PaymentCryptoV1> {\n    if (data.expiration && new Date(data.expiration) < new Date()) {\n      throw new Error(`failed request. expired request`);\n    }\n    const txId = await paymentHandler(data);\n\n    return {\n      id: data.id,\n      '@context': 'https://schema.iden3.io/core/jsonld/payment.jsonld#Iden3PaymentCryptoV1',\n      type: PaymentType.Iden3PaymentCryptoV1,\n      paymentData: {\n        txId\n      }\n    };\n  }\n\n  private async handleIden3PaymentRailsRequestV1(\n    data: Iden3PaymentRailsRequestV1,\n    paymentHandler: (data: Iden3PaymentRailsRequestV1) => Promise<string>\n  ): Promise<Iden3PaymentRailsV1> {\n    if (data.expirationDate && new Date(data.expirationDate) < new Date()) {\n      throw new Error(`failed request. expired request`);\n    }\n    const signer = await verifyEIP712TypedData(data, this._params.documentResolver);\n    if (this._params.allowedSigners && !this._params.allowedSigners.includes(signer)) {\n      throw new Error(`failed request. signer is not in the allowed signers list`);\n    }\n    const txId = await paymentHandler(data);\n    const proof = Array.isArray(data.proof) ? data.proof[0] : data.proof;\n    return {\n      nonce: data.nonce,\n      type: PaymentType.Iden3PaymentRailsV1,\n      '@context': 'https://schema.iden3.io/core/jsonld/payment.jsonld#Iden3PaymentRailsV1',\n      paymentData: {\n        txId,\n        chainId: proof.eip712.domain.chainId\n      }\n    };\n  }\n\n  private async handleIden3PaymentRailsERC20RequestV1(\n    data: Iden3PaymentRailsERC20RequestV1,\n    paymentHandler: (data: Iden3PaymentRailsERC20RequestV1) => Promise<string>,\n    approveHandler?: (data: Iden3PaymentRailsERC20RequestV1) => Promise<string>\n  ): Promise<Iden3PaymentRailsERC20V1> {\n    if (data.expirationDate && new Date(data.expirationDate) < new Date()) {\n      throw new Error(`failed request. expired request`);\n    }\n\n    const signer = await verifyEIP712TypedData(data, this._params.documentResolver);\n    if (this._params.allowedSigners && !this._params.allowedSigners.includes(signer)) {\n      throw new Error(`failed request. signer is not in the allowed signers list`);\n    }\n    if (!data.features?.includes(PaymentFeatures.EIP_2612) && !approveHandler) {\n      throw new Error(`please provide erc20TokenApproveHandler in context for ERC-20 payment type`);\n    }\n\n    if (approveHandler) {\n      await approveHandler(data);\n    }\n\n    const txId = await paymentHandler(data);\n    const proof = Array.isArray(data.proof) ? data.proof[0] : data.proof;\n    return {\n      nonce: data.nonce,\n      type: PaymentType.Iden3PaymentRailsERC20V1,\n      '@context': 'https://schema.iden3.io/core/jsonld/payment.jsonld#Iden3PaymentRailsERC20V1',\n      paymentData: {\n        txId,\n        chainId: proof.eip712.domain.chainId,\n        tokenAddress: data.tokenAddress\n      }\n    };\n  }\n}\n","import { MediaType, PROTOCOL_MESSAGE_TYPE } from '../constants';\n\nimport { BasicMessage, IPackageManager, ProtocolMessage } from '../types';\n\nimport * as uuid from 'uuid';\nimport {\n  DiscoverFeatureDiscloseMessage,\n  DiscoverFeatureDisclosure,\n  DiscoverFeatureQueriesMessage,\n  DiscoverFeatureQuery,\n  DiscoverFeatureQueryType,\n  DiscoveryProtocolFeatureType\n} from '../types/protocol/discovery-protocol';\nimport {\n  AbstractMessageHandler,\n  BasicHandlerOptions,\n  IProtocolMessageHandler\n} from './message-handler';\nimport { getUnixTimestamp } from '@iden3/js-iden3-core';\nimport { verifyExpiresTime } from './common';\n\n/**\n * @beta\n * DiscoveryProtocolOptions contains options for DiscoveryProtocolHandler\n * @public\n * @interface   DiscoveryProtocolOptions\n */\nexport interface DiscoveryProtocolOptions {\n  packageManager: IPackageManager;\n  protocols?: Array<ProtocolMessage>;\n  goalCodes?: Array<string>;\n  headers?: Array<string>;\n}\n\n/**\n *\n * Options to pass to discovery-protocol handler\n *\n * @beta\n * @public\n * @type DiscoveryProtocolHandlerOptions\n */\nexport type DiscoveryProtocolHandlerOptions = BasicHandlerOptions & {\n  disclosureExpiresDate?: Date;\n};\n\n/**\n * @beta\n * createDiscoveryFeatureQueryMessage is a function to create didcomm protocol discovery-feature query message\n * @param opts - discovery-feature query options\n * @returns `DiscoverFeatureQueriesMessage`\n */\nexport function createDiscoveryFeatureQueryMessage(\n  queries: DiscoverFeatureQuery[],\n  opts?: {\n    from?: string;\n    to?: string;\n    expires_time?: number;\n  }\n): DiscoverFeatureQueriesMessage {\n  const uuidv4 = uuid.v4();\n  return {\n    id: uuidv4,\n    thid: uuidv4,\n    typ: MediaType.PlainMessage,\n    type: PROTOCOL_MESSAGE_TYPE.DISCOVERY_PROTOCOL_QUERIES_MESSAGE_TYPE,\n    body: {\n      queries\n    },\n    from: opts?.from,\n    to: opts?.to,\n    created_time: getUnixTimestamp(new Date()),\n    expires_time: opts?.expires_time\n  };\n}\n\n/**\n * @beta\n * createDiscoveryFeatureDiscloseMessage is a function to create didcomm protocol discovery-feature disclose message\n * @param {DiscoverFeatureDisclosure[]} disclosures - array of disclosures\n * @param opts - basic message options\n * @returns `DiscoverFeatureQueriesMessage`\n */\nexport function createDiscoveryFeatureDiscloseMessage(\n  disclosures: DiscoverFeatureDisclosure[],\n  opts?: {\n    from?: string;\n    to?: string;\n    expires_time?: number;\n  }\n): DiscoverFeatureDiscloseMessage {\n  const uuidv4 = uuid.v4();\n  return {\n    id: uuidv4,\n    typ: MediaType.PlainMessage,\n    thid: uuidv4,\n    type: PROTOCOL_MESSAGE_TYPE.DISCOVERY_PROTOCOL_DISCLOSE_MESSAGE_TYPE,\n    body: {\n      disclosures\n    },\n    from: opts?.from,\n    to: opts?.to,\n    created_time: getUnixTimestamp(new Date()),\n    expires_time: opts?.expires_time\n  };\n}\n\n/**\n * Interface to work with discovery protocol handler\n *\n * @beta\n * @public\n * @interface IDiscoveryProtocolHandler\n */\nexport interface IDiscoveryProtocolHandler {\n  /**\n   * handle discovery query message\n   *\n   * @param {DiscoverFeatureQueriesMessage} message - discover feature queries message\n   * @param {{ expires_time?: number}} opts - discover feature handle options\n   * @returns {Promise<DiscoverFeatureDiscloseMessage>} - discover feature disclose message\n   */\n  handleDiscoveryQuery(\n    message: DiscoverFeatureQueriesMessage,\n    opts?: DiscoveryProtocolHandlerOptions\n  ): Promise<DiscoverFeatureDiscloseMessage>;\n}\n\n/**\n *\n * Handler for discovery protocol\n *\n * @public\n * @beta\n * @class DiscoveryProtocolHandler\n * @implements implements DiscoveryProtocolHandler interface\n */\nexport class DiscoveryProtocolHandler\n  extends AbstractMessageHandler\n  implements IDiscoveryProtocolHandler, IProtocolMessageHandler\n{\n  /**\n   * Creates an instance of DiscoveryProtocolHandler.\n   * @param {DiscoveryProtocolOptions} _options - discovery protocol options\n   */\n  constructor(private readonly _options: DiscoveryProtocolOptions) {\n    super();\n    const headers = [\n      'id',\n      'typ',\n      'type',\n      'thid',\n      'body',\n      'from',\n      'to',\n      'created_time',\n      'expires_time'\n    ];\n    if (!_options.headers) {\n      _options.headers = headers;\n    }\n  }\n\n  /**\n   * @inheritdoc IProtocolMessageHandler#handle\n   */\n  public async handle(\n    message: BasicMessage,\n    context: { [key: string]: unknown }\n  ): Promise<BasicMessage | null> {\n    switch (message.type) {\n      case PROTOCOL_MESSAGE_TYPE.DISCOVERY_PROTOCOL_QUERIES_MESSAGE_TYPE:\n        return await this.handleDiscoveryQuery(message as DiscoverFeatureQueriesMessage, context);\n      default:\n        return super.handle(message, context as { [key: string]: unknown });\n    }\n  }\n\n  /**\n   * @inheritdoc IDiscoveryProtocolHandler#handleDiscoveryQuery\n   */\n  async handleDiscoveryQuery(\n    message: DiscoverFeatureQueriesMessage,\n    opts?: DiscoveryProtocolHandlerOptions\n  ): Promise<DiscoverFeatureDiscloseMessage> {\n    if (!opts?.allowExpiredMessages) {\n      verifyExpiresTime(message);\n    }\n\n    const disclosures: DiscoverFeatureDisclosure[] = [];\n    for (const query of message.body.queries) {\n      disclosures.push(...this.handleQuery(query));\n    }\n\n    return Promise.resolve(\n      createDiscoveryFeatureDiscloseMessage(disclosures, {\n        to: message.from,\n        from: message.to,\n        expires_time: opts?.disclosureExpiresDate\n          ? getUnixTimestamp(opts.disclosureExpiresDate)\n          : undefined\n      })\n    );\n  }\n\n  private handleQuery(query: DiscoverFeatureQuery): DiscoverFeatureDisclosure[] {\n    let result: DiscoverFeatureDisclosure[] = [];\n    switch (query[DiscoverFeatureQueryType.FeatureType]) {\n      case DiscoveryProtocolFeatureType.Accept:\n        result = this.handleAcceptQuery();\n        break;\n      case DiscoveryProtocolFeatureType.Protocol:\n        result = this.handleProtocolQuery();\n        break;\n      case DiscoveryProtocolFeatureType.GoalCode:\n        result = this.handleGoalCodeQuery();\n        break;\n      case DiscoveryProtocolFeatureType.Header:\n        result = this.handleHeaderQuery();\n        break;\n    }\n\n    return this.handleMatch(result, query.match);\n  }\n\n  private handleAcceptQuery(): DiscoverFeatureDisclosure[] {\n    const acceptProfiles = this._options.packageManager.getSupportedProfiles();\n    return acceptProfiles.map((profile) => ({\n      [DiscoverFeatureQueryType.FeatureType]: DiscoveryProtocolFeatureType.Accept,\n      id: profile\n    }));\n  }\n\n  private handleProtocolQuery(): DiscoverFeatureDisclosure[] {\n    return (\n      this._options.protocols?.map((protocol) => ({\n        [DiscoverFeatureQueryType.FeatureType]: DiscoveryProtocolFeatureType.Protocol,\n        id: protocol\n      })) ?? []\n    );\n  }\n\n  private handleGoalCodeQuery(): DiscoverFeatureDisclosure[] {\n    return (\n      this._options.goalCodes?.map((goalCode) => ({\n        [DiscoverFeatureQueryType.FeatureType]: DiscoveryProtocolFeatureType.GoalCode,\n        id: goalCode\n      })) ?? []\n    );\n  }\n\n  private handleHeaderQuery(): DiscoverFeatureDisclosure[] {\n    return (\n      this._options.headers?.map((header) => ({\n        [DiscoverFeatureQueryType.FeatureType]: DiscoveryProtocolFeatureType.Header,\n        id: header\n      })) ?? []\n    );\n  }\n\n  private handleMatch(\n    disclosures: DiscoverFeatureDisclosure[],\n    match?: string\n  ): DiscoverFeatureDisclosure[] {\n    if (!match || match === '*') {\n      return disclosures;\n    }\n    const regExp = this.wildcardToRegExp(match);\n    return disclosures.filter((disclosure) => regExp.test(disclosure.id));\n  }\n\n  private wildcardToRegExp(match: string): RegExp {\n    // Escape special regex characters, then replace `*` with `.*`\n    const regexPattern = match.replace(/[.+^${}()|[\\]\\\\]/g, '\\\\$&').replace(/\\*/g, '.*');\n    return new RegExp(`^${regexPattern}$`);\n  }\n}\n","import * as uuid from 'uuid';\nimport { ProblemReportMessage } from '../types/protocol/problem-report';\nimport { MediaType, PROTOCOL_MESSAGE_TYPE } from '../constants';\n\n/**\n * @beta\n * createProblemReportMessage is a function to create didcomm protocol problem report message\n * @param pthid - parent thread id\n * @param code - problem report code\n * @param opts - problem report options\n * @returns `ProblemReportMessage`\n */\nexport function createProblemReportMessage(\n  pthid: string,\n  code: string,\n  opts?: {\n    comment?: string;\n    ack?: string[];\n    args?: string[];\n    escalate_to?: string;\n    from?: string;\n    to?: string;\n  }\n): ProblemReportMessage {\n  const uuidv4 = uuid.v4();\n  return {\n    id: uuidv4,\n    pthid: pthid,\n    typ: MediaType.PlainMessage,\n    type: PROTOCOL_MESSAGE_TYPE.PROBLEM_REPORT_MESSAGE_TYPE,\n    ack: opts?.ack,\n    body: {\n      code: code,\n      comment: opts?.comment,\n      args: opts?.args,\n      escalate_to: opts?.escalate_to\n    },\n    from: opts?.from,\n    to: opts?.to\n  };\n}\n","import { JsonRpcProvider, Signer, Contract, TransactionRequest, ethers } from 'ethers';\nimport { EthConnectionConfig } from './state';\nimport { IOnChainZKPVerifier } from '../interfaces/onchain-zkp-verifier';\nimport {\n  AuthMethod,\n  AuthProof,\n  AuthProofEthIdentity,\n  AuthProofZKP,\n  ContractInvokeTransactionData,\n  CrossChainProof,\n  JsonDocumentObjectValue,\n  processProofResponse,\n  ZeroKnowledgeInvokeResponse,\n  ZeroKnowledgeProofResponse\n} from '../../iden3comm';\nimport abi from './abi/ZkpVerifier.json';\nimport { IVerifierABI } from '@iden3/universal-verifier-v2-abi';\nimport { TransactionService } from '../../blockchain';\nimport { BytesHelper, chainIDfromDID, DID, Id } from '@iden3/js-iden3-core';\nimport {\n  AtomicQueryMTPV2OnChainPubSignals,\n  AtomicQuerySigV2OnChainPubSignals,\n  AtomicQueryV3OnChainPubSignals,\n  AuthV2PubSignals,\n  CircuitId,\n  StatesInfo\n} from '../../circuits';\nimport { byteEncoder, bytesToHex, DIDDocumentSignature, resolveDidDocument } from '../../utils';\nimport { GlobalStateUpdate, IdentityStateUpdate } from '../entities/state';\nimport { Hash } from '@iden3/js-merkletree';\nimport { packZkpProof, prepareZkpProof } from './common';\n\nconst maxGasLimit = 10000000n;\n\n/**\n * Supported function signature for SubmitZKPResponse\n */\nexport enum FunctionSignatures {\n  /**\n   * solidity identifier for function signature:\n   * function submitZKPResponse(uint64 requestId, uint256[] calldata inputs,\n   * uint256[2] calldata a, uint256[2][2] calldata b, uint256[2] calldata c) public\n   */\n  SubmitZKPResponseV1 = 'b68967e2',\n  //function submitZKPResponseV2(tuple[](uint64 requestId,bytes zkProof,bytes data),bytes crossChainProof)\n  SubmitZKPResponseV2 = 'ade09fcd',\n  //function submitResponse(tuple(string authMethod,bytes proof),tuple(uint256 requestId,bytes proof,bytes metadata)[],bytes crossChainProof)\n  SubmitResponse = '06c86a91'\n}\n/**\n * OnChainZKPVerifierOptions represents OnChainZKPVerifier options\n */\nexport type OnChainZKPVerifierOptions = {\n  didResolverUrl?: string;\n};\ntype ProofPreparationResult = {\n  requestId: string | number;\n  proof: ZeroKnowledgeProofResponse;\n  encoded: string;\n  metadata: string;\n};\nexport type TxPreparationResultSubmitResponse = {\n  authProof: { raw: AuthProof; encoded: string };\n  crossChainProof: { raw: CrossChainProof; encoded: string };\n  proofs: ProofPreparationResult[];\n};\n\nexport const toTxDataArgs = function (res: TxPreparationResultSubmitResponse) {\n  return [\n    {\n      authMethod: res.authProof.raw.authMethod,\n      proof: res.authProof.encoded\n    },\n    res.proofs.map((p) => {\n      return {\n        requestId: p.requestId,\n        proof: p.encoded,\n        metadata: p.metadata\n      };\n    }),\n    res.crossChainProof.encoded\n  ];\n};\n\ntype OnChainZKPVerifierCircuitId =\n  | CircuitId.AuthV2\n  | CircuitId.AtomicQueryMTPV2OnChain\n  | CircuitId.AtomicQuerySigV2OnChain\n  | CircuitId.AtomicQueryV3OnChain;\n\n/**\n * OnChainZKPVerifier is a class that allows to interact with the OnChainZKPVerifier contract\n * and submitZKPResponse.\n *\n * @beta\n * @class OnChainZKPVerifier\n */\nexport class OnChainZKPVerifier implements IOnChainZKPVerifier {\n  /**\n   * supported circuits\n   */\n  private static readonly _supportedCircuits: OnChainZKPVerifierCircuitId[] = [\n    CircuitId.AuthV2,\n    CircuitId.AtomicQueryMTPV2OnChain,\n    CircuitId.AtomicQuerySigV2OnChain,\n    CircuitId.AtomicQueryV3OnChain\n  ];\n\n  private static readonly _supportedCircuitsPubSignalsMap = {\n    [CircuitId.AtomicQueryMTPV2OnChain]: AtomicQueryMTPV2OnChainPubSignals,\n    [CircuitId.AtomicQuerySigV2OnChain]: AtomicQuerySigV2OnChainPubSignals,\n    [CircuitId.AtomicQueryV3OnChain]: AtomicQueryV3OnChainPubSignals,\n    [CircuitId.AuthV2]: AuthV2PubSignals\n  };\n\n  /**\n   *\n   * Creates an instance of OnChainZKPVerifier.\n   * @beta\n   * @param {EthConnectionConfig[]} - array of ETH configs\n   */\n\n  constructor(\n    private readonly _configs: EthConnectionConfig[],\n    private readonly _opts?: OnChainZKPVerifierOptions\n  ) {}\n\n  public static async prepareTxArgsSubmitV1(\n    txData: ContractInvokeTransactionData,\n    zkProofResponse: ZeroKnowledgeProofResponse\n  ): Promise<JsonDocumentObjectValue[]> {\n    if (txData.method_id.replace('0x', '') !== FunctionSignatures.SubmitZKPResponseV1) {\n      throw new Error(\n        `prepareTxArgsSubmitV1 function doesn't implement requested method id. Only '0x${FunctionSignatures.SubmitZKPResponseV1}' is supported.`\n      );\n    }\n    const requestID = zkProofResponse.id;\n    const inputs = zkProofResponse.pub_signals;\n\n    const preparedZkpProof = prepareZkpProof(zkProofResponse.proof);\n    const payload = [requestID, inputs, preparedZkpProof.a, preparedZkpProof.b, preparedZkpProof.c];\n\n    return payload;\n  }\n  /**\n   * {@inheritDoc IOnChainZKPVerifier.prepareTxArgsSubmitV1}\n   */\n  public async prepareTxArgsSubmitV1(\n    txData: ContractInvokeTransactionData,\n    zkProofResponse: ZeroKnowledgeProofResponse\n  ): Promise<JsonDocumentObjectValue[]> {\n    return OnChainZKPVerifier.prepareTxArgsSubmitV1(txData, zkProofResponse);\n  }\n\n  /**\n   * {@inheritDoc IOnChainZKPVerifier.submitZKPResponse}\n   */\n  public async submitZKPResponse(\n    ethSigner: Signer,\n    txData: ContractInvokeTransactionData,\n    zkProofResponses: ZeroKnowledgeProofResponse[]\n  ): Promise<Map<string, ZeroKnowledgeProofResponse>> {\n    const chainConfig = this._configs.find((i) => i.chainId == txData.chain_id);\n    if (!chainConfig) {\n      throw new Error(`config for chain id ${txData.chain_id} was not found`);\n    }\n    if (txData.method_id.replace('0x', '') !== FunctionSignatures.SubmitZKPResponseV1) {\n      throw new Error(\n        `submitZKPResponse function doesn't implement requested method id. Only '0x${FunctionSignatures.SubmitZKPResponseV1}' is supported.`\n      );\n    }\n    const provider = new JsonRpcProvider(chainConfig.url, chainConfig.chainId);\n    ethSigner = ethSigner.connect(provider);\n    const response = new Map<string, ZeroKnowledgeProofResponse>();\n\n    const feeData = await provider.getFeeData();\n    const maxFeePerGas = chainConfig.maxFeePerGas\n      ? BigInt(chainConfig.maxFeePerGas)\n      : feeData.maxFeePerGas;\n    const maxPriorityFeePerGas = chainConfig.maxPriorityFeePerGas\n      ? BigInt(chainConfig.maxPriorityFeePerGas)\n      : feeData.maxPriorityFeePerGas;\n\n    const verifierContract = new Contract(txData.contract_address, abi);\n\n    for (const zkProofResponse of zkProofResponses) {\n      const txArgs = await this.prepareTxArgsSubmitV1(txData, zkProofResponse);\n      const payload = await verifierContract.submitZKPResponse.populateTransaction(...txArgs);\n      const request: TransactionRequest = {\n        to: txData.contract_address,\n        data: payload.data,\n        maxFeePerGas,\n        maxPriorityFeePerGas\n      };\n\n      let gasLimit;\n      try {\n        gasLimit = await ethSigner.estimateGas(request);\n      } catch (e) {\n        gasLimit = maxGasLimit;\n      }\n      request.gasLimit = gasLimit;\n\n      const transactionService = new TransactionService(provider);\n      const { txnHash } = await transactionService.sendTransactionRequest(ethSigner, request);\n      response.set(txnHash, zkProofResponse);\n    }\n\n    return response;\n  }\n\n  /**\n   * {@inheritDoc IOnChainZKPVerifier.submitZKPResponseV2}\n   */\n  public async submitZKPResponseV2(\n    ethSigner: Signer,\n    txData: ContractInvokeTransactionData,\n    zkProofResponses: ZeroKnowledgeProofResponse[]\n  ): Promise<Map<string, ZeroKnowledgeProofResponse[]>> {\n    const chainConfig = this._configs.find((i) => i.chainId == txData.chain_id);\n    if (!chainConfig) {\n      throw new Error(`config for chain id ${txData.chain_id} was not found`);\n    }\n    if (txData.method_id.replace('0x', '') !== FunctionSignatures.SubmitZKPResponseV2) {\n      throw new Error(\n        `submitZKPResponseV2 function doesn't implement requested method id. Only '0x${FunctionSignatures.SubmitZKPResponseV2}' is supported.`\n      );\n    }\n    if (!this._opts?.didResolverUrl) {\n      throw new Error(`did resolver url required for crosschain verification`);\n    }\n    const provider = new JsonRpcProvider(chainConfig.url, chainConfig.chainId);\n    ethSigner = ethSigner.connect(provider);\n\n    const txDataArgs = await this.prepareTxArgsSubmitV2(txData, zkProofResponses);\n    const feeData = await provider.getFeeData();\n    const maxFeePerGas = chainConfig.maxFeePerGas\n      ? BigInt(chainConfig.maxFeePerGas)\n      : feeData.maxFeePerGas;\n    const maxPriorityFeePerGas = chainConfig.maxPriorityFeePerGas\n      ? BigInt(chainConfig.maxPriorityFeePerGas)\n      : feeData.maxPriorityFeePerGas;\n\n    const verifierContract = new Contract(txData.contract_address, abi);\n    const txRequestData = await verifierContract.submitZKPResponseV2.populateTransaction(\n      ...txDataArgs\n    );\n\n    const request: TransactionRequest = {\n      to: txData.contract_address,\n      data: txRequestData.data,\n      maxFeePerGas,\n      maxPriorityFeePerGas\n    };\n\n    let gasLimit;\n    try {\n      gasLimit = await ethSigner.estimateGas(request);\n    } catch (e) {\n      gasLimit = maxGasLimit;\n    }\n    request.gasLimit = gasLimit;\n\n    const transactionService = new TransactionService(provider);\n    const { txnHash } = await transactionService.sendTransactionRequest(ethSigner, request);\n\n    return new Map<string, ZeroKnowledgeProofResponse[]>().set(txnHash, zkProofResponses);\n  }\n\n  /**\n   * {@inheritDoc IOnChainVerifierMultiQuery.submitResponse}\n   */\n  public async submitResponse(\n    ethSigner: Signer,\n    txData: ContractInvokeTransactionData,\n    responses: ZeroKnowledgeProofResponse[],\n    authProof: AuthProof\n  ): Promise<Map<string, ZeroKnowledgeInvokeResponse>> {\n    const chainConfig = this._configs.find((i) => i.chainId == txData.chain_id);\n    if (!chainConfig) {\n      throw new Error(`config for chain id ${txData.chain_id} was not found`);\n    }\n    if (txData.method_id.replace('0x', '') !== FunctionSignatures.SubmitResponse) {\n      throw new Error(\n        `submitResponse function doesn't implement requested method id. Only '0x${FunctionSignatures.SubmitResponse}' is supported.`\n      );\n    }\n    if (!this._opts?.didResolverUrl) {\n      throw new Error(`did resolver url required for crosschain verification`);\n    }\n    const provider = new JsonRpcProvider(chainConfig.url, chainConfig.chainId);\n    ethSigner = ethSigner.connect(provider);\n\n    const txPreparationResult = await this.prepareTxArgsSubmit(txData, responses, authProof);\n\n    const feeData = await provider.getFeeData();\n    const maxFeePerGas = chainConfig.maxFeePerGas\n      ? BigInt(chainConfig.maxFeePerGas)\n      : feeData.maxFeePerGas;\n    const maxPriorityFeePerGas = chainConfig.maxPriorityFeePerGas\n      ? BigInt(chainConfig.maxPriorityFeePerGas)\n      : feeData.maxPriorityFeePerGas;\n\n    const verifierContract = new Contract(txData.contract_address, IVerifierABI);\n    const txRequestData = await verifierContract.submitResponse.populateTransaction(\n      ...txPreparationResult.txDataArgs\n    );\n\n    const request: TransactionRequest = {\n      to: txData.contract_address,\n      data: txRequestData.data,\n      maxFeePerGas,\n      maxPriorityFeePerGas\n    };\n\n    let gasLimit;\n    try {\n      gasLimit = await ethSigner.estimateGas(request);\n    } catch (e) {\n      gasLimit = maxGasLimit;\n    }\n    request.gasLimit = gasLimit;\n\n    const transactionService = new TransactionService(provider);\n    const { txnHash } = await transactionService.sendTransactionRequest(ethSigner, request);\n\n    // return multiple responses for all the responses (single and grouped)\n    return new Map<string, ZeroKnowledgeInvokeResponse>().set(txnHash, {\n      authProof: txPreparationResult.result.authProof.raw,\n      crossChainProof: txPreparationResult.result.crossChainProof.raw,\n      responses: txPreparationResult.result.proofs.map((m) => m.proof)\n    });\n  }\n\n  public static async prepareTxArgsSubmit(\n    resolverUrl: string,\n    txData: ContractInvokeTransactionData,\n    responses: ZeroKnowledgeProofResponse[],\n    authProof: AuthProof\n  ): Promise<{ result: TxPreparationResultSubmitResponse; txDataArgs: JsonDocumentObjectValue[] }> {\n    if (txData.method_id.replace('0x', '') !== FunctionSignatures.SubmitResponse) {\n      throw new Error(\n        `submit cross chain doesn't implement requested method id. Only '0x${FunctionSignatures.SubmitResponse}' is supported.`\n      );\n    }\n    const gistUpdatesArr: GlobalStateUpdate[] = [];\n    const stateUpdatesArr: IdentityStateUpdate[] = [];\n    const payloadResponses = [];\n    const emptyBytes = '0x';\n\n    let encodedAuthProof = '';\n\n    switch (authProof.authMethod) {\n      case AuthMethod.AUTHV2: {\n        const preparedZkpProof = prepareZkpProof((authProof as AuthProofZKP).zkp.proof);\n        encodedAuthProof = packZkpProof(\n          (authProof as AuthProofZKP).zkp.pub_signals,\n          preparedZkpProof.a,\n          preparedZkpProof.b,\n          preparedZkpProof.c\n        );\n        break;\n      }\n      case AuthMethod.ETH_IDENTITY: {\n        encodedAuthProof = packEthIdentityProof((authProof as AuthProofEthIdentity).userDid);\n        break;\n      }\n      default:\n        throw new Error('auth proof must use method AuthV2 or ethIdentity');\n    }\n\n    // Process all the responses\n    for (const zkProof of responses) {\n      this.checkSupportedCircuit(zkProof.circuitId as CircuitId);\n      const { requestId, zkProofEncoded, metadata } = processProofResponse(zkProof);\n\n      payloadResponses.push({\n        proof: zkProof,\n        requestId: requestId,\n        encoded: zkProofEncoded,\n        metadata: metadata\n      });\n    }\n\n    // Process all zkProofs and prepare cross chain proofs\n    const allZkProofs = responses.map((zkProof) => ({\n      circuitId: zkProof.circuitId as OnChainZKPVerifierCircuitId,\n      pub_signals: zkProof.pub_signals\n    }));\n\n    if (authProof.authMethod == AuthMethod.AUTHV2) {\n      allZkProofs.push({\n        circuitId: (authProof as AuthProofZKP).zkp.circuitId as OnChainZKPVerifierCircuitId,\n        pub_signals: (authProof as AuthProofZKP).zkp.pub_signals\n      });\n    }\n\n    for (const zkProof of allZkProofs) {\n      const { gistUpdateResolutions, stateUpdateResolutions } = this.getUpdateResolutions(\n        resolverUrl,\n        txData.chain_id,\n        zkProof.circuitId,\n        zkProof.pub_signals\n      );\n\n      if (gistUpdateResolutions.length > 0) {\n        gistUpdatesArr.push(...((await Promise.all(gistUpdateResolutions)) as GlobalStateUpdate[]));\n      }\n      if (stateUpdateResolutions.length > 0) {\n        stateUpdatesArr.push(\n          ...((await Promise.all(stateUpdateResolutions)) as IdentityStateUpdate[])\n        );\n      }\n    }\n\n    const encodedCrossChainProof =\n      gistUpdatesArr.length || stateUpdatesArr.length\n        ? this.packCrossChainProofs(gistUpdatesArr, stateUpdatesArr)\n        : emptyBytes;\n\n    const preparationResult = {\n      authProof: { raw: authProof, encoded: encodedAuthProof },\n      proofs: payloadResponses,\n      crossChainProof: {\n        raw: {\n          globalStateProofs: gistUpdatesArr || [],\n          identityStateProofs: stateUpdatesArr || []\n        },\n        encoded: encodedCrossChainProof\n      }\n    };\n    return { result: preparationResult, txDataArgs: toTxDataArgs(preparationResult) };\n  }\n\n  public async prepareTxArgsSubmit(\n    txData: ContractInvokeTransactionData,\n    responses: ZeroKnowledgeProofResponse[],\n    authProof: AuthProof\n  ): Promise<{ result: TxPreparationResultSubmitResponse; txDataArgs: JsonDocumentObjectValue[] }> {\n    if (!this._opts?.didResolverUrl) {\n      throw new Error(`did resolver url required for crosschain verification`);\n    }\n    return OnChainZKPVerifier.prepareTxArgsSubmit(\n      this._opts.didResolverUrl,\n      txData,\n      responses,\n      authProof\n    );\n  }\n\n  private static checkSupportedCircuit(circuitId: CircuitId) {\n    if (!this._supportedCircuits.includes(circuitId as OnChainZKPVerifierCircuitId)) {\n      throw new Error(`Circuit ${circuitId} not supported by OnChainZKPVerifier`);\n    }\n  }\n\n  private static getCrossChainResolvers(\n    source: {\n      id: Id;\n      root?: Hash;\n      state?: Hash;\n    }[],\n    txDataChainId: number,\n    type: 'gist' | 'state',\n    didResolverUrl: string\n  ) {\n    return [\n      ...new Set(\n        source.map((info) =>\n          JSON.stringify({\n            id: info.id.string(),\n            [type]: type === 'gist' ? info.root?.string() : info.state?.string()\n          })\n        )\n      )\n    ].reduce((acc: Promise<unknown>[], s: string) => {\n      const info = JSON.parse(s);\n      const id = Id.fromString(info.id);\n      const chainId = chainIDfromDID(DID.parseFromId(id));\n\n      if (txDataChainId === chainId) {\n        return acc;\n      }\n      const promise = this.resolveDidDocumentEip712MessageAndSignature(\n        DID.parseFromId(Id.fromString(info.id)),\n        didResolverUrl,\n        {\n          [type]: Hash.fromString(info[type])\n        }\n      );\n      return [...acc, promise];\n    }, []);\n  }\n\n  public static async prepareTxArgsSubmitV2(\n    resolverUrl: string,\n    txData: ContractInvokeTransactionData,\n    zkProofResponses: ZeroKnowledgeProofResponse[]\n  ): Promise<JsonDocumentObjectValue[]> {\n    if (txData.method_id.replace('0x', '') !== FunctionSignatures.SubmitZKPResponseV2) {\n      throw new Error(\n        `submit cross chain doesn't implement requested method id. Only '0x${FunctionSignatures.SubmitZKPResponseV2}' is supported.`\n      );\n    }\n\n    const gistUpdatesArr = [];\n    const stateUpdatesArr = [];\n    const payloadResponses = [];\n    const emptyBytes = '0x';\n\n    for (const zkProof of zkProofResponses) {\n      this.checkSupportedCircuit(zkProof.circuitId as CircuitId);\n      const { requestId, zkProofEncoded, metadata } = processProofResponse(zkProof);\n\n      payloadResponses.push({\n        requestId: requestId,\n        zkProof: zkProofEncoded,\n        data: metadata\n      });\n\n      const { gistUpdateResolutions, stateUpdateResolutions } = this.getUpdateResolutions(\n        resolverUrl,\n        txData.chain_id,\n        zkProof.circuitId as OnChainZKPVerifierCircuitId,\n        zkProof.pub_signals\n      );\n\n      if (gistUpdateResolutions.length > 0) {\n        gistUpdatesArr.push(...((await Promise.all(gistUpdateResolutions)) as GlobalStateUpdate[]));\n      }\n      if (stateUpdateResolutions.length > 0) {\n        stateUpdatesArr.push(\n          ...((await Promise.all(stateUpdateResolutions)) as IdentityStateUpdate[])\n        );\n      }\n    }\n\n    const crossChainProofEncoded =\n      gistUpdatesArr.length || stateUpdatesArr.length\n        ? this.packCrossChainProofs(gistUpdatesArr, stateUpdatesArr)\n        : emptyBytes;\n    return [payloadResponses, crossChainProofEncoded];\n  }\n\n  public async prepareTxArgsSubmitV2(\n    txData: ContractInvokeTransactionData,\n    zkProofResponses: ZeroKnowledgeProofResponse[]\n  ): Promise<JsonDocumentObjectValue[]> {\n    if (!this._opts?.didResolverUrl) {\n      throw new Error(`did resolver url required for crosschain verification`);\n    }\n    return OnChainZKPVerifier.prepareTxArgsSubmitV2(\n      this._opts.didResolverUrl,\n      txData,\n      zkProofResponses\n    );\n  }\n\n  private static getUpdateResolutions(\n    resolverUrl: string,\n    chainId: number,\n    proofCircuitId: OnChainZKPVerifierCircuitId,\n    inputs: string[]\n  ) {\n    const stateInfo = this.getOnChainGistRootStatePubSignals(proofCircuitId, inputs);\n\n    const gistUpdateResolutions = this.getCrossChainResolvers(\n      stateInfo.gists,\n      chainId,\n      'gist',\n      resolverUrl\n    );\n\n    const stateUpdateResolutions = this.getCrossChainResolvers(\n      stateInfo.states,\n      chainId,\n      'state',\n      resolverUrl\n    );\n\n    return { gistUpdateResolutions, stateUpdateResolutions };\n  }\n\n  private static packCrossChainProofs(\n    gistUpdateArr: GlobalStateUpdate[],\n    stateUpdateArr: IdentityStateUpdate[]\n  ) {\n    const proofs = [];\n    for (const globalStateUpdate of gistUpdateArr) {\n      proofs.push({\n        proofType: 'globalStateProof',\n        proof: this.packGlobalStateMsg(globalStateUpdate)\n      });\n    }\n    for (const stateUpdate of stateUpdateArr) {\n      proofs.push({\n        proofType: 'stateProof',\n        proof: this.packIdentityStateMsg(stateUpdate)\n      });\n    }\n    return new ethers.AbiCoder().encode(\n      ['tuple(' + 'string proofType,' + 'bytes proof' + ')[]'],\n      [proofs]\n    );\n  }\n\n  public static packGlobalStateMsg(msg: GlobalStateUpdate): string {\n    return new ethers.AbiCoder().encode(\n      [\n        'tuple(' +\n          'tuple(' +\n          'uint256 timestamp,' +\n          'bytes2 idType,' +\n          'uint256 root,' +\n          'uint256 replacedAtTimestamp' +\n          ') globalStateMsg,' +\n          'bytes signature,' +\n          ')'\n      ],\n      [msg]\n    );\n  }\n\n  private static packIdentityStateMsg(msg: IdentityStateUpdate): string {\n    return new ethers.AbiCoder().encode(\n      [\n        'tuple(' +\n          'tuple(' +\n          'uint256 timestamp,' +\n          'uint256 id,' +\n          'uint256 state,' +\n          'uint256 replacedAtTimestamp' +\n          ') idStateMsg,' +\n          'bytes signature,' +\n          ')'\n      ],\n      [msg]\n    );\n  }\n\n  private static getOnChainGistRootStatePubSignals(\n    onChainCircuitId: OnChainZKPVerifierCircuitId,\n    inputs: string[]\n  ): StatesInfo {\n    const PubSignals = this._supportedCircuitsPubSignalsMap[onChainCircuitId];\n    if (!PubSignals) {\n      throw new Error(`Circuit ${onChainCircuitId} not supported by OnChainZKPVerifier`);\n    }\n    const atomicQueryPubSignals = new PubSignals();\n    const encodedInputs = byteEncoder.encode(JSON.stringify(inputs));\n    atomicQueryPubSignals.pubSignalsUnmarshal(encodedInputs);\n    return atomicQueryPubSignals.getStatesInfo();\n  }\n\n  private static async resolveDidDocumentEip712MessageAndSignature(\n    did: DID,\n    resolverUrl: string,\n    opts?: {\n      state?: Hash;\n      gist?: Hash;\n    }\n  ) {\n    const didDoc = await resolveDidDocument(did, resolverUrl, {\n      ...opts,\n      signature: DIDDocumentSignature.EthereumEip712Signature2021\n    });\n    if (!didDoc.didResolutionMetadata.proof?.length) {\n      throw new Error('No proof found in resolved DID document');\n    }\n    const message = didDoc.didResolutionMetadata.proof[0].eip712.message;\n    const signature = didDoc.didResolutionMetadata.proof[0].proofValue;\n    const isGistRequest = opts?.gist && !opts.state;\n    if (isGistRequest) {\n      return {\n        globalStateMsg: {\n          timestamp: message.timestamp,\n          idType: message.idType,\n          root: message.root,\n          replacedAtTimestamp: message.replacedAtTimestamp\n        },\n        signature\n      };\n    }\n\n    return {\n      idStateMsg: {\n        timestamp: message.timestamp,\n        id: message.id,\n        state: message.state,\n        replacedAtTimestamp: message.replacedAtTimestamp\n      },\n      signature\n    };\n  }\n}\n\n/**\n * Packs an Ethereum identity proof from a Decentralized Identifier (DID).\n * @param did - Decentralized Identifier (DID) to pack.\n * @returns A hexadecimal string representing the packed DID identity proof.\n */\nexport const packEthIdentityProof = (did: DID): string => {\n  return `0x${bytesToHex(BytesHelper.intToBytes(DID.idFromDID(did).bigInt()))}`;\n};\n","[\n  {\n    \"inputs\": [],\n    \"name\": \"InvalidInitialization\",\n    \"type\": \"error\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"message\",\n        \"type\": \"string\"\n      },\n      {\n        \"internalType\": \"uint64\",\n        \"name\": \"requestId\",\n        \"type\": \"uint64\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"linkID\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint64\",\n        \"name\": \"requestIdToCompare\",\n        \"type\": \"uint64\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"linkIdToCompare\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"LinkedProofError\",\n    \"type\": \"error\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"NotInitializing\",\n    \"type\": \"error\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"OwnableInvalidOwner\",\n    \"type\": \"error\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"OwnableUnauthorizedAccount\",\n    \"type\": \"error\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint64\",\n        \"name\": \"version\",\n        \"type\": \"uint64\"\n      }\n    ],\n    \"name\": \"Initialized\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"previousOwner\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"newOwner\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"OwnershipTransferStarted\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"previousOwner\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"newOwner\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"OwnershipTransferred\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"uint64\",\n        \"name\": \"requestId\",\n        \"type\": \"uint64\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"requestOwner\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"string\",\n        \"name\": \"metadata\",\n        \"type\": \"string\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"address\",\n        \"name\": \"validator\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"bytes\",\n        \"name\": \"data\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"ZKPRequestSet\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"uint64\",\n        \"name\": \"requestId\",\n        \"type\": \"uint64\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"caller\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"ZKPResponseSubmitted\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"REQUESTS_RETURN_LIMIT\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"VERSION\",\n    \"outputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"acceptOwnership\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract ICircuitValidator\",\n        \"name\": \"validator\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"addValidatorToWhitelist\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint64\",\n        \"name\": \"requestId\",\n        \"type\": \"uint64\"\n      }\n    ],\n    \"name\": \"disableZKPRequest\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint64\",\n        \"name\": \"requestId\",\n        \"type\": \"uint64\"\n      }\n    ],\n    \"name\": \"enableZKPRequest\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"sender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint64\",\n        \"name\": \"requestId\",\n        \"type\": \"uint64\"\n      }\n    ],\n    \"name\": \"getProofStatus\",\n    \"outputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"bool\",\n            \"name\": \"isVerified\",\n            \"type\": \"bool\"\n          },\n          {\n            \"internalType\": \"string\",\n            \"name\": \"validatorVersion\",\n            \"type\": \"string\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"blockNumber\",\n            \"type\": \"uint256\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"blockTimestamp\",\n            \"type\": \"uint256\"\n          }\n        ],\n        \"internalType\": \"struct IZKPVerifier.ProofStatus\",\n        \"name\": \"\",\n        \"type\": \"tuple\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"user\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint64\",\n        \"name\": \"requestId\",\n        \"type\": \"uint64\"\n      },\n      {\n        \"internalType\": \"string\",\n        \"name\": \"key\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"getProofStorageField\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint64\",\n        \"name\": \"requestId\",\n        \"type\": \"uint64\"\n      }\n    ],\n    \"name\": \"getRequestOwner\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint64\",\n        \"name\": \"requestId\",\n        \"type\": \"uint64\"\n      }\n    ],\n    \"name\": \"getZKPRequest\",\n    \"outputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"string\",\n            \"name\": \"metadata\",\n            \"type\": \"string\"\n          },\n          {\n            \"internalType\": \"contract ICircuitValidator\",\n            \"name\": \"validator\",\n            \"type\": \"address\"\n          },\n          {\n            \"internalType\": \"bytes\",\n            \"name\": \"data\",\n            \"type\": \"bytes\"\n          }\n        ],\n        \"internalType\": \"struct IZKPVerifier.ZKPRequest\",\n        \"name\": \"zkpRequest\",\n        \"type\": \"tuple\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"startIndex\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"length\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"getZKPRequests\",\n    \"outputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"string\",\n            \"name\": \"metadata\",\n            \"type\": \"string\"\n          },\n          {\n            \"internalType\": \"contract ICircuitValidator\",\n            \"name\": \"validator\",\n            \"type\": \"address\"\n          },\n          {\n            \"internalType\": \"bytes\",\n            \"name\": \"data\",\n            \"type\": \"bytes\"\n          }\n        ],\n        \"internalType\": \"struct IZKPVerifier.ZKPRequest[]\",\n        \"name\": \"\",\n        \"type\": \"tuple[]\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"getZKPRequestsCount\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract IStateCrossChain\",\n        \"name\": \"stateCrossChain\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"initialize\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"sender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint64\",\n        \"name\": \"requestId\",\n        \"type\": \"uint64\"\n      }\n    ],\n    \"name\": \"isProofVerified\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract ICircuitValidator\",\n        \"name\": \"validator\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"isWhitelistedValidator\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint64\",\n        \"name\": \"requestId\",\n        \"type\": \"uint64\"\n      }\n    ],\n    \"name\": \"isZKPRequestEnabled\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"owner\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"pendingOwner\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"contract ICircuitValidator\",\n        \"name\": \"validator\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"removeValidatorFromWhitelist\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"renounceOwnership\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint64\",\n        \"name\": \"requestId\",\n        \"type\": \"uint64\"\n      }\n    ],\n    \"name\": \"requestIdExists\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint64\",\n        \"name\": \"requestId\",\n        \"type\": \"uint64\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"requestOwner\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setRequestOwner\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint64\",\n        \"name\": \"requestId\",\n        \"type\": \"uint64\"\n      },\n      {\n        \"components\": [\n          {\n            \"internalType\": \"string\",\n            \"name\": \"metadata\",\n            \"type\": \"string\"\n          },\n          {\n            \"internalType\": \"contract ICircuitValidator\",\n            \"name\": \"validator\",\n            \"type\": \"address\"\n          },\n          {\n            \"internalType\": \"bytes\",\n            \"name\": \"data\",\n            \"type\": \"bytes\"\n          }\n        ],\n        \"internalType\": \"struct IZKPVerifier.ZKPRequest\",\n        \"name\": \"request\",\n        \"type\": \"tuple\"\n      }\n    ],\n    \"name\": \"setZKPRequest\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint64\",\n        \"name\": \"requestId\",\n        \"type\": \"uint64\"\n      },\n      {\n        \"internalType\": \"uint256[]\",\n        \"name\": \"inputs\",\n        \"type\": \"uint256[]\"\n      },\n      {\n        \"internalType\": \"uint256[2]\",\n        \"name\": \"a\",\n        \"type\": \"uint256[2]\"\n      },\n      {\n        \"internalType\": \"uint256[2][2]\",\n        \"name\": \"b\",\n        \"type\": \"uint256[2][2]\"\n      },\n      {\n        \"internalType\": \"uint256[2]\",\n        \"name\": \"c\",\n        \"type\": \"uint256[2]\"\n      }\n    ],\n    \"name\": \"submitZKPResponse\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"uint64\",\n            \"name\": \"requestId\",\n            \"type\": \"uint64\"\n          },\n          {\n            \"internalType\": \"bytes\",\n            \"name\": \"zkProof\",\n            \"type\": \"bytes\"\n          },\n          {\n            \"internalType\": \"bytes\",\n            \"name\": \"data\",\n            \"type\": \"bytes\"\n          }\n        ],\n        \"internalType\": \"struct ZKPResponse[]\",\n        \"name\": \"responses\",\n        \"type\": \"tuple[]\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"crossChainProof\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"submitZKPResponseV2\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"newOwner\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"transferOwnership\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"sender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint64[]\",\n        \"name\": \"requestIds\",\n        \"type\": \"uint64[]\"\n      }\n    ],\n    \"name\": \"verifyLinkedProofs\",\n    \"outputs\": [],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint64\",\n        \"name\": \"requestId\",\n        \"type\": \"uint64\"\n      },\n      {\n        \"internalType\": \"uint256[]\",\n        \"name\": \"inputs\",\n        \"type\": \"uint256[]\"\n      },\n      {\n        \"internalType\": \"uint256[2]\",\n        \"name\": \"a\",\n        \"type\": \"uint256[2]\"\n      },\n      {\n        \"internalType\": \"uint256[2][2]\",\n        \"name\": \"b\",\n        \"type\": \"uint256[2][2]\"\n      },\n      {\n        \"internalType\": \"uint256[2]\",\n        \"name\": \"c\",\n        \"type\": \"uint256[2]\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"sender\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"verifyZKPResponse\",\n    \"outputs\": [\n      {\n        \"components\": [\n          {\n            \"internalType\": \"string\",\n            \"name\": \"key\",\n            \"type\": \"string\"\n          },\n          {\n            \"internalType\": \"uint256\",\n            \"name\": \"inputValue\",\n            \"type\": \"uint256\"\n          }\n        ],\n        \"internalType\": \"struct ICircuitValidator.KeyToInputValue[]\",\n        \"name\": \"\",\n        \"type\": \"tuple[]\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"version\",\n    \"outputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"stateMutability\": \"pure\",\n    \"type\": \"function\"\n  }\n]","import { DID, Id, chainIDfromDID } from '@iden3/js-iden3-core';\nimport { Contract, ethers } from 'ethers';\nimport { INonMerklizedIssuerABI as abi } from '@iden3/onchain-non-merklized-issuer-base-abi';\nimport { Options } from '@iden3/js-jsonld-merklization';\nimport { W3CCredential } from '../../verifiable';\nimport { OnchainNonMerklizedIssuerAdapter } from './onchain-issuer-adapter/non-merklized/version/v0.0.1/onchain-non-merklized-issuer-adapter';\nimport { EthConnectionConfig } from './state';\nimport { IOnchainIssuer } from '../interfaces/onchain-issuer';\n\ninterface OnchainIssuerOptions {\n  merklizationOptions?: Options;\n}\n\n/**\n * Represents an adapter for interacting with on-chain issuers.\n *\n * @public\n * @beta\n * @class OnchainIssuer\n */\nexport class OnchainIssuer implements IOnchainIssuer {\n  private readonly _ethConnectionConfig: EthConnectionConfig[];\n  private readonly _onchainIssuerOptions?: OnchainIssuerOptions;\n\n  /**\n   * Initializes an instance of `Adapter`.\n   * @param config The configuration for the Ethereum connection.\n   * @param merklizationOptions Optional settings for merklization.\n   */\n  constructor(config: EthConnectionConfig[], options?: OnchainIssuerOptions) {\n    this._ethConnectionConfig = config;\n    this._onchainIssuerOptions = options;\n  }\n\n  /**\n   * Retrieves a credential from the on-chain issuer.\n   * @param issuerDID The issuer's core.DID.\n   * @param userId The user's core.Id.\n   * @param credentialId The unique identifier of the credential.\n   */\n  public async getCredential(\n    issuerDID: DID,\n    userDID: DID,\n    credentialId: bigint\n  ): Promise<W3CCredential> {\n    const { contract, connection } = this.getContractConnection(issuerDID);\n    const response = await contract.getCredentialAdapterVersion();\n    switch (response) {\n      case '0.0.1': {\n        const adapter = new OnchainNonMerklizedIssuerAdapter(connection, issuerDID, {\n          merklizationOptions: this._onchainIssuerOptions?.merklizationOptions\n        });\n        await adapter.isInterfaceSupported();\n        const { credentialData, coreClaimBigInts, credentialSubjectFields } =\n          await adapter.getCredential(DID.idFromDID(userDID), credentialId);\n        return await adapter.convertOnChainInfoToW3CCredential(\n          credentialData,\n          coreClaimBigInts,\n          credentialSubjectFields\n        );\n      }\n      default:\n        throw new Error(`Unsupported adapter version ${response}`);\n    }\n  }\n\n  /**\n   * Retrieves the credential identifiers for a user from the on-chain issuer.\n   * @param issuerDID The issuer's core.DID.\n   * @param userId The user's core.Id.\n   */\n  public async getUserCredentialIds(issuerDID: DID, userDID: DID): Promise<bigint[]> {\n    const { contract, connection } = this.getContractConnection(issuerDID);\n    const response = await contract.getCredentialAdapterVersion();\n    switch (response) {\n      case '0.0.1': {\n        const adapter = new OnchainNonMerklizedIssuerAdapter(connection, issuerDID, {\n          merklizationOptions: this._onchainIssuerOptions?.merklizationOptions\n        });\n        await adapter.isInterfaceSupported();\n        return await adapter.getUserCredentialsIds(DID.idFromDID(userDID));\n      }\n      default:\n        throw new Error(`Unsupported adapter version ${response}`);\n    }\n  }\n\n  private getContractConnection(did: DID): { contract: Contract; connection: EthConnectionConfig } {\n    const issuerId = DID.idFromDID(did);\n    const chainId = chainIDfromDID(did);\n    const contractAddress = ethers.getAddress(ethers.hexlify(Id.ethAddressFromId(issuerId)));\n    const connection = this._ethConnectionConfig.find((c) => c.chainId === chainId);\n    if (!connection) {\n      throw new Error(`No connection found for chain ID ${chainId}`);\n    }\n    if (!connection.url) {\n      throw new Error(`No URL found for chain ID ${chainId}`);\n    }\n\n    const contract = new Contract(contractAddress, abi, new ethers.JsonRpcProvider(connection.url));\n\n    return { contract, connection };\n  }\n}\n","import { Claim, DID, Id } from '@iden3/js-iden3-core';\nimport { NonMerklizedIssuerBase__factory } from '@iden3/onchain-non-merklized-issuer-base-abi';\nimport { NonMerklizedIssuerBase } from '@iden3/onchain-non-merklized-issuer-base-abi';\nimport { INonMerklizedIssuer } from '@iden3/onchain-non-merklized-issuer-base-abi';\nimport {\n  CredentialStatusType,\n  DisplayMethod,\n  DisplayMethodType,\n  Iden3SparseMerkleTreeProof,\n  W3CCredential\n} from '../../../../../../verifiable';\nimport { Merklizer, Path } from '@iden3/js-jsonld-merklization';\nimport { XSDNS } from '../../../../../../circuits';\nimport { Hash, Proof } from '@iden3/js-merkletree';\nimport { JsonDocumentObject } from '../../../../../../iden3comm';\nimport { ethers } from 'ethers';\nimport { getDateFromUnixTimestamp } from '@iden3/js-iden3-core';\nimport { Options } from '@iden3/js-jsonld-merklization';\nimport { EthConnectionConfig } from '../../../../state';\n\nenum NonMerklizedIssuerInterfaces {\n  InterfaceDetection = '0x01ffc9a7',\n  InterfaceNonMerklizedIssuer = '0x58874949',\n  InterfaceGetCredential = '0x5d1ca631'\n}\n\nenum ValueHashes {\n  BooleanTrue = '18586133768512220936620570745912940619677854269274689475585506675881198879027',\n  BooleanFalse = '19014214495641488759237505126948346942972912379615652741039992445865937985820'\n}\n\n/**\n * `OnchainNonMerklizedIssuerAdapter` provides functionality to interact with a non-merklized on-chain credential issuer.\n * This adapter enables interface detection, credential retrieval, and conversion to the W3C Verifiable Credential format.\n *\n * @public\n * @beta\n * @class OnchainNonMerklizedIssuerAdapter\n */\nexport class OnchainNonMerklizedIssuerAdapter {\n  private readonly _contract: NonMerklizedIssuerBase;\n  private readonly _contractAddress: string;\n  private readonly _chainId: number;\n\n  private readonly _issuerDid: DID;\n\n  private readonly _merklizationOptions?: Options;\n\n  /**\n   * Initializes an instance of `OnchainNonMerklizedIssuerAdapter`.\n   *\n   * @param ethConnectionConfig The configuration for the Ethereum connection.\n   * @param issuerDid The decentralized identifier (DID) of the issuer.\n   * @param merklizationOptions Optional settings for merklization.\n   */\n  constructor(\n    ethConnectionConfig: EthConnectionConfig,\n    issuerDid: DID,\n    options?: {\n      merklizationOptions?: Options;\n    }\n  ) {\n    if (!ethConnectionConfig.chainId) {\n      throw new Error('Chain ID is required');\n    }\n    this._chainId = ethConnectionConfig.chainId;\n\n    this._contractAddress = ethers.getAddress(\n      ethers.hexlify(Id.ethAddressFromId(DID.idFromDID(issuerDid)))\n    );\n    this._contract = NonMerklizedIssuerBase__factory.connect(\n      this._contractAddress,\n      new ethers.JsonRpcProvider(ethConnectionConfig.url)\n    );\n\n    this._issuerDid = issuerDid;\n    this._merklizationOptions = options?.merklizationOptions;\n  }\n\n  /**\n   * Checks if the contract supports required interfaces.\n   * Throws an error if any required interface is unsupported.\n   *\n   * @throws Error - If required interfaces are not supported.\n   */\n  public async isInterfaceSupported() {\n    const supportedInterfaces = [\n      {\n        name: 'Interface detection ERC-165',\n        value: NonMerklizedIssuerInterfaces.InterfaceDetection\n      },\n      {\n        name: 'Interface non-merklized issuer',\n        value: NonMerklizedIssuerInterfaces.InterfaceNonMerklizedIssuer\n      },\n      {\n        name: 'Interface get credential',\n        value: NonMerklizedIssuerInterfaces.InterfaceGetCredential\n      }\n    ];\n\n    const unsupportedInterfaces = await Promise.all(\n      supportedInterfaces.map(async (interfaceObj) => {\n        const isSupported = await this._contract.supportsInterface(interfaceObj.value);\n        return isSupported ? null : interfaceObj.name;\n      })\n    );\n\n    const unsupportedInterfacesFiltered = unsupportedInterfaces.filter(\n      (interfaceName) => interfaceName !== null\n    );\n\n    if (unsupportedInterfacesFiltered.length > 0) {\n      throw new Error(`Unsupported interfaces: ${unsupportedInterfacesFiltered.join(', ')}`);\n    }\n  }\n\n  /**\n   * Retrieves a credential from the on-chain non-merklized contract.\n   * @param userId The user's core.Id.\n   * @param credentialId The unique identifier of the credential.\n   */\n  public async getCredential(\n    userId: Id,\n    credentialId: bigint\n  ): Promise<{\n    credentialData: INonMerklizedIssuer.CredentialDataStructOutput;\n    coreClaimBigInts: bigint[];\n    credentialSubjectFields: INonMerklizedIssuer.SubjectFieldStructOutput[];\n  }> {\n    const [credentialData, coreClaimBigInts, credentialSubjectFields] =\n      await this._contract.getCredential(userId.bigInt(), credentialId);\n    return { credentialData, coreClaimBigInts, credentialSubjectFields };\n  }\n\n  /**\n   * Retrieves the credential IDs of a user.\n   * @param userId The user's core.Id.\n   * @returns An array of credential IDs.\n   */\n  public async getUserCredentialsIds(userId: Id): Promise<bigint[]> {\n    return this._contract.getUserCredentialIds(userId.bigInt());\n  }\n\n  /**\n   * Converts on-chain credential to a verifiable credential.\n   *\n   * @param credentialData Data structure of the credential from the contract.\n   * @param coreClaimBigInts Claim data in bigint format.\n   * @param credentialSubjectFields Subject fields of the credential.\n   */\n  public async convertOnChainInfoToW3CCredential(\n    credentialData: INonMerklizedIssuer.CredentialDataStructOutput,\n    coreClaimBigInts: bigint[],\n    credentialSubjectFields: INonMerklizedIssuer.SubjectFieldStructOutput[]\n  ): Promise<W3CCredential> {\n    const c = new Claim().unMarshalJson(JSON.stringify(coreClaimBigInts.map((b) => b.toString())));\n\n    const credentialSubject = await this.convertCredentialSubject(\n      c,\n      credentialData.context,\n      credentialData._type,\n      credentialSubjectFields\n    );\n\n    const credentialRequest = {\n      id: this.credentialId(credentialData.id),\n      credentialSchema: credentialData.credentialSchema.id,\n      type: credentialData._type,\n      credentialSubject: credentialSubject,\n      expiration: c.getExpirationDate()?.getTime(),\n      displayMethod: this.convertDisplayMethod(credentialData.displayMethod),\n      context: credentialData.context,\n      revocationOpts: {\n        id: this._contractAddress,\n        nonce: Number(c.getRevocationNonce()),\n        type: CredentialStatusType.Iden3OnchainSparseMerkleTreeProof2023\n      },\n      issuanceDate: getDateFromUnixTimestamp(Number(credentialData.issuanceDate)).getTime()\n    };\n\n    const existenceProof = await this.existenceProof(c);\n    const w3c = W3CCredential.fromCredentialRequest(this._issuerDid, credentialRequest);\n    w3c.proof = [existenceProof];\n    return w3c;\n  }\n\n  private credentialId(id: bigint): string {\n    return `urn:iden3:onchain:${this._chainId}:${this._contractAddress}:${id}`;\n  }\n\n  private async convertCredentialSubject(\n    coreClaim: Claim,\n    contractContexts: string[],\n    credentialType: string,\n    credentialSubjectFields: INonMerklizedIssuer.SubjectFieldStructOutput[]\n  ): Promise<JsonDocumentObject> {\n    const contractContextsStr = JSON.stringify({\n      '@context': contractContexts\n    });\n\n    const credentialSubject = {} as JsonDocumentObject;\n    for (const f of credentialSubjectFields) {\n      const dataType = await Path.newTypeFromContext(\n        contractContextsStr,\n        `${credentialType}.${f.key}`,\n        this._merklizationOptions\n      );\n      switch (dataType) {\n        case XSDNS.Boolean: {\n          switch (f.rawValue.toString()) {\n            case ValueHashes.BooleanTrue:\n              credentialSubject[f.key] = true;\n              break;\n            case ValueHashes.BooleanFalse:\n              credentialSubject[f.key] = false;\n              break;\n          }\n          break;\n        }\n        case (XSDNS.NonNegativeInteger,\n        XSDNS.NonPositiveInteger,\n        XSDNS.NegativeInteger,\n        XSDNS.PositiveInteger): {\n          credentialSubject[f.key] = f.value.toString();\n          break;\n        }\n        case XSDNS.Integer: {\n          credentialSubject[f.key] = Number(f.value);\n          break;\n        }\n        case XSDNS.String: {\n          this.validateSourceValue(dataType, f.value, f.rawValue);\n          credentialSubject[f.key] = f.rawValue;\n          break;\n        }\n        case XSDNS.DateTime: {\n          const timestamp = BigInt(f.rawValue);\n          const sourceTimestamp = getDateFromUnixTimestamp(Number(timestamp)).toISOString();\n          this.validateSourceValue(dataType, f.value, sourceTimestamp);\n          credentialSubject[f.key] = sourceTimestamp;\n          break;\n        }\n        case XSDNS.Double: {\n          const rawFloat = Number(f.rawValue);\n          this.validateSourceValue(dataType, f.value, rawFloat);\n          credentialSubject[f.key] = rawFloat;\n          break;\n        }\n        default: {\n          throw new Error(`Unsupported data type ${dataType}`);\n        }\n      }\n    }\n    credentialSubject['type'] = credentialType;\n\n    const subjectId = coreClaim.getId();\n    const subjectDid = DID.parseFromId(subjectId);\n    credentialSubject['id'] = subjectDid.string();\n\n    return credentialSubject;\n  }\n\n  private async existenceProof(coreClaim: Claim): Promise<Iden3SparseMerkleTreeProof> {\n    const [mtpProof, stateInfo] = await this._contract.getClaimProofWithStateInfo(\n      coreClaim.hIndex()\n    );\n    if (!mtpProof.existence) {\n      throw new Error('Claim does not exist');\n    }\n    const latestStateHash = Hash.fromBigInt(stateInfo.state);\n    const latestClaimsOfRootHash = Hash.fromBigInt(stateInfo.claimsRoot);\n    const latestRevocationOfRootHash = Hash.fromBigInt(stateInfo.revocationsRoot);\n    const latestRootsOfRootHash = Hash.fromBigInt(stateInfo.rootsRoot);\n\n    const p = new Proof({\n      siblings: mtpProof.siblings.map((s) => Hash.fromBigInt(s)),\n      existence: mtpProof.existence,\n      nodeAux: mtpProof.auxExistence\n        ? {\n            key: Hash.fromBigInt(mtpProof.auxIndex),\n            value: Hash.fromBigInt(mtpProof.auxValue)\n          }\n        : undefined\n    });\n\n    return new Iden3SparseMerkleTreeProof({\n      issuerData: {\n        id: this._issuerDid,\n        state: {\n          value: latestStateHash,\n          claimsTreeRoot: latestClaimsOfRootHash,\n          revocationTreeRoot: latestRevocationOfRootHash,\n          rootOfRoots: latestRootsOfRootHash\n        }\n      },\n      mtp: p,\n      coreClaim: coreClaim\n    });\n  }\n\n  private async validateSourceValue(dataType: string, originHash: bigint, source: unknown) {\n    const sourceHash = await Merklizer.hashValue(dataType, source);\n    if (sourceHash !== originHash) {\n      throw new Error(`Invalid source value for ${dataType} type`);\n    }\n  }\n\n  private convertDisplayMethod(\n    onchainDisplayMethod: INonMerklizedIssuer.DisplayMethodStructOutput\n  ): DisplayMethod | undefined {\n    if (!onchainDisplayMethod.id || !onchainDisplayMethod._type) {\n      return undefined;\n    }\n    switch (onchainDisplayMethod._type) {\n      case DisplayMethodType.Iden3BasicDisplayMethodV1: {\n        return {\n          id: onchainDisplayMethod.id,\n          type: DisplayMethodType.Iden3BasicDisplayMethodV1\n        };\n      }\n      default: {\n        throw new Error(`Unsupported display method type ${onchainDisplayMethod._type}`);\n      }\n    }\n  }\n}\n","import { Hash } from '@iden3/js-merkletree';\nimport { DIDDocument, VerificationMethod } from '../../iden3comm';\nimport { resolveDidDocument } from '../../utils';\nimport { RootInfo, StateInfo, StateProof } from '../entities';\nimport { IStateStorage } from '../interfaces';\nimport { DID, Id } from '@iden3/js-iden3-core';\nimport { JsonRpcProvider } from 'ethers';\n\nexport class DidResolverStateReadonlyStorage implements IStateStorage {\n  constructor(private readonly resolverUrl: string) {}\n  async getLatestStateById(id: bigint): Promise<StateInfo> {\n    return this.getStateInfo(id);\n  }\n  async getStateInfoByIdAndState(id: bigint, state: bigint): Promise<StateInfo> {\n    return this.getStateInfo(id, state);\n  }\n\n  async getGISTProof(id: bigint): Promise<StateProof> {\n    const { didDocument } = await resolveDidDocument(\n      DID.parseFromId(Id.fromBigInt(id)),\n      this.resolverUrl\n    );\n    const { global } = this.getIden3StateInfo2023(didDocument);\n    if (!global) {\n      throw new Error('GIST root not found');\n    }\n    const { proof } = global;\n    if (!proof) {\n      throw new Error('GIST proof not found');\n    }\n    return {\n      root: global.root,\n      existence: proof.existence,\n      siblings: proof.siblings?.map((sibling) => BigInt(sibling)),\n      index: BigInt(0),\n      value: BigInt(0),\n      auxExistence: !!proof.node_aux,\n      auxIndex: proof.node_aux ? BigInt(proof.node_aux.key) : BigInt(0),\n      auxValue: proof.node_aux ? BigInt(proof.node_aux.value) : BigInt(0)\n    };\n  }\n\n  async getGISTRootInfo(root: bigint, userId: bigint): Promise<RootInfo> {\n    const { didDocument } = await resolveDidDocument(\n      DID.parseFromId(Id.fromBigInt(userId)),\n      this.resolverUrl,\n      {\n        gist: Hash.fromBigInt(root)\n      }\n    );\n    const { global } = this.getIden3StateInfo2023(didDocument);\n    if (!global) {\n      throw new Error('GIST root not found');\n    }\n    return global;\n  }\n\n  getRpcProvider(): JsonRpcProvider {\n    return new JsonRpcProvider();\n  }\n\n  publishState(): Promise<string> {\n    throw new Error('publishState method not implemented.');\n  }\n\n  publishStateGeneric(): Promise<string> {\n    throw new Error('publishStateGeneric method not implemented.');\n  }\n\n  private async getStateInfo(id: bigint, state?: bigint): Promise<StateInfo> {\n    const opts = state ? { state: Hash.fromBigInt(state) } : undefined;\n    const { didDocument } = await resolveDidDocument(\n      DID.parseFromId(Id.fromBigInt(id)),\n      this.resolverUrl,\n      opts\n    );\n    const { info } = this.getIden3StateInfo2023(didDocument);\n    return { ...info };\n  }\n\n  private getIden3StateInfo2023(didDocument: DIDDocument): VerificationMethod {\n    const vm: VerificationMethod | undefined = didDocument.verificationMethod?.find(\n      (i: VerificationMethod) => i.type === 'Iden3StateInfo2023'\n    );\n    if (!vm) {\n      throw new Error('Iden3StateInfo2023 verification method not found');\n    }\n    return vm;\n  }\n}\n","import { Contract, Signer, ethers } from 'ethers';\n\nimport permitAbi from './abi/ERC20Permit.json';\nimport erc20Abi from './abi/ERC20.json';\n\n/**\n * @beta\n * getPermitSignature is a function to create EIP712 Permit signature\n * @param {Signer} signer - User who owns the tokens\n * @param {string} tokenAddress - EIP-2612 contract address\n * @param {string} spender -  The contract address that will spend tokens\n * @param {bigint} value - Amount of tokens to approve\n * @param {number} deadline - Timestamp when the permit expires\n * @returns {Promise<PaymentRequestMessage>}\n */\nexport async function getPermitSignature(\n  signer: Signer,\n  tokenAddress: string,\n  spender: string,\n  value: bigint,\n  deadline: number\n) {\n  const erc20PermitContract = new Contract(tokenAddress, permitAbi, signer);\n  const nonce = await erc20PermitContract.nonces(await signer.getAddress());\n  const domainData = await erc20PermitContract.eip712Domain();\n  const domain = {\n    name: domainData[1],\n    version: domainData[2],\n    chainId: domainData[3],\n    verifyingContract: tokenAddress\n  };\n\n  const types = {\n    Permit: [\n      { name: 'owner', type: 'address' },\n      { name: 'spender', type: 'address' },\n      { name: 'value', type: 'uint256' },\n      { name: 'nonce', type: 'uint256' },\n      { name: 'deadline', type: 'uint256' }\n    ]\n  };\n\n  const message = {\n    owner: await signer.getAddress(),\n    spender: spender,\n    value: value,\n    nonce: nonce,\n    deadline: deadline\n  };\n\n  return signer.signTypedData(domain, types, message);\n}\n\n/**\n * @beta\n * getERC20Decimals is a function to retrieve the number of decimals of an ERC20 token\n * @param {string} tokenAddress - Token address\n * @param {ethers.ContractRunner} runner - Contract runner\n */\nexport async function getERC20Decimals(\n  tokenAddress: string,\n  runner: ethers.ContractRunner\n): Promise<number> {\n  const erc20Contract = new Contract(tokenAddress, erc20Abi, runner);\n  return erc20Contract.decimals();\n}\n","[{\"inputs\":[],\"name\":\"ECDSAInvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"ECDSAInvalidSignatureLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"ECDSAInvalidSignatureS\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSpender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"ERC2612ExpiredSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC2612InvalidSigner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentNonce\",\"type\":\"uint256\"}],\"name\":\"InvalidAccountNonce\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidShortString\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"StringTooLong\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EIP712DomainChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eip712Domain\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"fields\",\"type\":\"bytes1\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifyingContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"extensions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"initialSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSpender\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { W3CCredential, ProofQuery } from '../../verifiable';\n\n/**\n * search errors\n *\n * @enum {number}\n */\nexport enum SearchError {\n  NotDefinedQueryKey = 'not defined query key',\n  NotDefinedComparator = 'not defined comparator'\n}\n/**\n * supported data formats\n *\n * @enum {number}\n */\nexport enum SupportedDataFormat {\n  BigInt,\n  Boolean,\n  Double,\n  DateTime,\n  String\n}\n/** allowed operators to search */\nexport type FilterOperatorMethod =\n  | '$noop'\n  | '$eq'\n  | '$in'\n  | '$nin'\n  | '$gt'\n  | '$lt'\n  | '$ne'\n  | '$gte'\n  | '$lte'\n  | '$sd'\n  | '$exists'\n  | '$between'\n  | '$nonbetween';\n\n/** filter function type */\nexport type FilterOperatorFunction = (a: any, b: any) => boolean;\n\n/**\n * query filter interface that allows to query Verifiable Credential\n *\n * @public\n * @interface   IFilterQuery\n */\nexport interface IFilterQuery {\n  /**\n   * applies filter to verifiable credential\n   *\n   * @param {W3CCredential} credential - credential to query\n   * @returns boolean\n   */\n  execute(credential: W3CCredential): boolean;\n}\n\nconst truthyValues = [true, 1, 'true'];\nconst falsyValues = [false, 0, 'false'];\ntype ComparableType = number | string | boolean;\nconst equalsComparator = (\n  a: ComparableType | Array<ComparableType>,\n  b: ComparableType | Array<ComparableType>\n) => {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return (\n      a.length === b.length && a.every((val, index) => val === (b as Array<ComparableType>)[index])\n    );\n  }\n\n  if (!Array.isArray(a) && Array.isArray(b)) {\n    return b.includes(a);\n  }\n\n  if (Array.isArray(a) && !Array.isArray(b)) {\n    return a.includes(b);\n  }\n\n  a = a as ComparableType;\n  b = b as ComparableType;\n  if (truthyValues.includes(a) && truthyValues.includes(b)) {\n    return true;\n  }\n\n  if (falsyValues.includes(a) && falsyValues.includes(b)) {\n    return true;\n  }\n\n  return a === b;\n};\n\nconst greaterThan = (\n  a: ComparableType | ComparableType[],\n  b: ComparableType | ComparableType[]\n) => {\n  const predicate = (a: ComparableType, b: ComparableType) => {\n    const dataFormat = detectDataFormat(a.toString());\n\n    switch (dataFormat) {\n      case SupportedDataFormat.BigInt:\n      case SupportedDataFormat.Boolean:\n        return BigInt(a) > BigInt(b);\n      case SupportedDataFormat.DateTime:\n        return Date.parse(a.toString()) > Date.parse(b.toString()); /// nanoseconds won't be compared.\n      case SupportedDataFormat.Double:\n      case SupportedDataFormat.String:\n      default:\n        return a > b;\n    }\n  };\n\n  return operatorIndependentCheck(a, b, predicate);\n};\n\nconst greaterThanOrEqual = (\n  a: ComparableType | ComparableType[],\n  b: ComparableType | ComparableType[]\n) => {\n  const predicate = (a: ComparableType, b: ComparableType) => {\n    const dataFormat = detectDataFormat(a.toString());\n\n    switch (dataFormat) {\n      case SupportedDataFormat.BigInt:\n      case SupportedDataFormat.Boolean:\n        return BigInt(a) >= BigInt(b);\n      case SupportedDataFormat.DateTime:\n        return Date.parse(a.toString()) >= Date.parse(b.toString()); /// nanoseconds won't be compared.\n      case SupportedDataFormat.Double:\n      case SupportedDataFormat.String:\n      default:\n        return a >= b;\n    }\n  };\n\n  return operatorIndependentCheck(a, b, predicate);\n};\n\n// a - field value\n// b - true / false (exists operator values)\nconst existsComparator = (a: ComparableType | ComparableType[] | undefined, b: ComparableType) => {\n  if (truthyValues.includes(b) && typeof a !== 'undefined') {\n    // if exists val is true , a field val exists\n    return true;\n  }\n  // if exists val is false , a field val doesn't exist\n  if (falsyValues.includes(b) && (a === undefined || (Array.isArray(a) && !a.length))) {\n    return true;\n  }\n  return false;\n};\n\nconst inOperator = (a: ComparableType | ComparableType[], b: ComparableType | ComparableType[]) => {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.every((val) => b.includes(val));\n  }\n  if (!Array.isArray(a) && Array.isArray(b)) {\n    return b.includes(a);\n  }\n  if (Array.isArray(a) && !Array.isArray(b)) {\n    return a.includes(b);\n  }\n  return false;\n};\n\nconst betweenOperator = (\n  a: ComparableType | ComparableType[],\n  b: ComparableType | ComparableType[]\n) => {\n  if (!Array.isArray(b) || b.length !== 2) {\n    throw new Error('$between/$nonbetween operator value should be 2 elements array');\n  }\n\n  const [min, max] = b.map(BigInt);\n  const predicate = (val: bigint) => val >= min && val <= max;\n\n  if (Array.isArray(a)) {\n    return a.map(BigInt).every(predicate);\n  }\n\n  return predicate(BigInt(a));\n};\n\nexport const comparatorOptions: { [v in FilterOperatorMethod]: FilterOperatorFunction } = {\n  $noop: () => true,\n  $sd: () => true,\n  $exists: (a, b) => existsComparator(a, b),\n  $eq: (a, b) => equalsComparator(a, b),\n  $in: (a: ComparableType | ComparableType[], b: ComparableType | ComparableType[]) =>\n    inOperator(a, b),\n  $nin: (a: ComparableType | ComparableType[], b: ComparableType | ComparableType[]) =>\n    !inOperator(a, b),\n  $gt: (a: ComparableType | ComparableType[], b: ComparableType | ComparableType[]) =>\n    greaterThan(a, b),\n  $lt: (a: ComparableType | ComparableType[], b: ComparableType | ComparableType[]) =>\n    !greaterThanOrEqual(a, b),\n  $ne: (a, b) => !equalsComparator(a, b),\n  $gte: (a: ComparableType | ComparableType[], b: ComparableType | ComparableType[]) =>\n    greaterThanOrEqual(a, b),\n  $lte: (a: ComparableType | ComparableType[], b: ComparableType | ComparableType[]) =>\n    !greaterThan(a, b),\n  $between: (a: ComparableType | ComparableType[], b: ComparableType | ComparableType[]) =>\n    betweenOperator(a, b),\n  $nonbetween: (a: ComparableType | ComparableType[], b: ComparableType | ComparableType[]) =>\n    !betweenOperator(a, b)\n};\n\n/**\n * credential search path resolver\n *\n * @param {object} object - object to query\n * @param {string} path - given path\n * @param {*} [defaultValue=null]\n */\nexport const resolvePath = (object: object, path: string, defaultValue = null) => {\n  const pathParts = path.split('.');\n  let o = object;\n  for (const part of pathParts) {\n    if (o === null || o === undefined) {\n      return defaultValue;\n    }\n    o = o[part as keyof typeof o];\n  }\n  return o;\n};\n\n/**\n * Filter for queries of credentialSubject with a json path e.g  birthday.date\n *\n *\n * @public\n * @class FilterQuery\n * @implements implements IFilterQuery interface\n */\nexport class FilterQuery implements IFilterQuery {\n  /**\n   * Creates an instance of FilterQuery.\n   * @param {string} path\n   * @param {FilterOperatorFunction} operatorFunc\n   * @param {*} value\n   * @param {boolean} [isReverseParams=false]\n   */\n  constructor(\n    public path: string,\n    public operatorFunc: FilterOperatorFunction,\n    public value: any,\n    public isReverseParams = false\n  ) {}\n  /** {@inheritdoc IFilterQuery} */\n  execute(credential: W3CCredential): boolean {\n    if (!this.operatorFunc) {\n      throw new Error(SearchError.NotDefinedComparator);\n    }\n    const credentialPathValue = resolvePath(credential, this.path);\n    if (\n      (credentialPathValue === null || credentialPathValue === undefined) &&\n      this.operatorFunc !== comparatorOptions.$exists\n    ) {\n      return false;\n    }\n    if (this.isReverseParams) {\n      return this.operatorFunc(this.value, credentialPathValue);\n    }\n    return this.operatorFunc(credentialPathValue, this.value);\n  }\n}\n\n/**\n * creates filters based on proof query\n * @param {ProofQuery} query - proof query\n * @returns {*}  {FilterQuery[]} - array of filters to apply\n */\nexport const StandardJSONCredentialsQueryFilter = (query: ProofQuery): FilterQuery[] => {\n  return Object.keys(query).reduce((acc: FilterQuery[], queryKey) => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const queryValue: any = query[queryKey as keyof typeof query];\n    switch (queryKey) {\n      case 'claimId':\n        return acc.concat(new FilterQuery('id', comparatorOptions.$eq, queryValue));\n      case 'allowedIssuers': {\n        const queryValueParam = queryValue || ['*'];\n        if (queryValueParam.includes('*')) {\n          return acc;\n        }\n        return acc.concat(new FilterQuery('issuer', comparatorOptions.$in, queryValue));\n      }\n      case 'type':\n        return acc.concat(new FilterQuery('type', comparatorOptions.$in, queryValue, true));\n      case 'context':\n        return acc.concat(new FilterQuery('@context', comparatorOptions.$in, queryValue, true));\n      case 'credentialSubjectId':\n        return acc.concat(\n          new FilterQuery('credentialSubject.id', comparatorOptions.$eq, queryValue)\n        );\n      case 'schema':\n        return acc.concat(\n          new FilterQuery('credentialSchema.id', comparatorOptions.$eq, queryValue)\n        );\n      case 'credentialSubject': {\n        const reqFilters = Object.keys(queryValue).reduce((acc: FilterQuery[], fieldKey) => {\n          const fieldParams = queryValue[fieldKey];\n          if (typeof fieldParams === 'object' && Object.keys(fieldParams).length === 0) {\n            return acc.concat([\n              new FilterQuery(`credentialSubject.${fieldKey}`, comparatorOptions.$noop, null)\n            ]);\n          }\n          const res = Object.keys(fieldParams).map((comparator) => {\n            const value = fieldParams[comparator];\n            const path = `credentialSubject.${fieldKey}`;\n            return new FilterQuery(\n              path,\n              comparatorOptions[comparator as keyof typeof comparatorOptions],\n              value\n            );\n          });\n          return acc.concat(res);\n        }, []);\n\n        return acc.concat(reqFilters);\n      }\n      case 'proofType':\n      case 'groupId':\n      case 'skipClaimRevocationCheck': {\n        return acc;\n      }\n      default:\n        throw new Error(`${queryKey} : ${SearchError.NotDefinedQueryKey}`);\n    }\n  }, []);\n};\n\nconst operatorIndependentCheck = (\n  a: ComparableType | ComparableType[],\n  b: ComparableType | ComparableType[],\n  predicate: (a: ComparableType, b: ComparableType) => boolean\n) => {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.every((val, index) => predicate(val, (b as ComparableType[])[index]));\n  }\n  if (!Array.isArray(a) && Array.isArray(b)) {\n    return b.every((val) => predicate(a, val));\n  }\n  if (Array.isArray(a) && !Array.isArray(b)) {\n    return a.every((val) => predicate(val, b));\n  }\n  // in this case a and b are not arrays\n  return predicate(a as ComparableType, b as ComparableType);\n};\n\nconst regExBigInt = /^[+-]?\\d+$/;\nconst regExDouble = /^(-?)(0|([1-9][0-9]*))(\\\\.[0-9]+)?$/;\nconst regExDateTimeRFC3339Nano =\n  /* eslint-disable-next-line */\n  /^([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(([Zz])|([\\+|\\-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;\nconst regExBoolean = /^(true)|(false)$/;\nconst regExDateTimeYYYYMMDD = /^\\d{4}-\\d{2}-\\d{2}$/;\n\nconst detectDataFormat = (s: string): SupportedDataFormat =>\n  regExBigInt.test(s)\n    ? SupportedDataFormat.BigInt\n    : regExDouble.test(s)\n    ? SupportedDataFormat.Double\n    : regExDateTimeRFC3339Nano.test(s) || regExDateTimeYYYYMMDD.test(s)\n    ? SupportedDataFormat.DateTime\n    : regExBoolean.test(s)\n    ? SupportedDataFormat.Boolean\n    : SupportedDataFormat.String;\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { StorageErrors } from '../errors';\nimport { IDataSource } from '../interfaces/data-source';\n\n/**\n * Storage in the browser, uses local storage\n *\n * @public\n * @class BrowserDataSource\n * @template Type\n */\nexport class BrowserDataSource<Type> implements IDataSource<Type> {\n  /**\n   * Creates an instance of BrowserDataSource.\n   * @param {string} _localStorageKey - key string to put storage name in the local storage\n   */\n  constructor(private _localStorageKey: string) {\n    const data = localStorage.getItem(this._localStorageKey);\n    if (!data) {\n      localStorage.setItem(_localStorageKey, JSON.stringify([]));\n    }\n  }\n\n  /**\n   *\n   * saves value to the local storage\n   * @param {string} key - key value\n   * @param {Type} value - value to store\n   * @param {string} [keyName='id'] -  key name\n   */\n  async save(key: string, value: Type, keyName = 'id'): Promise<void> {\n    if (localStorage) {\n      const data = localStorage.getItem(this._localStorageKey);\n      let items: Type[] = [];\n      if (data) {\n        items = JSON.parse(data) as Type[];\n      }\n      const itemIndex = items.findIndex((i: any): boolean => i[keyName] === key);\n      if (itemIndex === -1) {\n        items.push(value);\n      } else {\n        items[itemIndex] = value;\n      }\n      localStorage.setItem(this._localStorageKey, JSON.stringify(items));\n    }\n  }\n\n  /**\n   * gets value from the local storage by given key\n   * @param {string} key - key value\n   * @param {string}  [keyName='id'] -  key name\n   */\n\n  async get(key: string, keyName = 'id'): Promise<Type | undefined> {\n    const data = localStorage.getItem(this._localStorageKey);\n    let parsedData: Type[] = [];\n    if (data) {\n      parsedData = JSON.parse(data) as Type[];\n    }\n    return parsedData.find((t: any) => t[keyName] === key);\n  }\n\n  /**\n   * loads all from the local storage\n   */\n  async load(): Promise<Type[]> {\n    const data = localStorage.getItem(this._localStorageKey);\n    return data && JSON.parse(data);\n  }\n  /**\n   * deletes item from the local storage\n   * @param {string} key - key value\n   * @param {string}  [keyName='id'] -  key name\n   */\n  async delete(key: string, keyName = 'id'): Promise<void> {\n    const dataStr = localStorage.getItem(this._localStorageKey);\n    let data: Type[] = [];\n    if (dataStr) {\n      data = JSON.parse(dataStr) as Type[];\n    }\n    const items = data.filter((i: any) => i[keyName] !== key);\n    if (data.length === items.length) {\n      throw new Error(`${StorageErrors.ItemNotFound} to delete: ${key}`);\n    }\n    localStorage.setItem(this._localStorageKey, JSON.stringify(items));\n  }\n}\n","import { LocalStorageDB, Merkletree, str2Bytes } from '@iden3/js-merkletree';\nimport { IdentityMerkleTreeMetaInformation, MerkleTreeType } from '../entities/mt';\nimport * as uuid from 'uuid';\n\nimport { IMerkleTreeStorage } from '../interfaces/merkletree';\nimport { createMerkleTreeMetaInfo } from '../utils';\n\n/**\n * Merkle tree storage that uses browser local storage\n *\n * @public\n * @class MerkleTreeLocalStorage\n * @implements implements IMerkleTreeStorage interface\n */\nexport class MerkleTreeLocalStorage implements IMerkleTreeStorage {\n  /**\n   * key for the storage key metadata\n   *\n   * @static\n   */\n  static readonly storageKeyMeta = 'merkle-tree-meta';\n\n  /**\n   * Creates an instance of MerkleTreeLocalStorage.\n   * @param {number} _mtDepth\n   */\n  constructor(private readonly _mtDepth: number) {}\n\n  /** creates a tree in the local storage */\n  async createIdentityMerkleTrees(\n    identifier: string\n  ): Promise<IdentityMerkleTreeMetaInformation[]> {\n    if (!identifier) {\n      identifier = `${uuid.v4()}`;\n    }\n    const meta = localStorage.getItem(MerkleTreeLocalStorage.storageKeyMeta);\n    if (meta) {\n      const metaInfo: IdentityMerkleTreeMetaInformation[] = JSON.parse(meta);\n      const presentMetaForIdentifier = metaInfo.find((m) => m.treeId === `${identifier}+${m.type}`);\n      if (presentMetaForIdentifier) {\n        throw new Error(\n          `Present merkle tree meta information in the store for current identifier ${identifier}`\n        );\n      }\n      const identityMetaInfo = metaInfo.filter((m) => m.identifier === identifier);\n      if (identityMetaInfo.length > 0) {\n        return identityMetaInfo;\n      }\n      const treesMeta = createMerkleTreeMetaInfo(identifier);\n      localStorage.setItem(\n        MerkleTreeLocalStorage.storageKeyMeta,\n        JSON.stringify([...metaInfo, ...treesMeta])\n      );\n\n      return [...metaInfo, ...treesMeta];\n    }\n    const treesMeta = createMerkleTreeMetaInfo(identifier);\n    localStorage.setItem(MerkleTreeLocalStorage.storageKeyMeta, JSON.stringify(treesMeta));\n    return treesMeta;\n  }\n  /**\n   *\n   * getIdentityMerkleTreesInfo from the local storage\n   * @param {string} identifier\n   * @returns `{Promise<IdentityMerkleTreeMetaInformation[]>}`\n   */\n  async getIdentityMerkleTreesInfo(\n    identifier: string\n  ): Promise<IdentityMerkleTreeMetaInformation[]> {\n    const meta = localStorage.getItem(MerkleTreeLocalStorage.storageKeyMeta);\n    if (meta) {\n      const metaInfo: IdentityMerkleTreeMetaInformation[] = JSON.parse(meta);\n      return metaInfo.filter((m) => m.identifier === identifier);\n    }\n    throw new Error(`Merkle tree meta not found for identifier ${identifier}`);\n  }\n\n  /** get merkle tree from the local storage */\n  async getMerkleTreeByIdentifierAndType(\n    identifier: string,\n    mtType: MerkleTreeType\n  ): Promise<Merkletree> {\n    const resultMeta = this.getMeta(identifier, mtType);\n    return new Merkletree(new LocalStorageDB(str2Bytes(resultMeta.treeId)), true, this._mtDepth);\n  }\n\n  private getMeta(identifier: string, mtType: MerkleTreeType) {\n    const meta = localStorage.getItem(MerkleTreeLocalStorage.storageKeyMeta);\n    const err = new Error(`Merkle tree not found for identifier ${identifier} and type ${mtType}`);\n    if (!meta) {\n      throw err;\n    }\n\n    const metaInfo: IdentityMerkleTreeMetaInformation[] = JSON.parse(meta);\n    const resultMeta = metaInfo.filter((m) => m.identifier === identifier && m.type === mtType)[0];\n    if (!resultMeta) {\n      throw err;\n    }\n    return resultMeta;\n  }\n\n  /** adds to merkle tree in the local storage */\n  async addToMerkleTree(\n    identifier: string,\n    mtType: MerkleTreeType,\n    hindex: bigint,\n    hvalue: bigint\n  ): Promise<void> {\n    const resultMeta = this.getMeta(identifier, mtType);\n\n    const tree = new Merkletree(\n      new LocalStorageDB(str2Bytes(resultMeta.treeId)),\n      true,\n      this._mtDepth\n    );\n\n    await tree.add(hindex, hvalue);\n  }\n\n  /** binds merkle tree in the local storage to the new identifiers */\n  async bindMerkleTreeToNewIdentifier(oldIdentifier: string, newIdentifier: string): Promise<void> {\n    const meta = localStorage.getItem(MerkleTreeLocalStorage.storageKeyMeta);\n    if (!meta) {\n      throw new Error(`Merkle tree meta not found for identifier ${oldIdentifier}`);\n    }\n    const metaInfo: IdentityMerkleTreeMetaInformation[] = JSON.parse(meta);\n    const treesMeta = metaInfo\n      .filter((m) => m.identifier === oldIdentifier)\n      .map((m) => ({ ...m, identifier: newIdentifier }));\n    if (treesMeta.length === 0) {\n      throw new Error(`Merkle tree meta not found for identifier ${oldIdentifier}`);\n    }\n\n    const newMetaInfo = [...metaInfo.filter((m) => m.identifier !== oldIdentifier), ...treesMeta];\n    localStorage.setItem(MerkleTreeLocalStorage.storageKeyMeta, JSON.stringify(newMetaInfo));\n  }\n}\n","/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { IDataSource } from '../interfaces/data-source';\nimport { set, get, del, values, createStore, UseStore } from 'idb-keyval';\n\n/**\n * Storage in the browser, uses indexed db storage\n *\n * @public\n * @class IndexedDBDataSource\n * @template Type\n */\nexport class IndexedDBDataSource<Type> implements IDataSource<Type> {\n  /**\n   * Creates an instance of IndexedDBDataSource.\n   *\n   * @param {string} _storageKey - key string to put storage name\n   */\n  private readonly _store: UseStore;\n  constructor(private _storageKey: string) {\n    this._store = createStore(`${_storageKey}-db`, _storageKey);\n  }\n\n  /**\n   * Saves value to the indexed db storage\n   *\n   * @param {string} key - key value\n   * @param {Type} value - value to store\n   * @param {string} [keyName='id'] -  key name\n   */\n  async save(key: string, value: Type, keyName = 'id'): Promise<void> {\n    return set(key, value, this._store);\n  }\n\n  /**\n   * Gets value from the indexed db storage by given key\n   *\n   * @param {string} key - key value\n   * @param {string}  [keyName='id'] -  key name\n   */\n  async get(key: string, keyName = 'id'): Promise<Type | undefined> {\n    return get(key, this._store);\n  }\n\n  /**\n   * loads all from the indexed db storage\n   */\n  async load(): Promise<Type[]> {\n    return values(this._store);\n  }\n  /**\n   * deletes item from the indexed db storage\n   * @param {string} key - key value\n   * @param {string}  [keyName='id'] -  key name\n   */\n  async delete(key: string, keyName = 'id'): Promise<void> {\n    return del(key, this._store);\n  }\n}\n","import { createStore, UseStore, get, set, del } from 'idb-keyval';\nimport { IndexedDBStorage, Merkletree, str2Bytes } from '@iden3/js-merkletree';\nimport { IdentityMerkleTreeMetaInformation, MerkleTreeType } from '../entities/mt';\nimport * as uuid from 'uuid';\n\nimport { IMerkleTreeStorage } from '../interfaces/merkletree';\nimport { createMerkleTreeMetaInfo } from '../utils';\n\n/**\n * Merkle tree storage that uses browser indexed db storage\n *\n * @public\n * @class MerkleTreeIndexedDBStorage\n * @implements implements IMerkleTreeStorage interface\n */\nexport class MerkleTreeIndexedDBStorage implements IMerkleTreeStorage {\n  /**\n   * key for the storage key metadata\n   *\n   * @static\n   */\n  static readonly storageKeyMeta = 'merkle-tree-meta';\n  static readonly storageBindingKeyMeta = 'binding-did';\n\n  private readonly _merkleTreeMetaStore: UseStore;\n  private readonly _bindingStore: UseStore;\n\n  /**\n   * Creates an instance of MerkleTreeIndexedDBStorage.\n   * @param {number} _mtDepth\n   */\n  constructor(private readonly _mtDepth: number) {\n    this._merkleTreeMetaStore = createStore(\n      `${MerkleTreeIndexedDBStorage.storageKeyMeta}-db`,\n      MerkleTreeIndexedDBStorage.storageKeyMeta\n    );\n    this._bindingStore = createStore(\n      `${MerkleTreeIndexedDBStorage.storageBindingKeyMeta}-db`,\n      MerkleTreeIndexedDBStorage.storageBindingKeyMeta\n    );\n  }\n\n  /** creates a tree in the indexed db storage */\n  async createIdentityMerkleTrees(\n    identifier: string\n  ): Promise<IdentityMerkleTreeMetaInformation[]> {\n    if (!identifier) {\n      identifier = `${uuid.v4()}`;\n    }\n    const existingBinging = await get(identifier, this._bindingStore);\n    if (existingBinging) {\n      throw new Error(\n        `Present merkle tree meta information in the store for current identifier ${identifier}`\n      );\n    }\n    const treesMeta = createMerkleTreeMetaInfo(identifier);\n    await set(identifier, treesMeta, this._merkleTreeMetaStore);\n    return treesMeta;\n  }\n  /**\n   *\n   * getIdentityMerkleTreesInfo from the indexed db storage\n   * @param {string} identifier\n   * @returns `{Promise<IdentityMerkleTreeMetaInformation[]>}`\n   */\n  async getIdentityMerkleTreesInfo(\n    identifier: string\n  ): Promise<IdentityMerkleTreeMetaInformation[]> {\n    const meta = await get(identifier, this._merkleTreeMetaStore);\n    if (meta) {\n      return meta;\n    }\n    throw new Error(`Merkle tree meta not found for identifier ${identifier}`);\n  }\n\n  /** get merkle tree from the indexed db storage */\n  async getMerkleTreeByIdentifierAndType(\n    identifier: string,\n    mtType: MerkleTreeType\n  ): Promise<Merkletree> {\n    const meta = await get(identifier, this._merkleTreeMetaStore);\n    const err = new Error(`Merkle tree not found for identifier ${identifier} and type ${mtType}`);\n    if (!meta) {\n      throw err;\n    }\n\n    const resultMeta = meta.find(\n      (m: { identifier: string; type: MerkleTreeType }) =>\n        m.identifier === identifier && m.type === mtType\n    );\n    if (!resultMeta) {\n      throw err;\n    }\n    return new Merkletree(new IndexedDBStorage(str2Bytes(resultMeta.treeId)), true, this._mtDepth);\n  }\n  /** adds to merkle tree in the indexed db storage */\n  async addToMerkleTree(\n    identifier: string,\n    mtType: MerkleTreeType,\n    hindex: bigint,\n    hvalue: bigint\n  ): Promise<void> {\n    const meta = await get(identifier, this._merkleTreeMetaStore);\n    if (!meta) {\n      throw new Error(`Merkle tree meta not found for identifier ${identifier}`);\n    }\n    const resultMeta = meta.find(\n      (m: { identifier: string; type: MerkleTreeType }) =>\n        m.identifier === identifier && m.type === mtType\n    );\n    if (!resultMeta) {\n      throw new Error(`Merkle tree not found for identifier ${identifier} and type ${mtType}`);\n    }\n\n    const tree = new Merkletree(\n      new IndexedDBStorage(str2Bytes(resultMeta.treeId)),\n      true,\n      this._mtDepth\n    );\n\n    await tree.add(hindex, hvalue);\n  }\n\n  /** binds merkle tree in the indexed db storage to the new identifiers */\n  async bindMerkleTreeToNewIdentifier(oldIdentifier: string, newIdentifier: string): Promise<void> {\n    const meta = await get(oldIdentifier, this._merkleTreeMetaStore);\n    if (!meta || !meta?.length) {\n      throw new Error(`Merkle tree meta not found for identifier ${oldIdentifier}`);\n    }\n\n    const treesMeta = meta.map((m: { identifier: string; type: MerkleTreeType }) => ({\n      ...m,\n      identifier: newIdentifier\n    }));\n\n    await del(oldIdentifier, this._merkleTreeMetaStore);\n    await set(newIdentifier, treesMeta, this._merkleTreeMetaStore);\n    await set(oldIdentifier, newIdentifier, this._bindingStore);\n  }\n}\n","import { CircuitId } from '../../circuits';\nimport { CircuitData } from '../entities/circuitData';\nimport { StorageErrors } from '../errors';\nimport { ICircuitStorage } from '../interfaces/circuits';\nimport { IDataSource } from '../interfaces/data-source';\n\n/**\n * Implementation of ICircuitStorage to store keys data\n *\n * @public\n * @class CircuitStorage\n * @implements implements ICircuitStorage interface\n */\nexport class CircuitStorage implements ICircuitStorage {\n  /**\n   * storage key for circuits\n   */\n  static readonly storageKey = 'circuits';\n  /**\n   * Creates an instance of CircuitStorage.\n   * @param {IDataSource<CircuitData>} _dataSource - data source to store circuit keys\n   */\n  constructor(private readonly _dataSource: IDataSource<CircuitData>) {}\n\n  /**\n   * loads circuit data by id\n   * {@inheritdoc  ICircuitStorage.loadCircuitData}\n   * @param {CircuitId} circuitId - id of the circuit\n   * @returns `Promise<CircuitData>`\n   */\n  async loadCircuitData(circuitId: CircuitId): Promise<CircuitData> {\n    const circuitData = await this._dataSource.get(circuitId.toString(), 'circuitId');\n    if (!circuitData) {\n      throw new Error(`${StorageErrors.ItemNotFound}: ${circuitId}`);\n    }\n    return circuitData;\n  }\n\n  /**\n   * {@inheritdoc  ICircuitStorage.loadCircuitData}\n   * saves circuit data for circuit id\n   * @param {CircuitId} circuitId - id of the circuit\n   * @param {CircuitData} circuitData - circuit keys\n   * @returns `Promise<void>`\n   */\n  async saveCircuitData(circuitId: CircuitId, circuitData: CircuitData): Promise<void> {\n    await this._dataSource.save(circuitId.toString(), circuitData, 'circuitId');\n  }\n}\n","import { ProofQuery, W3CCredential } from '../../verifiable';\nimport { StandardJSONCredentialsQueryFilter } from '../filters';\nimport { ICredentialStorage } from '../interfaces/credentials';\nimport { IDataSource } from '../interfaces/data-source';\n\n/**\n * Implementation of ICredentialStorage with KV Data source\n *\n * @public\n * @class CredentialStorage\n * @implements {ICredentialStorage}\n */\nexport class CredentialStorage implements ICredentialStorage {\n  /**\n   * key for storage\n   *\n   * @static\n   */\n  static readonly storageKey = 'credentials';\n  /**\n   * Creates an instance of CredentialStorage.\n   * @param {IDataSource<W3CCredential>} _dataSource - W3CCredential credential KV data source\n   */\n  constructor(private readonly _dataSource: IDataSource<W3CCredential>) {}\n\n  /** {@inheritdoc ICredentialStorage.listCredentials } */\n  async listCredentials(): Promise<W3CCredential[]> {\n    const creds = await this._dataSource.load();\n    return creds.filter((i) => i !== undefined).map((cred) => cred && W3CCredential.fromJSON(cred));\n  }\n\n  /** @inheritdoc */\n  async saveCredential(credential: W3CCredential): Promise<void> {\n    return this._dataSource.save(credential.id, credential.toJSON());\n  }\n\n  /** {@inheritdoc ICredentialStorage.listCredentials } */\n  async saveAllCredentials(credentials: W3CCredential[]): Promise<void> {\n    for (const credential of credentials) {\n      await this.saveCredential(credential);\n    }\n  }\n\n  /** {@inheritdoc ICredentialStorage.listCredentials } */\n  async removeCredential(id: string): Promise<void> {\n    return this._dataSource.delete(id);\n  }\n\n  /** {@inheritdoc ICredentialStorage.listCredentials } */\n  async findCredentialById(id: string): Promise<W3CCredential | undefined> {\n    const cred = await this._dataSource.get(id);\n    return cred && W3CCredential.fromJSON(cred);\n  }\n\n  /** {@inheritdoc ICredentialStorage.listCredentials }\n   * uses JSON query\n   */\n  async findCredentialsByQuery(query: ProofQuery): Promise<W3CCredential[]> {\n    const filters = StandardJSONCredentialsQueryFilter(query);\n    const creds = (await this._dataSource.load()).filter((credential) =>\n      filters.every((filter) => filter.execute(credential))\n    );\n\n    const mappedCreds = creds\n      .filter((i) => i !== undefined)\n      .map((cred) => W3CCredential.fromJSON(cred));\n\n    return mappedCreds;\n  }\n}\n","import { Identity, Profile } from '../entities';\nimport { IDataSource } from '../interfaces/data-source';\nimport { IIdentityStorage } from '../interfaces/identity';\n\n/**\n * Implementation of the IIdentityStorage with KV data source\n *\n * @public\n * @class IdentityStorage\n * @implements implements IIdentityStorage interface\n */\nexport class IdentityStorage implements IIdentityStorage {\n  /**\n   * storage key for identities\n   *\n   * @static\n   */\n  static readonly identitiesStorageKey = 'identities';\n  /**\n   * storage key for profiles\n   *\n   * @static\n   */\n  static readonly profilesStorageKey = 'profiles';\n\n  /**\n   * Creates an instance of IdentityStorage.\n   * @param {IDataSource<Identity>} _identityDataSource - data source for identities\n   * @param {IDataSource<Profile>} _profileDataSource - data source for profiles\n   */\n  constructor(\n    private readonly _identityDataSource: IDataSource<Identity>,\n    private readonly _profileDataSource: IDataSource<Profile>\n  ) {}\n\n  async saveProfile(profile: Profile): Promise<void> {\n    const profiles = await this._profileDataSource.load();\n    const identityProfiles = profiles.filter(\n      (p) => p.genesisIdentifier === profile.genesisIdentifier\n    );\n    const toSave = identityProfiles.length ? [...identityProfiles, profile] : [profile];\n    for (let index = 0; index < toSave.length; index++) {\n      const element = toSave[index];\n      await this._profileDataSource.save(element.id, element);\n    }\n  }\n  /**\n   *  @deprecated The method should not be used. It returns only one profile per verifier, which can potentially restrict business use cases\n   *   Use getProfilesByVerifier instead.\n   */\n  async getProfileByVerifier(verifier: string): Promise<Profile | undefined> {\n    return this._profileDataSource.get(verifier, 'verifier');\n  }\n\n  async getProfilesByVerifier(verifier: string, tags?: string[]): Promise<Profile[]> {\n    return (await this._profileDataSource.load()).filter(\n      (p) => p.verifier === verifier && (!tags || tags.every((tag) => p.tags?.includes(tag)))\n    );\n  }\n\n  async getProfileById(profileId: string): Promise<Profile | undefined> {\n    return this._profileDataSource.get(profileId);\n  }\n\n  async getProfilesByGenesisIdentifier(genesisIdentifier: string): Promise<Profile[]> {\n    return (await this._profileDataSource.load()).filter(\n      (p) => p.genesisIdentifier === genesisIdentifier\n    );\n  }\n\n  async getAllIdentities(): Promise<Identity[]> {\n    return this._identityDataSource.load();\n  }\n\n  async saveIdentity(identity: Identity): Promise<void> {\n    return this._identityDataSource.save(identity.did, identity, 'did');\n  }\n\n  async getIdentity(identifier: string): Promise<Identity | undefined> {\n    return this._identityDataSource.get(identifier, 'did');\n  }\n}\n","import { CircuitId } from '../../circuits';\nimport { CircuitData } from '../entities/circuitData';\nimport { ICircuitStorage } from '../interfaces/circuits';\n\n/**\n * Options for FSCircuitStorage,\n * Path to the circuit file is constructed from `${this._dirname}/${circuitId}/${filename}`,\n * by default values for keys are:\n *   - verification key : verification_key.json\n *   - proving key : circuit_final.zkey\n *   - wasm file : circuit.wasm\n * you can customize filename by passing the corresponding option.\n * dirname is mandatory.\n * hierarchical structure for files is mandatory\n *     e.g. --circuits\n *          -----circuitId\n *          ---------file\n * @public\n * @interface FSCircuitStorageOptions\n */\nexport interface FSCircuitStorageOptions {\n  dirname: string;\n  verificationFileName?: string;\n  provingFileName?: string;\n  wasmFileName?: string;\n}\n/**\n * Implementation of ICircuitStorage to store keys data in file system\n *\n * @public\n * @class FSCircuitStorage\n * @implements implements ICircuitStorage interface\n */\nexport class FSCircuitStorage implements ICircuitStorage {\n  private readonly _verificationKeyPath: string = 'verification_key.json';\n  private readonly _provingKeyPath: string = 'circuit_final.zkey';\n  private readonly _wasmFilePath: string = 'circuit.wasm';\n\n  private _fs: typeof import('fs') | null = null;\n\n  private readonly _browserNotSupportedError: Error = new Error(\n    'File system operations are not supported in browser environment'\n  );\n\n  private async getFs(): Promise<typeof import('fs')> {\n    if (this._fs) {\n      return this._fs;\n    }\n\n    if (!process.env.BUILD_BROWSER) {\n      this._fs = await import('fs');\n    } else {\n      this._fs = {\n        existsSync: () => {\n          throw this._browserNotSupportedError;\n        },\n        readFileSync: () => {\n          throw this._browserNotSupportedError;\n        },\n        writeFileSync: () => {\n          throw this._browserNotSupportedError;\n        },\n        mkdirSync: () => {\n          throw this._browserNotSupportedError;\n        }\n      } as unknown as typeof import('fs');\n    }\n\n    return this._fs;\n  }\n  /**\n   * Creates an instance of FSCircuitStorage.\n   * @param {string} opts - options to read / save files\n   */\n  constructor(private readonly opts: FSCircuitStorageOptions) {\n    this._verificationKeyPath = this.opts.verificationFileName ?? this._verificationKeyPath;\n    this._provingKeyPath = this.opts.provingFileName ?? this._provingKeyPath;\n    this._wasmFilePath = this.opts.wasmFileName ?? this._wasmFilePath;\n  }\n\n  /**\n   * loads circuit data by id from file storage\n   * {@inheritdoc  ICircuitStorage.loadCircuitData}\n   * @param {CircuitId} circuitId - id of the circuit\n   * @returns `Promise<CircuitData>`\n   */\n  async loadCircuitData(circuitId: CircuitId): Promise<CircuitData> {\n    const verificationKey = await this.loadCircuitFile(circuitId, this._verificationKeyPath);\n    const provingKey = await this.loadCircuitFile(circuitId, this._provingKeyPath);\n    const wasm = await this.loadCircuitFile(circuitId, this._wasmFilePath);\n\n    return {\n      circuitId,\n      wasm,\n      provingKey,\n      verificationKey\n    };\n  }\n\n  private async loadCircuitFile(\n    circuitId: CircuitId,\n    filename: string\n  ): Promise<Uint8Array | null> {\n    const keyPath = `${this.opts.dirname}/${circuitId}/${filename}`;\n    const fs = await this.getFs();\n    if (fs.existsSync(keyPath)) {\n      const keyData = fs.readFileSync(keyPath);\n      return new Uint8Array(keyData);\n    }\n    return null;\n  }\n  private async writeCircuitFile(\n    circuitId: CircuitId,\n    filename: string,\n    file: Uint8Array,\n    encoding?: BufferEncoding\n  ): Promise<void> {\n    const dirPath = `${this.opts.dirname}/${circuitId}`;\n    const keyPath = `${dirPath}/${filename}`;\n    const fs = await this.getFs();\n    fs.mkdirSync(dirPath, { recursive: true });\n    fs.writeFileSync(keyPath, file, encoding);\n  }\n\n  /**\n   * {@inheritdoc  ICircuitStorage.loadCircuitData}\n   * saves circuit data for circuit id to the file storage\n   * @param {CircuitId} circuitId - id of the circuit\n   * @param {CircuitData} circuitData - circuit keys\n   * @returns `Promise<void>`\n   */\n  async saveCircuitData(circuitId: CircuitId, circuitData: CircuitData): Promise<void> {\n    if (circuitData.verificationKey) {\n      await this.writeCircuitFile(\n        circuitId,\n        this._verificationKeyPath,\n        circuitData.verificationKey,\n        'utf-8'\n      );\n    }\n\n    if (circuitData.provingKey) {\n      await this.writeCircuitFile(circuitId, this._provingKeyPath, circuitData.provingKey);\n    }\n    if (circuitData.wasm) {\n      await this.writeCircuitFile(circuitId, this._wasmFilePath, circuitData.wasm);\n    }\n  }\n}\n","import {\n  BytesHelper,\n  DID,\n  MerklizedRootPosition,\n  getDateFromUnixTimestamp\n} from '@iden3/js-iden3-core';\nimport {\n  AuthV2Inputs,\n  AuthV2PubSignals,\n  CircuitId,\n  Operators,\n  Query,\n  TreeState,\n  ValueProof\n} from '../circuits';\nimport { ICredentialWallet } from '../credentials';\nimport { IIdentityWallet } from '../identity';\nimport {\n  createVerifiablePresentation,\n  ProofQuery,\n  RevocationStatus,\n  VerifiableConstants,\n  W3CCredential\n} from '../verifiable';\nimport {\n  PreparedCredential,\n  QueryMetadata,\n  parseCredentialSubject,\n  parseQueryMetadata,\n  toGISTProof,\n  transformQueryValueToBigInts\n} from './common';\nimport { IZKProver, NativeProver } from './provers/prover';\n\nimport { Merklizer, Options, getDocumentLoader } from '@iden3/js-jsonld-merklization';\nimport { ZKProof } from '@iden3/js-jwz';\nimport { Signer } from 'ethers';\nimport {\n  StateVerificationOpts,\n  JSONObject,\n  ZeroKnowledgeProofRequest,\n  ZeroKnowledgeProofResponse,\n  PROTOCOL_CONSTANTS,\n  VerifiablePresentation,\n  JsonDocumentObject,\n  ZeroKnowledgeProofAuthResponse\n} from '../iden3comm';\nimport { cacheLoader } from '../schema-processor';\nimport { ICircuitStorage, IStateStorage } from '../storage';\nimport { byteDecoder, byteEncoder } from '../utils/encoding';\nimport {\n  AuthProofGenerationOptions,\n  InputGenerator,\n  ProofGenerationOptions,\n  ProofInputsParams\n} from './provers/inputs-generator';\nimport { PubSignalsVerifier, VerifyContext } from './verifiers/pub-signals-verifier';\nimport { VerifyOpts } from './verifiers';\n\nexport interface QueryWithFieldName {\n  query: Query;\n  fieldName: string;\n  rawValue?: unknown;\n  isSelectiveDisclosure?: boolean;\n}\n\n/**\n *  Metadata that returns on verification\n * @type VerificationResultMetadata\n */\nexport type VerificationResultMetadata = {\n  linkID?: number;\n};\n\n/**\n *  List of options to customize ProofService\n */\nexport type ProofServiceOptions = Options & {\n  prover?: IZKProver;\n};\n\nexport interface ProofVerifyOpts {\n  query: ProofQuery;\n  sender: string;\n  opts?: VerifyOpts;\n  params?: JSONObject;\n}\n\nexport interface IProofService {\n  /**\n   * Verification of zkp proof for given circuit id\n   *\n   * @param {ZKProof} zkp  - proof to verify\n   * @param {CircuitId} circuitId - circuit id\n   * @returns `{Promise<boolean>}`\n   */\n  verifyProof(zkp: ZKProof, circuitName: CircuitId): Promise<boolean>;\n\n  /**\n   * Verification of zkp proof and pub signals for given circuit id\n   *\n   * @param {ZeroKnowledgeProofResponse} response  - zero knowledge proof response\n   * @param {ProofVerifyOpts} opts - proof verification options\n   * @returns `{Promise<VerificationResultMetadata>}`\n   */\n  verifyZKPResponse(\n    proofResp: ZeroKnowledgeProofResponse,\n    opts: ProofVerifyOpts\n  ): Promise<VerificationResultMetadata>;\n\n  /**\n   * Generate proof from given identity and credential for protocol proof request\n   *\n   * @param {ZeroKnowledgeProofRequest} proofReq - protocol zkp request\n   * @param {DID} identifier - did that will generate proof\n   * @param {W3CCredential} credential - credential that will be used for proof generation\n   * @param {ProofGenerationOptions} opts - options that will be used for proof generation\n   *\n   * @returns `Promise<ZeroKnowledgeProofResponse>`\n   */\n  generateProof(\n    proofReq: ZeroKnowledgeProofRequest,\n    identifier: DID,\n    opts?: ProofGenerationOptions\n  ): Promise<ZeroKnowledgeProofResponse>;\n\n  /**\n   * generates auth inputs\n   *\n   * @param {Uint8Array} hash - challenge that will be signed\n   * @param {DID} did - identity that will generate a proof\n   * @param {CircuitId} circuitId - circuit id for authentication\n   * @returns `Promise<Uint8Array>`\n   */\n  generateAuthV2Inputs(hash: Uint8Array, did: DID, circuitId: CircuitId): Promise<Uint8Array>;\n\n  /**\n   * generates auth v2 proof from given identity\n   *\n   * @param {Uint8Array} hash - challenge that will be signed\n   * @param {DID} did - identity that will generate a proof\n   * @returns `Promise<ZKProof>`\n   */\n  generateAuthV2Proof(hash: Uint8Array, did: DID): Promise<ZKProof>;\n\n  /**\n   * Generate auth proof from given identity with generic params\n   *\n   * @param {CircuitId} circuitId - circuitId for the proof generation\n   * @param {DID} identifier - did that will generate proof\n   * @param {ProofGenerationOptions} opts - options that will be used for proof generation\n   *\n   * @returns `Promise<ZeroKnowledgeProofResponse>`\n   */\n  generateAuthProof(\n    circuitId: CircuitId,\n    identifier: DID,\n    opts?: AuthProofGenerationOptions\n  ): Promise<ZeroKnowledgeProofAuthResponse>;\n\n  /**\n   * state verification function\n   *\n   * @param {string} circuitId - id of authentication circuit\n   * @param {Array<string>} pubSignals - public signals of authentication circuit\n   * @returns `Promise<boolean>`\n   */\n  verifyState(circuitId: string, pubSignals: Array<string>): Promise<boolean>;\n  /**\n   * transitState is done always to the latest state\n   *\n   * Generates a state transition proof and publishes state to the blockchain\n   *\n   * @param {DID} did - identity that will transit state\n   * @param {TreeState} oldTreeState - previous tree state\n   * @param {boolean} isOldStateGenesis - is a transition state is done from genesis state\n   * @param {Signer} ethSigner - signer for transaction\n   * @returns `{Promise<string>}` - transaction hash is returned\n   */\n  transitState(\n    did: DID,\n    oldTreeState: TreeState,\n    isOldStateGenesis: boolean,\n    stateStorage: IStateStorage,\n    ethSigner: Signer\n  ): Promise<string>;\n\n  findCredentialByProofQuery(\n    did: DID,\n    query: ProofQuery,\n    opts?: { skipClaimRevocationCheck: boolean }\n  ): Promise<{ cred: W3CCredential; revStatus: RevocationStatus | undefined }>;\n}\n/**\n * Proof service is an implementation of IProofService\n * that works with a native groth16 prover\n *\n * @public\n * @class ProofService\n * @implements implements IProofService interface\n */\nexport class ProofService implements IProofService {\n  private readonly _prover: IZKProver;\n  private readonly _ldOptions: Options;\n  private readonly _inputsGenerator: InputGenerator;\n  private readonly _pubSignalsVerifier: PubSignalsVerifier;\n  /**\n   * Creates an instance of ProofService.\n   * @param {IIdentityWallet} _identityWallet - identity wallet\n   * @param {ICredentialWallet} _credentialWallet - credential wallet\n   * @param {ICircuitStorage} _circuitStorage - circuit storage to load proving / verification files\n   * @param {IStateStorage} _stateStorage - state storage to get GIST proof / publish state\n   */\n  constructor(\n    private readonly _identityWallet: IIdentityWallet,\n    private readonly _credentialWallet: ICredentialWallet,\n    _circuitStorage: ICircuitStorage,\n    private readonly _stateStorage: IStateStorage,\n    opts?: ProofServiceOptions\n  ) {\n    this._prover = opts?.prover ?? new NativeProver(_circuitStorage);\n    this._ldOptions = { ...opts, documentLoader: opts?.documentLoader ?? cacheLoader(opts) };\n    this._inputsGenerator = new InputGenerator(_identityWallet, _credentialWallet, _stateStorage);\n    this._pubSignalsVerifier = new PubSignalsVerifier(\n      opts?.documentLoader ?? cacheLoader(opts),\n      _stateStorage\n    );\n  }\n\n  /** {@inheritdoc IProofService.verifyProof} */\n  async verifyProof(zkp: ZKProof, circuitId: CircuitId): Promise<boolean> {\n    return this._prover.verify(zkp, circuitId);\n  }\n\n  /** {@inheritdoc IProofService.verify} */\n  async verifyZKPResponse(\n    proofResp: ZeroKnowledgeProofResponse,\n    opts: ProofVerifyOpts\n  ): Promise<VerificationResultMetadata> {\n    const proofValid = await this._prover.verify(proofResp, proofResp.circuitId);\n    if (!proofValid) {\n      throw Error(\n        `Proof with circuit id ${proofResp.circuitId} and request id ${proofResp.id} is not valid`\n      );\n    }\n\n    const verifyContext: VerifyContext = {\n      pubSignals: proofResp.pub_signals,\n      query: opts.query,\n      verifiablePresentation: proofResp.vp,\n      sender: opts.sender,\n      challenge: BigInt(proofResp.id),\n      opts: opts.opts,\n      params: opts.params\n    };\n    const pubSignals = await this._pubSignalsVerifier.verify(proofResp.circuitId, verifyContext);\n\n    return { linkID: (pubSignals as unknown as { linkID?: number }).linkID };\n  }\n\n  /** {@inheritdoc IProofService.generateProof} */\n  async generateProof(\n    proofReq: ZeroKnowledgeProofRequest,\n    identifier: DID,\n    opts?: ProofGenerationOptions\n  ): Promise<ZeroKnowledgeProofResponse> {\n    if (!opts) {\n      opts = {\n        skipRevocation: false,\n        challenge: 0n\n      };\n    }\n\n    let credentialWithRevStatus: {\n      cred: W3CCredential | undefined;\n      revStatus: RevocationStatus | undefined;\n    } = { cred: opts.credential, revStatus: opts.credentialRevocationStatus };\n\n    if (!opts.credential) {\n      credentialWithRevStatus = await this.findCredentialByProofQuery(identifier, proofReq.query);\n    }\n\n    if (opts.credential && !opts.credentialRevocationStatus && !opts.skipRevocation) {\n      const revStatus = await this._credentialWallet.getRevocationStatusFromCredential(\n        opts.credential\n      );\n      credentialWithRevStatus = { cred: opts.credential, revStatus };\n    }\n\n    if (!credentialWithRevStatus.cred) {\n      throw new Error(\n        VerifiableConstants.ERRORS.PROOF_SERVICE_NO_CREDENTIAL_FOR_QUERY +\n          ` ${JSON.stringify(proofReq.query)}`\n      );\n    }\n\n    const credentialCoreClaim = await this._identityWallet.getCoreClaimFromCredential(\n      credentialWithRevStatus.cred\n    );\n\n    const { nonce: authProfileNonce, genesisDID } =\n      await this._identityWallet.getGenesisDIDMetadata(identifier);\n\n    const preparedCredential: PreparedCredential = {\n      credential: credentialWithRevStatus.cred,\n      credentialCoreClaim,\n      revStatus: credentialWithRevStatus.revStatus\n    };\n\n    const subjectDID = DID.parse(preparedCredential.credential.credentialSubject['id'] as string);\n\n    const { nonce: credentialSubjectProfileNonce, genesisDID: subjectGenesisDID } =\n      await this._identityWallet.getGenesisDIDMetadata(subjectDID);\n\n    if (subjectGenesisDID.string() !== genesisDID.string()) {\n      throw new Error(VerifiableConstants.ERRORS.PROOF_SERVICE_PROFILE_GENESIS_DID_MISMATCH);\n    }\n\n    const propertiesMetadata = parseCredentialSubject(\n      proofReq.query.credentialSubject as JsonDocumentObject\n    );\n    if (!propertiesMetadata.length) {\n      throw new Error(VerifiableConstants.ERRORS.PROOF_SERVICE_NO_QUERIES_IN_ZKP_REQUEST);\n    }\n\n    const mtPosition = preparedCredential.credentialCoreClaim.getMerklizedPosition();\n\n    let mk: Merklizer | undefined;\n    if (mtPosition !== MerklizedRootPosition.None) {\n      mk = await preparedCredential.credential.merklize(this._ldOptions);\n    }\n\n    const context = proofReq.query['context'] as string;\n    const groupId = proofReq.query['groupId'] as number;\n\n    const ldContext = await this.loadLdContext(context);\n\n    const credentialType = proofReq.query['type'] as string;\n    const queriesMetadata: QueryMetadata[] = [];\n    const circuitQueries: Query[] = [];\n\n    for (const propertyMetadata of propertiesMetadata) {\n      const queryMetadata = await parseQueryMetadata(\n        propertyMetadata,\n        byteDecoder.decode(ldContext),\n        credentialType,\n        this._ldOptions\n      );\n\n      queriesMetadata.push(queryMetadata);\n      const circuitQuery = await this.toCircuitsQuery(\n        preparedCredential.credential,\n        queryMetadata,\n        mk\n      );\n      circuitQueries.push(circuitQuery);\n    }\n\n    const inputs = await this.generateInputs(\n      preparedCredential,\n      genesisDID,\n      proofReq,\n      {\n        ...opts,\n        authProfileNonce,\n        credentialSubjectProfileNonce,\n        linkNonce: groupId ? opts.linkNonce : 0n\n      },\n      circuitQueries\n    );\n\n    const sdQueries = queriesMetadata.filter((q) => q.operator === Operators.SD);\n    let vp: VerifiablePresentation | undefined;\n    if (sdQueries.length) {\n      vp = createVerifiablePresentation(\n        context,\n        credentialType,\n        preparedCredential.credential,\n        sdQueries\n      );\n    }\n\n    const { proof, pub_signals } = await this._prover.generate(inputs, proofReq.circuitId);\n\n    return {\n      id: proofReq.id,\n      circuitId: proofReq.circuitId,\n      vp,\n      proof,\n      pub_signals\n    };\n  }\n\n  /** {@inheritdoc IProofService.generateAuthProof} */\n  async generateAuthProof(\n    circuitId: CircuitId,\n    identifier: DID,\n    opts?: AuthProofGenerationOptions\n  ): Promise<ZeroKnowledgeProofAuthResponse> {\n    if (!opts) {\n      opts = {\n        challenge: 0n\n      };\n    }\n\n    let zkProof;\n\n    switch (circuitId) {\n      case CircuitId.AuthV2:\n        {\n          const challenge = opts.challenge\n            ? BytesHelper.intToBytes(opts.challenge).reverse()\n            : new Uint8Array(32);\n          zkProof = await this.generateAuthV2Proof(challenge, identifier);\n        }\n        return {\n          circuitId: circuitId,\n          proof: zkProof.proof,\n          pub_signals: zkProof.pub_signals\n        };\n      default:\n        throw new Error(`CircuitId ${circuitId} is not supported`);\n    }\n  }\n\n  /** {@inheritdoc IProofService.transitState} */\n  async transitState(\n    did: DID,\n    oldTreeState: TreeState,\n    isOldStateGenesis: boolean,\n    stateStorage: IStateStorage, // for compatibility with previous versions we leave this parameter\n    ethSigner: Signer\n  ): Promise<string> {\n    return this._identityWallet.transitState(\n      did,\n      oldTreeState,\n      isOldStateGenesis,\n      ethSigner,\n      this._prover\n    );\n  }\n\n  private async generateInputs(\n    preparedCredential: PreparedCredential,\n    identifier: DID,\n    proofReq: ZeroKnowledgeProofRequest,\n    params: ProofInputsParams,\n    circuitQueries: Query[]\n  ): Promise<Uint8Array> {\n    return this._inputsGenerator.generateInputs({\n      preparedCredential,\n      identifier,\n      proofReq,\n      params,\n      circuitQueries\n    });\n  }\n\n  private async toCircuitsQuery(\n    credential: W3CCredential,\n    queryMetadata: QueryMetadata,\n    merklizedCredential?: Merklizer\n  ): Promise<Query> {\n    if (queryMetadata.merklizedSchema && !merklizedCredential) {\n      throw new Error('merklized root position is set to None for merklized schema');\n    }\n    if (!queryMetadata.merklizedSchema && merklizedCredential) {\n      throw new Error('merklized root position is not set to None for non-merklized schema');\n    }\n    const query = new Query();\n\n    query.slotIndex = queryMetadata.slotIndex;\n    query.operator = queryMetadata.operator;\n    query.values = queryMetadata.values;\n\n    if (queryMetadata.merklizedSchema && merklizedCredential) {\n      const { proof, value: mtValue } = await merklizedCredential.proof(queryMetadata.path);\n      query.valueProof = new ValueProof();\n      query.valueProof.mtp = proof;\n      query.valueProof.path = queryMetadata.claimPathKey;\n\n      const mtEntry = (await mtValue?.mtEntry()) ?? 0n;\n      query.valueProof.value = mtEntry;\n      if (!queryMetadata.fieldName) {\n        query.values = [mtEntry];\n        return query;\n      }\n    }\n\n    if (queryMetadata.operator === Operators.SD) {\n      const [first, ...rest] = queryMetadata.fieldName.split('.');\n      let v = credential.credentialSubject[first];\n      for (const part of rest) {\n        v = (v as JsonDocumentObject)[part];\n      }\n      if (typeof v === 'undefined') {\n        throw new Error(`credential doesn't contain value for field ${queryMetadata.fieldName}`);\n      }\n      query.values = await transformQueryValueToBigInts(v, queryMetadata.datatype);\n    }\n\n    return query;\n  }\n\n  private async loadLdContext(context: string): Promise<Uint8Array> {\n    const loader = getDocumentLoader(this._ldOptions);\n    let ldSchema: object;\n    try {\n      ldSchema = (await loader(context)).document;\n    } catch (e) {\n      throw new Error(`can't load ld context from url ${context}`);\n    }\n    return byteEncoder.encode(JSON.stringify(ldSchema));\n  }\n\n  /** {@inheritdoc IProofService.generateAuthV2Inputs} */\n  async generateAuthV2Inputs(\n    hash: Uint8Array,\n    did: DID,\n    circuitId: CircuitId\n  ): Promise<Uint8Array> {\n    if (circuitId !== CircuitId.AuthV2) {\n      throw new Error('CircuitId is not supported');\n    }\n\n    const { nonce: authProfileNonce, genesisDID } =\n      await this._identityWallet.getGenesisDIDMetadata(did);\n\n    const challenge = BytesHelper.bytesToInt(hash.reverse());\n\n    const authPrepared = await this._inputsGenerator.prepareAuthBJJCredential(genesisDID);\n\n    const signature = await this._identityWallet.signChallenge(challenge, authPrepared.credential);\n    const id = DID.idFromDID(genesisDID);\n    const stateProof = await this._stateStorage.getGISTProof(id.bigInt());\n\n    const gistProof = toGISTProof(stateProof);\n\n    const authInputs = new AuthV2Inputs();\n\n    authInputs.genesisID = id;\n    authInputs.profileNonce = BigInt(authProfileNonce);\n    authInputs.authClaim = authPrepared.coreClaim;\n    authInputs.authClaimIncMtp = authPrepared.incProof.proof;\n    authInputs.authClaimNonRevMtp = authPrepared.nonRevProof.proof;\n    authInputs.treeState = authPrepared.incProof.treeState;\n    authInputs.signature = signature;\n    authInputs.challenge = challenge;\n    authInputs.gistProof = gistProof;\n    return authInputs.inputsMarshal();\n  }\n\n  /** {@inheritdoc IProofService.generateAuthV2Proof} */\n  async generateAuthV2Proof(challenge: Uint8Array, did: DID): Promise<ZKProof> {\n    const authInputs = await this.generateAuthV2Inputs(challenge, did, CircuitId.AuthV2);\n\n    const zkProof = await this._prover.generate(authInputs, CircuitId.AuthV2);\n    return zkProof;\n  }\n\n  async verifyState(\n    circuitId: string,\n    pubSignals: string[],\n    opts: StateVerificationOpts = {\n      acceptedStateTransitionDelay: PROTOCOL_CONSTANTS.DEFAULT_AUTH_VERIFY_DELAY\n    }\n  ): Promise<boolean> {\n    if (circuitId !== CircuitId.AuthV2) {\n      throw new Error(`CircuitId is not supported ${circuitId}`);\n    }\n\n    const authV2PubSignals = new AuthV2PubSignals().pubSignalsUnmarshal(\n      byteEncoder.encode(JSON.stringify(pubSignals))\n    );\n    const gistRoot = authV2PubSignals.GISTRoot.bigInt();\n    const userId = authV2PubSignals.userID.bigInt();\n    const globalStateInfo = await this._stateStorage.getGISTRootInfo(gistRoot, userId);\n\n    if (globalStateInfo.root !== gistRoot) {\n      throw new Error(`gist info contains invalid state`);\n    }\n\n    if (globalStateInfo.replacedByRoot !== 0n) {\n      if (globalStateInfo.replacedAtTimestamp === 0n) {\n        throw new Error(`state was replaced, but replaced time unknown`);\n      }\n\n      const timeDiff =\n        Date.now() -\n        getDateFromUnixTimestamp(Number(globalStateInfo.replacedAtTimestamp)).getTime();\n\n      if (\n        timeDiff >\n        (opts?.acceptedStateTransitionDelay ?? PROTOCOL_CONSTANTS.DEFAULT_AUTH_VERIFY_DELAY)\n      ) {\n        throw new Error('global state is outdated');\n      }\n    }\n\n    return true;\n  }\n\n  async findCredentialByProofQuery(\n    did: DID,\n    query: ProofQuery\n  ): Promise<{ cred: W3CCredential; revStatus: RevocationStatus | undefined }> {\n    const credentials = await this._identityWallet.findOwnedCredentialsByDID(did, query);\n\n    if (!credentials.length) {\n      throw new Error(\n        VerifiableConstants.ERRORS.PROOF_SERVICE_NO_CREDENTIAL_FOR_IDENTITY_OR_PROFILE\n      );\n    }\n\n    //  For EQ / IN / NIN / LT / GT operations selective if credential satisfies query - we can get any.\n    // TODO: choose credential for selective credentials\n    const credential = query.skipClaimRevocationCheck\n      ? { cred: credentials[0], revStatus: undefined }\n      : await this._credentialWallet.findNonRevokedCredential(credentials);\n\n    return credential;\n  }\n}\n","import { NodeAux, Hash, Proof, ZERO_HASH } from '@iden3/js-merkletree';\nimport {\n  buildTreeState,\n  ClaimNonRevStatus,\n  GISTProof,\n  isValidOperation,\n  Operators,\n  QueryOperators\n} from '../circuits';\nimport { StateProof } from '../storage/entities/state';\nimport {\n  MerkleTreeProofWithTreeState,\n  RevocationStatus,\n  W3CCredential,\n  buildFieldPath,\n  getSerializationAttrFromContext,\n  getFieldSlotIndex\n} from '../verifiable';\nimport { Merklizer, Options, Path } from '@iden3/js-jsonld-merklization';\nimport { byteEncoder } from '../utils';\nimport { JsonDocumentObject } from '../iden3comm';\nimport { Claim } from '@iden3/js-iden3-core';\nimport { poseidon } from '@iden3/js-crypto';\n\nexport type PreparedCredential = {\n  credential: W3CCredential;\n  credentialCoreClaim: Claim;\n  revStatus?: RevocationStatus;\n};\n\nexport type PreparedAuthBJJCredential = {\n  credential: W3CCredential;\n  incProof: MerkleTreeProofWithTreeState;\n  nonRevProof: MerkleTreeProofWithTreeState;\n  coreClaim: Claim;\n};\n/**\n * converts verifiable RevocationStatus model to circuits structure\n *\n * @param {RevocationStatus} - credential.status of the verifiable credential\n * @returns {ClaimNonRevStatus}\n */\nexport const toClaimNonRevStatus = (s?: RevocationStatus): ClaimNonRevStatus => {\n  if (!s) {\n    const hash = poseidon.hash(new Array(3).fill(0n));\n    return {\n      proof: new Proof(),\n      treeState: {\n        state: Hash.fromBigInt(hash),\n        claimsRoot: ZERO_HASH,\n        revocationRoot: ZERO_HASH,\n        rootOfRoots: ZERO_HASH\n      }\n    };\n  }\n  return {\n    proof: s.mtp,\n    treeState: buildTreeState(\n      s.issuer.state,\n      s.issuer.claimsTreeRoot,\n      s.issuer.revocationTreeRoot,\n      s.issuer.rootOfRoots\n    )\n  };\n};\n\n/**\n * converts state info from smart contract to gist proof\n *\n * @param {StateProof} smtProof  - state proof from smart contract\n * @returns {GISTProof}\n */\nexport const toGISTProof = (smtProof: StateProof): GISTProof => {\n  let existence = false;\n  let nodeAux: NodeAux | undefined;\n\n  if (smtProof.existence) {\n    existence = true;\n  } else {\n    if (smtProof.auxExistence) {\n      nodeAux = {\n        key: Hash.fromBigInt(smtProof.auxIndex),\n        value: Hash.fromBigInt(smtProof.auxValue)\n      };\n    }\n  }\n\n  const allSiblings: Hash[] = smtProof.siblings.map((s) => Hash.fromBigInt(s));\n\n  const proof = new Proof({ siblings: allSiblings, nodeAux: nodeAux, existence: existence });\n\n  const root = Hash.fromBigInt(smtProof.root);\n\n  return {\n    root,\n    proof\n  };\n};\n\nexport type PropertyQuery = {\n  fieldName: string;\n  operator: Operators;\n  operatorValue?: unknown;\n};\n\nexport type QueryMetadata = PropertyQuery & {\n  slotIndex: number;\n  values: bigint[];\n  path: Path;\n  claimPathKey: bigint;\n  datatype: string;\n  merklizedSchema: boolean;\n};\n\nexport const parseCredentialSubject = (credentialSubject?: JsonDocumentObject): PropertyQuery[] => {\n  // credentialSubject is empty\n  if (!credentialSubject) {\n    return [{ operator: QueryOperators.$noop, fieldName: '' }];\n  }\n\n  const queries: PropertyQuery[] = [];\n  const entries = Object.entries(credentialSubject);\n  if (!entries.length) {\n    throw new Error(`query must have at least 1 predicate`);\n  }\n\n  for (const [fieldName, fieldReq] of entries) {\n    const fieldReqEntries = Object.entries(fieldReq as { [key: string]: unknown });\n\n    const isSelectiveDisclosure = fieldReqEntries.length === 0;\n\n    if (isSelectiveDisclosure) {\n      queries.push({ operator: QueryOperators.$sd, fieldName: fieldName });\n      continue;\n    }\n\n    for (const [operatorName, operatorValue] of fieldReqEntries) {\n      if (!QueryOperators[operatorName as keyof typeof QueryOperators]) {\n        throw new Error(`operator is not supported by lib`);\n      }\n      const operator = QueryOperators[operatorName as keyof typeof QueryOperators];\n      queries.push({ operator, fieldName, operatorValue });\n    }\n  }\n  return queries;\n};\n\nexport const parseQueryMetadata = async (\n  propertyQuery: PropertyQuery,\n  ldContextJSON: string,\n  credentialType: string,\n  options: Options\n): Promise<QueryMetadata> => {\n  const query: QueryMetadata = {\n    ...propertyQuery,\n    slotIndex: 0,\n    merklizedSchema: false,\n    datatype: '',\n    claimPathKey: BigInt(0),\n    values: [],\n    path: new Path()\n  };\n\n  if (!propertyQuery.fieldName && propertyQuery.operator !== Operators.NOOP) {\n    throw new Error('query must have a field name if operator is not $noop');\n  }\n\n  if (propertyQuery.fieldName) {\n    query.datatype = await Path.newTypeFromContext(\n      ldContextJSON,\n      `${credentialType}.${propertyQuery.fieldName}`,\n      options\n    );\n  }\n\n  const serAttr = await getSerializationAttrFromContext(\n    JSON.parse(ldContextJSON),\n    options,\n    credentialType\n  );\n  if (!serAttr) {\n    query.merklizedSchema = true;\n  }\n  // for merklized credentials slotIndex in query must be equal to zero\n  // and not a position of merklization root.\n  // it has no influence on check in the off-chain circuits, but it aligns with onchain verification standard\n\n  if (!query.merklizedSchema) {\n    query.slotIndex = await getFieldSlotIndex(\n      propertyQuery.fieldName,\n      credentialType,\n      byteEncoder.encode(ldContextJSON)\n    );\n  } else {\n    try {\n      const path = await buildFieldPath(\n        ldContextJSON,\n        credentialType,\n        propertyQuery.fieldName,\n        options\n      );\n      query.claimPathKey = await path.mtEntry();\n      query.path = path;\n    } catch (e) {\n      throw new Error(`field does not exist in the schema ${(e as Error).message}`);\n    }\n  }\n\n  if (propertyQuery.operatorValue !== undefined) {\n    if (!isValidOperation(query.datatype, propertyQuery.operator)) {\n      throw new Error(\n        `operator ${propertyQuery.operator} is not supported for datatype ${query.datatype}`\n      );\n    }\n\n    if (\n      (propertyQuery.operator === Operators.NOOP || propertyQuery.operator === Operators.SD) &&\n      propertyQuery.operatorValue\n    ) {\n      throw new Error(`operator value should be undefined for ${propertyQuery.operator} operator`);\n    }\n\n    let values: bigint[];\n    switch (propertyQuery.operator) {\n      case Operators.NOOP:\n      case Operators.SD:\n        values = [];\n        break;\n      case Operators.EXISTS:\n        values = transformExistsValue(propertyQuery.operatorValue);\n        break;\n      default:\n        values = await transformQueryValueToBigInts(propertyQuery.operatorValue, query.datatype);\n    }\n    query.values = values;\n  }\n  return query;\n};\n\nexport const parseQueriesMetadata = async (\n  credentialType: string,\n  ldContextJSON: string,\n  credentialSubject: JsonDocumentObject,\n  options: Options\n): Promise<QueryMetadata[]> => {\n  const queriesMetadata = parseCredentialSubject(credentialSubject);\n  return Promise.all(\n    queriesMetadata.map((m) => parseQueryMetadata(m, ldContextJSON, credentialType, options))\n  );\n};\n\nexport const transformQueryValueToBigInts = async (\n  value: unknown,\n  ldType: string\n): Promise<bigint[]> => {\n  const values: bigint[] = [];\n\n  if (Array.isArray(value)) {\n    for (let index = 0; index < value.length; index++) {\n      values[index] = await Merklizer.hashValue(ldType, value[index]);\n    }\n  } else {\n    values[0] = await Merklizer.hashValue(ldType, value);\n  }\n  return values;\n};\n\nconst transformExistsValue = (value: unknown): bigint[] => {\n  if (typeof value == 'boolean') {\n    return [BigInt(value)];\n  }\n  throw new Error('exists operator value must be true or false');\n};\n","import { verifyGroth16Proof, ZKProof } from '@iden3/js-jwz';\nimport { witnessBuilder } from './witness_calculator';\nimport * as snarkjs from 'snarkjs';\nimport * as ffjavascript from 'ffjavascript';\nimport { ICircuitStorage } from '../../storage';\nimport { CircuitId } from '../../circuits';\nimport { byteDecoder } from '../../utils';\n\n/**\n * ZKProver is responsible for proof generation and verification\n *\n * @public\n * @interface ZKProver\n */\nexport interface IZKProver {\n  /**\n   * generates zero knowledge proof\n   *\n   * @param {Uint8Array} inputs - inputs that will be used for proof generation\n   * @param {string} circuitId - circuit id for proof generation\n   * @returns `Promise<ZKProof>`\n   */\n  generate(inputs: Uint8Array, circuitId: string): Promise<ZKProof>;\n  /**\n   * verifies zero knowledge proof\n   *\n   * @param {ZKProof} zkp - zero knowledge proof that will be verified\n   * @param {string} circuitId - circuit id for proof verification\n   * @returns `Promise<boolean>`\n   */\n  verify(zkp: ZKProof, circuitId: string): Promise<boolean>;\n}\n\n/**\n *  NativeProver service responsible for zk generation and verification of groth16 algorithm with bn128 curve\n * @public\n * @class NativeProver\n * @implements implements IZKProver interface\n */\nexport class NativeProver implements IZKProver {\n  private static readonly curveName = 'bn128';\n  constructor(private readonly _circuitStorage: ICircuitStorage) {}\n\n  /**\n   * verifies zero knowledge proof\n   *\n   * @param {ZKProof} zkp - zero knowledge proof that will be verified\n   * @param {string} circuitId - circuit id for proof verification\n   * @returns `Promise<ZKProof>`\n   */\n  async verify(zkp: ZKProof, circuitId: CircuitId): Promise<boolean> {\n    try {\n      const circuitData = await this._circuitStorage.loadCircuitData(circuitId);\n\n      if (!circuitData.verificationKey) {\n        throw new Error(`verification file doesn't exist for circuit ${circuitId}`);\n      }\n\n      return verifyGroth16Proof(zkp, JSON.parse(byteDecoder.decode(circuitData.verificationKey)));\n    } catch (e) {\n      // eslint-disable-next-line no-console\n      console.log(e);\n      return false;\n    }\n  }\n\n  /**\n   * generates zero knowledge proof\n   *\n   * @param {Uint8Array} inputs - inputs that will be used for proof generation\n   * @param {string} circuitId - circuit id for proof generation\n   * @returns `Promise<ZKProof>`\n   */\n  async generate(inputs: Uint8Array, circuitId: CircuitId): Promise<ZKProof> {\n    const circuitData = await this._circuitStorage.loadCircuitData(circuitId);\n    if (!circuitData.wasm) {\n      throw new Error(`wasm file doesn't exist for circuit ${circuitId}`);\n    }\n\n    const witnessCalculator = await witnessBuilder(circuitData.wasm);\n\n    const parsedData = JSON.parse(byteDecoder.decode(inputs));\n\n    const wtnsBytes: Uint8Array = await witnessCalculator.calculateWTNSBin(parsedData, 0);\n\n    if (!circuitData.provingKey) {\n      throw new Error(`proving file doesn't exist for circuit ${circuitId}`);\n    }\n    const { proof, publicSignals } = await snarkjs.groth16.prove(circuitData.provingKey, wtnsBytes);\n\n    // we need to terminate curve manually\n    await this.terminateCurve();\n\n    return {\n      proof,\n      pub_signals: publicSignals\n    };\n  }\n\n  private async terminateCurve(): Promise<void> {\n    const curve = await ffjavascript.getCurveFromName(NativeProver.curveName);\n    curve.terminate();\n  }\n}\n","/* eslint-disable require-await */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport async function witnessBuilder(code: BufferSource, options?: any) {\n  options = options || {};\n\n  let wasmModule;\n  try {\n    wasmModule = await WebAssembly.compile(code);\n  } catch (err: any) {\n    throw new Error(err);\n  }\n\n  let errStr = '';\n  let msgStr = '';\n\n  const instance = await WebAssembly.instantiate(wasmModule, {\n    runtime: {\n      exceptionHandler: function (code: number) {\n        let err;\n        if (code == 1) {\n          err = 'Signal not found.\\n';\n        } else if (code == 2) {\n          err = 'Too many signals set.\\n';\n        } else if (code == 3) {\n          err = 'Signal already set.\\n';\n        } else if (code == 4) {\n          err = 'Assert Failed.\\n';\n        } else if (code == 5) {\n          err = 'Not enough memory.\\n';\n        } else if (code == 6) {\n          err = 'Input signal array access exceeds the size.\\n';\n        } else {\n          err = 'Unknown error.\\n';\n        }\n        throw new Error(err + errStr);\n      },\n      printErrorMessage: function () {\n        errStr += getMessage() + '\\n';\n      },\n      writeBufferMessage: function () {\n        const msg = getMessage();\n        // Any calls to `log()` will always end with a `\\n`, so that's when we print and reset\n        if (msg === '\\n') {\n          msgStr = '';\n        } else {\n          // If we've buffered other content, put a space in between the items\n          if (msgStr !== '') {\n            msgStr += ' ';\n          }\n          // Then append the message to the message we are creating\n          msgStr += msg;\n        }\n      },\n      showSharedRWMemory: function () {\n        printSharedRWMemory();\n      }\n    }\n  });\n\n  const sanityCheck = options;\n\n  const wc = new WitnessCalculator(instance, sanityCheck);\n  return wc;\n\n  function getMessage() {\n    let message = '';\n    let c = (instance as any).exports.getMessageChar();\n    while (c != 0) {\n      message += String.fromCharCode(c);\n      c = (instance as any).exports.getMessageChar();\n    }\n    return message;\n  }\n\n  function printSharedRWMemory() {\n    const shared_rw_memory_size = (instance as any).exports.getFieldNumLen32();\n    const arr = new Uint32Array(shared_rw_memory_size);\n    for (let j = 0; j < shared_rw_memory_size; j++) {\n      arr[shared_rw_memory_size - 1 - j] = (instance as any).exports.readSharedRWMemory(j);\n    }\n\n    // If we've buffered other content, put a space in between the items\n    if (msgStr !== '') {\n      msgStr += ' ';\n    }\n    // Then append the value to the message we are creating\n    msgStr += fromArray32(arr).toString();\n  }\n}\n\nclass WitnessCalculator {\n  version: any;\n  n32: any;\n  prime: any;\n  witnessSize: any;\n  sanityCheck: any;\n  constructor(private instance: any, sanityCheck: any) {\n    this.instance = instance;\n    this.version = (this.instance.exports as any).getVersion();\n    this.n32 = (this.instance.exports as any).getFieldNumLen32();\n\n    (this.instance.exports as any).getRawPrime();\n    const arr = new Uint32Array(this.n32);\n    for (let i = 0; i < this.n32; i++) {\n      arr[this.n32 - 1 - i] = (this.instance.exports as any).readSharedRWMemory(i);\n    }\n    this.prime = fromArray32(arr);\n\n    this.witnessSize = (this.instance.exports as any).getWitnessSize();\n\n    this.sanityCheck = sanityCheck;\n  }\n\n  circom_version() {\n    return (this.instance.exports as any).getVersion();\n  }\n\n  async _doCalculateWitness(input: any, sanityCheck: any) {\n    //input is assumed to be a map from signals to arrays of bigints\n    (this.instance.exports as any).init(this.sanityCheck || sanityCheck ? 1 : 0);\n    const keys = Object.keys(input);\n    let input_counter = 0;\n    keys.forEach((k) => {\n      const h = fnvHash(k);\n      const hMSB = parseInt(h.slice(0, 8), 16);\n      const hLSB = parseInt(h.slice(8, 16), 16);\n      const fArr = flatArray(input[k]);\n      const signalSize = (this.instance.exports as any).getInputSignalSize(hMSB, hLSB);\n      if (signalSize < 0) {\n        throw new Error(`Signal ${k} not found\\n`);\n      }\n      if (fArr.length < signalSize) {\n        throw new Error(`Not enough values for input signal ${k}\\n`);\n      }\n      if (fArr.length > signalSize) {\n        throw new Error(`Too many values for input signal ${k}\\n`);\n      }\n      for (let i = 0; i < fArr.length; i++) {\n        const arrFr = toArray32(BigInt(fArr[i]) % this.prime, this.n32);\n        for (let j = 0; j < this.n32; j++) {\n          (this.instance.exports as any).writeSharedRWMemory(j, arrFr[this.n32 - 1 - j]);\n        }\n        try {\n          (this.instance.exports as any).setInputSignal(hMSB, hLSB, i);\n          input_counter++;\n        } catch (err: any) {\n          // console.log(`After adding signal ${i} of ${k}`)\n          throw new Error(err);\n        }\n      }\n    });\n    if (input_counter < (this.instance.exports as any).getInputSize()) {\n      throw new Error(\n        `Not all inputs have been set. Only ${input_counter} out of ${(\n          this.instance.exports as any\n        ).getInputSize()}`\n      );\n    }\n  }\n\n  async calculateWitness(input: any, sanityCheck: any) {\n    const w = [];\n\n    await this._doCalculateWitness(input, sanityCheck);\n\n    for (let i = 0; i < this.witnessSize; i++) {\n      (this.instance.exports as any).getWitness(i);\n      const arr = new Uint32Array(this.n32);\n      for (let j = 0; j < this.n32; j++) {\n        arr[this.n32 - 1 - j] = (this.instance.exports as any).readSharedRWMemory(j);\n      }\n      w.push(fromArray32(arr));\n    }\n\n    return w;\n  }\n\n  async calculateBinWitness(input: any, sanityCheck: any) {\n    const buff32 = new Uint32Array(this.witnessSize * this.n32);\n    const buff = new Uint8Array(buff32.buffer);\n    await this._doCalculateWitness(input, sanityCheck);\n\n    for (let i = 0; i < this.witnessSize; i++) {\n      (this.instance.exports as any).getWitness(i);\n      const pos = i * this.n32;\n      for (let j = 0; j < this.n32; j++) {\n        buff32[pos + j] = (this.instance.exports as any).readSharedRWMemory(j);\n      }\n    }\n\n    return buff;\n  }\n\n  async calculateWTNSBin(input: any, sanityCheck: any) {\n    const buff32 = new Uint32Array(this.witnessSize * this.n32 + this.n32 + 11);\n    const buff = new Uint8Array(buff32.buffer);\n    await this._doCalculateWitness(input, sanityCheck);\n\n    //\"wtns\"\n    buff[0] = 'w'.charCodeAt(0);\n    buff[1] = 't'.charCodeAt(0);\n    buff[2] = 'n'.charCodeAt(0);\n    buff[3] = 's'.charCodeAt(0);\n\n    //version 2\n    buff32[1] = 2;\n\n    //number of sections: 2\n    buff32[2] = 2;\n\n    //id section 1\n    buff32[3] = 1;\n\n    const n8 = this.n32 * 4;\n    //id section 1 length in 64bytes\n    const idSection1length = 8 + n8;\n    const idSection1lengthHex = idSection1length.toString(16);\n    buff32[4] = parseInt(idSection1lengthHex.slice(0, 8), 16);\n    buff32[5] = parseInt(idSection1lengthHex.slice(8, 16), 16);\n\n    //this.n32\n    buff32[6] = n8;\n\n    //prime number\n    this.instance.exports.getRawPrime();\n\n    let pos = 7;\n    for (let j = 0; j < this.n32; j++) {\n      buff32[pos + j] = this.instance.exports.readSharedRWMemory(j);\n    }\n    pos += this.n32;\n\n    // witness size\n    buff32[pos] = this.witnessSize;\n    pos++;\n\n    //id section 2\n    buff32[pos] = 2;\n    pos++;\n\n    // section 2 length\n    const idSection2length = n8 * this.witnessSize;\n    const idSection2lengthHex = idSection2length.toString(16);\n    buff32[pos] = parseInt(idSection2lengthHex.slice(0, 8), 16);\n    buff32[pos + 1] = parseInt(idSection2lengthHex.slice(8, 16), 16);\n\n    pos += 2;\n    for (let i = 0; i < this.witnessSize; i++) {\n      this.instance.exports.getWitness(i);\n      for (let j = 0; j < this.n32; j++) {\n        buff32[pos + j] = this.instance.exports.readSharedRWMemory(j);\n      }\n      pos += this.n32;\n    }\n\n    return buff;\n  }\n}\n\nfunction toArray32(rem: bigint, size: number) {\n  const res = []; //new Uint32Array(size); //has no unshift\n  const radix = BigInt(0x100000000);\n  while (rem) {\n    res.unshift(Number(rem % radix));\n    rem = rem / radix;\n  }\n  if (size) {\n    let i = size - res.length;\n    while (i > 0) {\n      res.unshift(0);\n      i--;\n    }\n  }\n  return res;\n}\n\nfunction fromArray32(arr: Uint32Array) {\n  //returns a BigInt\n  let res = BigInt(0);\n  const radix = BigInt(0x100000000);\n  for (let i = 0; i < arr.length; i++) {\n    res = res * radix + BigInt(arr[i]);\n  }\n  return res;\n}\n\nfunction flatArray(a: any[]) {\n  const res: any[] = [];\n  fillArray(res, a);\n  return res;\n\n  function fillArray(res: any[], a: any[]) {\n    if (Array.isArray(a)) {\n      for (let i = 0; i < a.length; i++) {\n        fillArray(res, a[i]);\n      }\n    } else {\n      res.push(a);\n    }\n  }\n}\n\nfunction fnvHash(str: any) {\n  const uint64_max = BigInt(2) ** BigInt(64);\n  let hash = BigInt('0xCBF29CE484222325');\n  for (let i = 0; i < str.length; i++) {\n    hash ^= BigInt(str[i].charCodeAt());\n    hash *= BigInt(0x100000001b3);\n    hash %= uint64_max;\n  }\n  let hashHex = hash.toString(16);\n  const n = 16 - hashHex.length;\n  hashHex = '0'.repeat(n).concat(hashHex);\n  return hashHex;\n}\n","import { DID, getUnixTimestamp } from '@iden3/js-iden3-core';\nimport {\n  Iden3SparseMerkleTreeProof,\n  ProofType,\n  RevocationStatus,\n  W3CCredential\n} from '../../verifiable';\nimport { ZeroKnowledgeProofRequest } from '../../iden3comm';\nimport {\n  AtomicQueryMTPV2Inputs,\n  AtomicQueryMTPV2OnChainInputs,\n  AtomicQuerySigV2Inputs,\n  AtomicQuerySigV2OnChainInputs,\n  AtomicQueryV3Inputs,\n  AtomicQueryV3OnChainInputs,\n  CircuitClaim,\n  CircuitId,\n  LinkedMultiQueryInputs,\n  MTProof,\n  Operators,\n  Query,\n  QueryOperators,\n  TreeState,\n  ValueProof,\n  getOperatorNameByValue\n} from '../../circuits';\nimport {\n  PreparedAuthBJJCredential,\n  PreparedCredential,\n  toClaimNonRevStatus,\n  toGISTProof\n} from '../common';\nimport { IIdentityWallet } from '../../identity';\nimport { IStateStorage } from '../../storage';\nimport {\n  CredentialStatusResolveOptions,\n  ICredentialWallet,\n  getUserDIDFromCredential\n} from '../../credentials';\nimport { isEthereumIdentity } from '../../utils';\n\nexport type DIDProfileMetadata = {\n  authProfileNonce: number | string;\n  credentialSubjectProfileNonce: number | string;\n};\n\nexport type ProofGenerationOptions = {\n  skipRevocation: boolean;\n  challenge?: bigint;\n  credential?: W3CCredential;\n  credentialRevocationStatus?: RevocationStatus;\n  verifierDid?: DID;\n  linkNonce?: bigint;\n};\n\nexport type AuthProofGenerationOptions = {\n  challenge?: bigint;\n};\n\nexport type ProofInputsParams = ProofGenerationOptions & DIDProfileMetadata;\n\ntype InputContext = {\n  preparedCredential: PreparedCredential;\n  identifier: DID;\n  proofReq: ZeroKnowledgeProofRequest;\n  params: ProofInputsParams;\n  circuitQueries: Query[];\n};\n\nconst allOperations = Object.values(QueryOperators);\nconst v2Operations = [\n  Operators.NOOP,\n  Operators.EQ,\n  Operators.LT,\n  Operators.GT,\n  Operators.IN,\n  Operators.NIN,\n  Operators.NE,\n  Operators.SD\n];\nconst v2OnChainOperations = [\n  Operators.EQ,\n  Operators.LT,\n  Operators.GT,\n  Operators.IN,\n  Operators.NIN,\n  Operators.NE\n];\n\nexport const circuitValidator: {\n  [k in CircuitId]: { maxQueriesCount: number; supportedOperations: Operators[] };\n} = {\n  [CircuitId.AtomicQueryMTPV2]: { maxQueriesCount: 1, supportedOperations: v2Operations },\n  [CircuitId.AtomicQueryMTPV2OnChain]: {\n    maxQueriesCount: 1,\n    supportedOperations: v2OnChainOperations\n  },\n  [CircuitId.AtomicQuerySigV2]: { maxQueriesCount: 1, supportedOperations: v2Operations },\n  [CircuitId.AtomicQuerySigV2OnChain]: {\n    maxQueriesCount: 1,\n    supportedOperations: v2OnChainOperations\n  },\n  [CircuitId.AtomicQueryV3]: { maxQueriesCount: 1, supportedOperations: allOperations },\n  [CircuitId.AtomicQueryV3OnChain]: { maxQueriesCount: 1, supportedOperations: allOperations },\n  [CircuitId.AuthV2]: { maxQueriesCount: 0, supportedOperations: [] },\n  [CircuitId.StateTransition]: { maxQueriesCount: 0, supportedOperations: [] },\n  [CircuitId.LinkedMultiQuery10]: { maxQueriesCount: 10, supportedOperations: allOperations }\n};\n\nexport class InputGenerator {\n  constructor(\n    private readonly _identityWallet: IIdentityWallet,\n    private readonly _credentialWallet: ICredentialWallet,\n    private readonly _stateStorage: IStateStorage\n  ) {}\n\n  async generateInputs(ctx: InputContext): Promise<Uint8Array> {\n    const { circuitId } = ctx.proofReq;\n    const fnName = `${circuitId.split('-')[0]}PrepareInputs`;\n\n    const queriesLength = ctx.circuitQueries.length;\n\n    if (queriesLength > circuitValidator[circuitId as CircuitId].maxQueriesCount) {\n      throw new Error(\n        `circuit ${circuitId} supports only ${\n          circuitValidator[circuitId as CircuitId].maxQueriesCount\n        } queries`\n      );\n    }\n\n    const fn = (this as unknown as { [k: string]: (ctx: InputContext) => Promise<Uint8Array> })[\n      fnName\n    ];\n\n    if (!fn) {\n      throw new Error(`inputs generator for ${circuitId} not found`);\n    }\n\n    return fn(ctx);\n  }\n\n  async newCircuitClaimData(preparedCredential: PreparedCredential): Promise<CircuitClaim> {\n    const smtProof: Iden3SparseMerkleTreeProof | undefined =\n      preparedCredential.credential.getIden3SparseMerkleTreeProof();\n\n    const circuitClaim = new CircuitClaim();\n    circuitClaim.claim = preparedCredential.credentialCoreClaim;\n    circuitClaim.issuerId = DID.idFromDID(DID.parse(preparedCredential.credential.issuer));\n\n    if (smtProof) {\n      circuitClaim.proof = smtProof.mtp;\n      circuitClaim.treeState = {\n        state: smtProof.issuerData.state.value,\n        claimsRoot: smtProof.issuerData.state.claimsTreeRoot,\n        revocationRoot: smtProof.issuerData.state.revocationTreeRoot,\n        rootOfRoots: smtProof.issuerData.state.rootOfRoots\n      };\n    }\n\n    const sigProof = preparedCredential.credential.getBJJSignature2021Proof();\n\n    if (sigProof) {\n      const issuerDID = sigProof.issuerData.id;\n      const userDID: DID = getUserDIDFromCredential(issuerDID, preparedCredential.credential);\n\n      const { credentialStatus, mtp, authCoreClaim } = sigProof.issuerData;\n\n      if (!credentialStatus) {\n        throw new Error(\n          \"can't check the validity of issuer auth claim: no credential status in proof\"\n        );\n      }\n\n      if (!mtp) {\n        throw new Error('issuer auth credential must have a mtp proof');\n      }\n\n      if (!authCoreClaim) {\n        throw new Error('issuer auth credential must have a core claim proof');\n      }\n\n      const opts: CredentialStatusResolveOptions = {\n        issuerGenesisState: sigProof.issuerData.state,\n        issuerDID,\n        userDID\n      };\n\n      const rs = await this._credentialWallet.getRevocationStatus(credentialStatus, opts);\n\n      const issuerAuthNonRevProof: MTProof = toClaimNonRevStatus(rs);\n\n      circuitClaim.signatureProof = {\n        signature: sigProof.signature,\n        issuerAuthIncProof: {\n          proof: sigProof.issuerData.mtp,\n          treeState: {\n            state: sigProof.issuerData.state.value,\n            claimsRoot: sigProof.issuerData.state.claimsTreeRoot,\n            revocationRoot: sigProof.issuerData.state.revocationTreeRoot,\n            rootOfRoots: sigProof.issuerData.state.rootOfRoots\n          }\n        },\n        issuerAuthClaim: sigProof.issuerData.authCoreClaim,\n        issuerAuthNonRevProof\n      };\n    }\n\n    return circuitClaim;\n  }\n\n  async prepareAuthBJJCredential(\n    did: DID,\n    treeStateInfo?: TreeState\n  ): Promise<PreparedAuthBJJCredential> {\n    const { authCredential, incProof, nonRevProof } =\n      await this._identityWallet.getActualAuthCredential(did, treeStateInfo);\n\n    const authCoreClaim = authCredential.getCoreClaimFromProof(\n      ProofType.Iden3SparseMerkleTreeProof\n    );\n\n    if (!authCoreClaim) {\n      throw new Error('auth core claim is not defined for auth bjj credential');\n    }\n\n    return {\n      credential: authCredential,\n      incProof,\n      nonRevProof,\n      coreClaim: authCoreClaim\n    };\n  }\n\n  private credentialAtomicQueryMTPV2PrepareInputs = async ({\n    preparedCredential,\n    identifier,\n    proofReq,\n    params,\n    circuitQueries\n  }: InputContext): Promise<Uint8Array> => {\n    const circuitClaimData = await this.newCircuitClaimData(preparedCredential);\n    circuitClaimData.nonRevProof = toClaimNonRevStatus(preparedCredential.revStatus);\n    const circuitInputs = new AtomicQueryMTPV2Inputs();\n    circuitInputs.id = DID.idFromDID(identifier);\n    circuitInputs.requestID = BigInt(proofReq.id);\n\n    const query = circuitQueries[0];\n    query.operator = this.transformV2QueryOperator(query.operator);\n    circuitInputs.query = query;\n    circuitInputs.claim = {\n      issuerID: circuitClaimData.issuerId,\n      claim: circuitClaimData.claim,\n      incProof: { proof: circuitClaimData.proof, treeState: circuitClaimData.treeState },\n      nonRevProof: circuitClaimData.nonRevProof\n    };\n    circuitInputs.currentTimeStamp = getUnixTimestamp(new Date());\n    circuitInputs.claimSubjectProfileNonce = BigInt(params.credentialSubjectProfileNonce);\n    circuitInputs.profileNonce = BigInt(params.authProfileNonce);\n    circuitInputs.skipClaimRevocationCheck = params.skipRevocation;\n\n    this.checkOperatorSupport(proofReq.circuitId, query.operator);\n\n    return circuitInputs.inputsMarshal();\n  };\n\n  private credentialAtomicQueryMTPV2OnChainPrepareInputs = async ({\n    preparedCredential,\n    identifier,\n    proofReq,\n    params,\n    circuitQueries\n  }: InputContext): Promise<Uint8Array> => {\n    const circuitClaimData = await this.newCircuitClaimData(preparedCredential);\n\n    const authInfo = await this.prepareAuthBJJCredential(identifier);\n\n    const authClaimData = await this.newCircuitClaimData({\n      credential: authInfo.credential,\n      credentialCoreClaim: authInfo.coreClaim\n    });\n\n    circuitClaimData.nonRevProof = toClaimNonRevStatus(preparedCredential.revStatus);\n\n    const circuitInputs = new AtomicQueryMTPV2OnChainInputs();\n    const id = DID.idFromDID(identifier);\n    circuitInputs.id = DID.idFromDID(identifier);\n    circuitInputs.requestID = BigInt(proofReq.id);\n\n    const stateProof = await this._stateStorage.getGISTProof(id.bigInt());\n\n    const gistProof = toGISTProof(stateProof);\n    circuitInputs.gistProof = gistProof;\n\n    if (authClaimData?.treeState) {\n      circuitInputs.treeState = {\n        state: authClaimData?.treeState?.state,\n        claimsRoot: authClaimData?.treeState?.claimsRoot,\n        revocationRoot: authClaimData?.treeState?.revocationRoot,\n        rootOfRoots: authClaimData?.treeState?.rootOfRoots\n      };\n    }\n\n    circuitInputs.authClaim = authClaimData.claim;\n    circuitInputs.authClaimIncMtp = authClaimData.proof;\n    circuitInputs.authClaimNonRevMtp = authInfo.nonRevProof.proof;\n    if (!params.challenge) {\n      throw new Error('challenge must be provided for onchain circuits');\n    }\n    const signature = await this._identityWallet.signChallenge(\n      params.challenge,\n      authInfo.credential\n    );\n\n    circuitInputs.signature = signature;\n    circuitInputs.challenge = params.challenge;\n\n    const query = circuitQueries[0];\n    circuitInputs.query = query;\n    circuitInputs.claim = {\n      issuerID: circuitClaimData.issuerId,\n      claim: circuitClaimData.claim,\n      incProof: { proof: circuitClaimData.proof, treeState: circuitClaimData.treeState },\n      nonRevProof: circuitClaimData.nonRevProof\n    };\n    circuitInputs.currentTimeStamp = getUnixTimestamp(new Date());\n    circuitInputs.claimSubjectProfileNonce = BigInt(params.credentialSubjectProfileNonce);\n    circuitInputs.profileNonce = BigInt(params.authProfileNonce);\n    circuitInputs.skipClaimRevocationCheck = params.skipRevocation;\n\n    this.checkOperatorSupport(proofReq.circuitId, query.operator);\n\n    return circuitInputs.inputsMarshal();\n  };\n\n  private credentialAtomicQuerySigV2PrepareInputs = async ({\n    preparedCredential,\n    identifier,\n    proofReq,\n    params,\n    circuitQueries\n  }: InputContext): Promise<Uint8Array> => {\n    const circuitClaimData = await this.newCircuitClaimData(preparedCredential);\n\n    circuitClaimData.nonRevProof = toClaimNonRevStatus(preparedCredential.revStatus);\n\n    const circuitInputs = new AtomicQuerySigV2Inputs();\n    circuitInputs.id = DID.idFromDID(identifier);\n    circuitInputs.claim = {\n      issuerID: circuitClaimData?.issuerId,\n      signatureProof: circuitClaimData.signatureProof,\n      claim: circuitClaimData.claim,\n      nonRevProof: circuitClaimData.nonRevProof\n    };\n    circuitInputs.requestID = BigInt(proofReq.id);\n    circuitInputs.claimSubjectProfileNonce = BigInt(params.credentialSubjectProfileNonce);\n    circuitInputs.profileNonce = BigInt(params.authProfileNonce);\n    circuitInputs.skipClaimRevocationCheck = params.skipRevocation;\n\n    const query = circuitQueries[0];\n    query.operator = this.transformV2QueryOperator(query.operator);\n    circuitInputs.query = query;\n    circuitInputs.currentTimeStamp = getUnixTimestamp(new Date());\n\n    this.checkOperatorSupport(proofReq.circuitId, query.operator);\n\n    return circuitInputs.inputsMarshal();\n  };\n\n  private credentialAtomicQuerySigV2OnChainPrepareInputs = async ({\n    preparedCredential,\n    identifier,\n    proofReq,\n    params,\n    circuitQueries\n  }: InputContext): Promise<Uint8Array> => {\n    const circuitClaimData = await this.newCircuitClaimData(preparedCredential);\n\n    const authInfo = await this.prepareAuthBJJCredential(identifier);\n\n    const authClaimData = await this.newCircuitClaimData({\n      credential: authInfo.credential,\n      credentialCoreClaim: authInfo.coreClaim\n    });\n\n    circuitClaimData.nonRevProof = toClaimNonRevStatus(preparedCredential.revStatus);\n\n    const circuitInputs = new AtomicQuerySigV2OnChainInputs();\n    const id = DID.idFromDID(identifier);\n    circuitInputs.id = id;\n    circuitInputs.claim = {\n      issuerID: circuitClaimData.issuerId,\n      signatureProof: circuitClaimData.signatureProof,\n      claim: circuitClaimData.claim,\n      nonRevProof: circuitClaimData.nonRevProof\n    };\n    circuitInputs.requestID = BigInt(proofReq.id);\n    circuitInputs.claimSubjectProfileNonce = BigInt(params.credentialSubjectProfileNonce);\n    circuitInputs.profileNonce = BigInt(params.authProfileNonce);\n    circuitInputs.skipClaimRevocationCheck = params.skipRevocation;\n\n    const query = circuitQueries[0];\n    circuitInputs.query = query;\n    circuitInputs.currentTimeStamp = getUnixTimestamp(new Date());\n\n    if (authClaimData.treeState) {\n      circuitInputs.treeState = {\n        state: authClaimData.treeState?.state,\n        claimsRoot: authClaimData.treeState?.claimsRoot,\n        revocationRoot: authClaimData.treeState?.revocationRoot,\n        rootOfRoots: authClaimData.treeState?.rootOfRoots\n      };\n    }\n\n    const stateProof = await this._stateStorage.getGISTProof(id.bigInt());\n    const gistProof = toGISTProof(stateProof);\n    circuitInputs.gistProof = gistProof;\n\n    circuitInputs.authClaim = authClaimData.claim;\n    circuitInputs.authClaimIncMtp = authClaimData.proof;\n    circuitInputs.authClaimNonRevMtp = authInfo.nonRevProof.proof;\n\n    if (!params.challenge) {\n      throw new Error('challenge must be provided for onchain circuits');\n    }\n\n    const signature = await this._identityWallet.signChallenge(\n      params.challenge,\n      authInfo.credential\n    );\n\n    circuitInputs.signature = signature;\n    circuitInputs.challenge = params.challenge;\n\n    this.checkOperatorSupport(proofReq.circuitId, query.operator);\n\n    return circuitInputs.inputsMarshal();\n  };\n\n  private credentialAtomicQueryV3PrepareInputs = async ({\n    preparedCredential,\n    identifier,\n    proofReq,\n    params,\n    circuitQueries\n  }: InputContext): Promise<Uint8Array> => {\n    const circuitClaimData = await this.newCircuitClaimData(preparedCredential);\n\n    circuitClaimData.nonRevProof = toClaimNonRevStatus(preparedCredential.revStatus);\n    let proofType: ProofType;\n    switch (proofReq.query.proofType) {\n      case ProofType.BJJSignature:\n        proofType = ProofType.BJJSignature;\n        break;\n      case ProofType.Iden3SparseMerkleTreeProof:\n        proofType = ProofType.Iden3SparseMerkleTreeProof;\n        break;\n      default:\n        if (circuitClaimData.proof) {\n          proofType = ProofType.Iden3SparseMerkleTreeProof;\n        } else if (circuitClaimData.signatureProof) {\n          proofType = ProofType.BJJSignature;\n        } else {\n          throw Error('claim has no MTP or signature proof');\n        }\n        break;\n    }\n\n    const circuitInputs = new AtomicQueryV3Inputs();\n    circuitInputs.id = DID.idFromDID(identifier);\n    circuitInputs.claim = {\n      issuerID: circuitClaimData?.issuerId,\n      signatureProof: circuitClaimData.signatureProof,\n      claim: circuitClaimData.claim,\n      nonRevProof: circuitClaimData.nonRevProof,\n      incProof: { proof: circuitClaimData.proof, treeState: circuitClaimData.treeState }\n    };\n    circuitInputs.requestID = BigInt(proofReq.id);\n    circuitInputs.claimSubjectProfileNonce = BigInt(params.credentialSubjectProfileNonce);\n    circuitInputs.profileNonce = BigInt(params.authProfileNonce);\n    circuitInputs.skipClaimRevocationCheck = params.skipRevocation;\n\n    const query = circuitQueries[0];\n    query.values = [Operators.SD, Operators.NOOP].includes(query.operator) ? [] : query.values;\n    query.valueProof = query.operator === Operators.NOOP ? new ValueProof() : query.valueProof;\n\n    circuitInputs.query = query;\n    circuitInputs.currentTimeStamp = getUnixTimestamp(new Date());\n\n    circuitInputs.proofType = proofType;\n    circuitInputs.linkNonce = params.linkNonce ?? BigInt(0);\n    circuitInputs.verifierID = params.verifierDid ? DID.idFromDID(params.verifierDid) : undefined;\n    circuitInputs.nullifierSessionID = proofReq.params?.nullifierSessionId\n      ? BigInt(proofReq.params?.nullifierSessionId?.toString())\n      : BigInt(0);\n\n    this.checkOperatorSupport(proofReq.circuitId, query.operator);\n\n    return circuitInputs.inputsMarshal();\n  };\n\n  private credentialAtomicQueryV3OnChainPrepareInputs = async ({\n    preparedCredential,\n    identifier,\n    proofReq,\n    params,\n    circuitQueries\n  }: InputContext): Promise<Uint8Array> => {\n    const id = DID.idFromDID(identifier);\n\n    const circuitClaimData = await this.newCircuitClaimData(preparedCredential);\n\n    circuitClaimData.nonRevProof = toClaimNonRevStatus(preparedCredential.revStatus);\n    let proofType: ProofType;\n    switch (proofReq.query.proofType) {\n      case ProofType.BJJSignature:\n        proofType = ProofType.BJJSignature;\n        break;\n      case ProofType.Iden3SparseMerkleTreeProof:\n        proofType = ProofType.Iden3SparseMerkleTreeProof;\n        break;\n      default:\n        if (circuitClaimData.proof) {\n          proofType = ProofType.Iden3SparseMerkleTreeProof;\n        } else if (circuitClaimData.signatureProof) {\n          proofType = ProofType.BJJSignature;\n        } else {\n          throw Error('claim has no MTP or signature proof');\n        }\n        break;\n    }\n\n    const circuitInputs = new AtomicQueryV3OnChainInputs();\n    circuitInputs.id = DID.idFromDID(identifier);\n    circuitInputs.claim = {\n      issuerID: circuitClaimData?.issuerId,\n      signatureProof: circuitClaimData.signatureProof,\n      claim: circuitClaimData.claim,\n      nonRevProof: circuitClaimData.nonRevProof,\n      incProof: { proof: circuitClaimData.proof, treeState: circuitClaimData.treeState }\n    };\n    circuitInputs.requestID = BigInt(proofReq.id);\n    circuitInputs.claimSubjectProfileNonce = BigInt(params.credentialSubjectProfileNonce);\n    circuitInputs.profileNonce = BigInt(params.authProfileNonce);\n    circuitInputs.skipClaimRevocationCheck = params.skipRevocation;\n\n    const query = circuitQueries[0];\n    query.values = [Operators.SD, Operators.NOOP].includes(query.operator) ? [] : query.values;\n    query.valueProof = query.operator === Operators.NOOP ? new ValueProof() : query.valueProof;\n\n    circuitInputs.query = query;\n    circuitInputs.currentTimeStamp = getUnixTimestamp(new Date());\n\n    circuitInputs.proofType = proofType;\n    circuitInputs.linkNonce = params.linkNonce ?? BigInt(0);\n    circuitInputs.verifierID = params.verifierDid ? DID.idFromDID(params.verifierDid) : undefined;\n    circuitInputs.nullifierSessionID = proofReq.params?.nullifierSessionId\n      ? BigInt(proofReq.params?.nullifierSessionId?.toString())\n      : BigInt(0);\n\n    const isEthIdentity = isEthereumIdentity(identifier);\n    circuitInputs.isBJJAuthEnabled = isEthIdentity ? 0 : 1;\n\n    circuitInputs.challenge = BigInt(params.challenge ?? 0);\n    const stateProof = await this._stateStorage.getGISTProof(id.bigInt());\n    const gistProof = toGISTProof(stateProof);\n    circuitInputs.gistProof = gistProof;\n    // auth inputs\n    if (circuitInputs.isBJJAuthEnabled === 1) {\n      const authPrepared = await this.prepareAuthBJJCredential(identifier);\n\n      const authClaimData = await this.newCircuitClaimData({\n        credential: authPrepared.credential,\n        credentialCoreClaim: authPrepared.coreClaim\n      });\n\n      const signature = await this._identityWallet.signChallenge(\n        circuitInputs.challenge,\n        authPrepared.credential\n      );\n\n      circuitInputs.authClaim = authClaimData.claim;\n      circuitInputs.authClaimIncMtp = authClaimData.proof;\n      circuitInputs.authClaimNonRevMtp = authPrepared.nonRevProof.proof;\n      circuitInputs.treeState = authClaimData.treeState;\n      circuitInputs.signature = signature;\n    }\n\n    this.checkOperatorSupport(proofReq.circuitId, query.operator);\n\n    return circuitInputs.inputsMarshal();\n  };\n\n  private linkedMultiQuery10PrepareInputs = async ({\n    preparedCredential,\n    params,\n    proofReq,\n    circuitQueries\n  }: InputContext): Promise<Uint8Array> => {\n    const circuitClaimData = await this.newCircuitClaimData(preparedCredential);\n\n    circuitClaimData.nonRevProof = toClaimNonRevStatus(preparedCredential.revStatus);\n    const circuitInputs = new LinkedMultiQueryInputs();\n    circuitInputs.linkNonce = params.linkNonce ?? BigInt(0);\n\n    circuitInputs.claim = circuitClaimData.claim;\n    circuitInputs.query = circuitQueries;\n\n    circuitQueries.forEach((query) => {\n      this.checkOperatorSupport(proofReq.circuitId, query.operator);\n    });\n    circuitQueries.forEach((query) => {\n      query.values = [Operators.SD, Operators.NOOP].includes(query.operator) ? [] : query.values;\n      query.valueProof = query.operator === Operators.NOOP ? new ValueProof() : query.valueProof;\n    });\n    return circuitInputs.inputsMarshal();\n  };\n\n  private transformV2QueryOperator(operator: number): number {\n    return operator === Operators.SD || operator === Operators.NOOP ? Operators.EQ : operator;\n  }\n  private checkOperatorSupport(circuitId: string, operator: number) {\n    const supportedOperators = circuitValidator[circuitId as CircuitId].supportedOperations;\n    if (!supportedOperators.includes(operator)) {\n      throw new Error(\n        `operator ${getOperatorNameByValue(operator)} is not supported by ${circuitId}`\n      );\n    }\n  }\n}\n","import { DID, getDateFromUnixTimestamp, Id } from '@iden3/js-iden3-core';\nimport { DocumentLoader, getDocumentLoader, Path } from '@iden3/js-jsonld-merklization';\nimport { Hash } from '@iden3/js-merkletree';\nimport { IStateStorage, RootInfo, StateInfo } from '../../storage';\nimport { byteEncoder, isGenesisState } from '../../utils';\nimport { calculateCoreSchemaHash, ProofQuery, ProofType } from '../../verifiable';\nimport { AtomicQueryMTPV2PubSignals } from '../../circuits/atomic-query-mtp-v2';\nimport { AtomicQuerySigV2PubSignals } from '../../circuits/atomic-query-sig-v2';\nimport { AtomicQueryV3PubSignals } from '../../circuits/atomic-query-v3';\nimport { AuthV2PubSignals } from '../../circuits/auth-v2';\nimport { BaseConfig } from '../../circuits/common';\nimport {\n  LinkedMultiQueryPubSignals,\n  LinkedMultiQueryInputs\n} from '../../circuits/linked-multi-query';\nimport { CircuitId } from '../../circuits/models';\nimport {\n  checkQueryRequest,\n  ClaimOutputs,\n  VerifyOpts,\n  fieldValueFromVerifiablePresentation,\n  validateDisclosureV2Circuit,\n  validateEmptyCredentialSubjectV2Circuit,\n  validateOperators,\n  verifyFieldValueInclusionV2,\n  validateDisclosureNativeSDSupport,\n  validateEmptyCredentialSubjectNoopNativeSupport,\n  verifyFieldValueInclusionNativeExistsSupport,\n  checkCircuitOperator\n} from './query';\nimport { parseQueriesMetadata, QueryMetadata } from '../common';\nimport { Operators } from '../../circuits';\nimport { calculateQueryHashV3 } from './query-hash';\nimport { JsonLd } from 'jsonld/jsonld-spec';\nimport {\n  PROTOCOL_CONSTANTS,\n  JSONObject,\n  VerifiablePresentation,\n  JsonDocumentObject\n} from '../../iden3comm';\n\n/**\n *  Verify Context - params for pub signal verification\n * @type VerifyContext\n */\nexport type VerifyContext = {\n  pubSignals: string[];\n  query: ProofQuery;\n  verifiablePresentation?: VerifiablePresentation;\n  sender: string;\n  challenge: bigint;\n  opts?: VerifyOpts;\n  params?: JSONObject;\n};\n\nexport const userStateError = new Error(`user state is not valid`);\nconst zeroInt = 0n;\n\n/**\n * PubSignalsVerifier provides verify method\n * @public\n * @class PubSignalsVerifier\n */\nexport class PubSignalsVerifier {\n  userId!: Id;\n  challenge!: bigint;\n\n  /**\n   * Creates an instance of PubSignalsVerifier.\n   * @param {DocumentLoader} _documentLoader document loader\n   * @param {IStateStorage} _stateStorage state storage\n   */\n\n  constructor(\n    private readonly _documentLoader: DocumentLoader,\n    private readonly _stateStorage: IStateStorage\n  ) {}\n\n  /**\n   * verify public signals\n   *\n   * @param {string} circuitId circuit id\n   * @param {VerifyContext} ctx verification parameters\n   * @returns `Promise<BaseConfig>`\n   */\n  async verify(circuitId: string, ctx: VerifyContext): Promise<BaseConfig> {\n    const fnName = `${circuitId.split('-')[0]}Verify`;\n    const fn = (this as unknown as { [k: string]: (ctx: VerifyContext) => Promise<BaseConfig> })[\n      fnName\n    ];\n    if (!fn) {\n      throw new Error(`public signals verifier for ${circuitId} not found`);\n    }\n    return fn(ctx);\n  }\n\n  private credentialAtomicQueryMTPV2Verify = async ({\n    query,\n    verifiablePresentation,\n    sender,\n    challenge,\n    pubSignals,\n    opts\n  }: VerifyContext): Promise<BaseConfig> => {\n    let mtpv2PubSignals = new AtomicQueryMTPV2PubSignals();\n    mtpv2PubSignals = mtpv2PubSignals.pubSignalsUnmarshal(\n      byteEncoder.encode(JSON.stringify(pubSignals))\n    );\n\n    if (!mtpv2PubSignals.userID) {\n      throw new Error('user id is not presented in proof public signals');\n    }\n\n    if (!mtpv2PubSignals.requestID) {\n      throw new Error('requestId is not presented in proof public signals');\n    }\n\n    this.userId = mtpv2PubSignals.userID;\n    this.challenge = mtpv2PubSignals.requestID;\n\n    // verify query\n    const outs: ClaimOutputs = {\n      issuerId: mtpv2PubSignals.issuerID,\n      schemaHash: mtpv2PubSignals.claimSchema,\n      slotIndex: mtpv2PubSignals.slotIndex,\n      operator: mtpv2PubSignals.operator,\n      value: mtpv2PubSignals.value,\n      timestamp: mtpv2PubSignals.timestamp,\n      merklized: mtpv2PubSignals.merklized,\n      claimPathKey: mtpv2PubSignals.claimPathKey,\n      claimPathNotExists: mtpv2PubSignals.claimPathNotExists,\n      valueArraySize: mtpv2PubSignals.getValueArrSize(),\n      isRevocationChecked: mtpv2PubSignals.isRevocationChecked\n    };\n\n    await this.checkQueryV2Circuits(\n      CircuitId.AtomicQueryMTPV2,\n      query,\n      outs,\n      opts,\n      verifiablePresentation\n    );\n\n    // verify state\n    await this.checkStateExistenceForId(\n      mtpv2PubSignals.issuerID,\n      mtpv2PubSignals.issuerClaimIdenState\n    );\n\n    if (mtpv2PubSignals.isRevocationChecked !== 0) {\n      await this.checkRevocationState(\n        mtpv2PubSignals.issuerID,\n        mtpv2PubSignals.issuerClaimNonRevState,\n        opts\n      );\n    }\n\n    // verify ID ownership\n    this.verifyIdOwnership(sender, challenge);\n    return mtpv2PubSignals;\n  };\n\n  private credentialAtomicQuerySigV2Verify = async ({\n    query,\n    verifiablePresentation,\n    sender,\n    challenge,\n    pubSignals,\n    opts\n  }: VerifyContext): Promise<BaseConfig> => {\n    let sigV2PubSignals = new AtomicQuerySigV2PubSignals();\n    sigV2PubSignals = sigV2PubSignals.pubSignalsUnmarshal(\n      byteEncoder.encode(JSON.stringify(pubSignals))\n    );\n\n    this.userId = sigV2PubSignals.userID;\n    this.challenge = sigV2PubSignals.requestID;\n\n    // verify query\n    const outs: ClaimOutputs = {\n      issuerId: sigV2PubSignals.issuerID,\n      schemaHash: sigV2PubSignals.claimSchema,\n      slotIndex: sigV2PubSignals.slotIndex,\n      operator: sigV2PubSignals.operator,\n      value: sigV2PubSignals.value,\n      timestamp: sigV2PubSignals.timestamp,\n      merklized: sigV2PubSignals.merklized,\n      claimPathKey: sigV2PubSignals.claimPathKey,\n      claimPathNotExists: sigV2PubSignals.claimPathNotExists,\n      valueArraySize: sigV2PubSignals.getValueArrSize(),\n      isRevocationChecked: sigV2PubSignals.isRevocationChecked\n    };\n\n    await this.checkQueryV2Circuits(\n      CircuitId.AtomicQuerySigV2,\n      query,\n      outs,\n      opts,\n      verifiablePresentation\n    );\n\n    // verify state\n    await this.checkStateExistenceForId(sigV2PubSignals.issuerID, sigV2PubSignals.issuerAuthState);\n\n    if (sigV2PubSignals.isRevocationChecked !== 0) {\n      await this.checkRevocationState(\n        sigV2PubSignals.issuerID,\n        sigV2PubSignals.issuerClaimNonRevState,\n        opts\n      );\n    }\n    // verify Id ownership\n    this.verifyIdOwnership(sender, challenge);\n\n    return sigV2PubSignals;\n  };\n\n  private credentialAtomicQueryV3Verify = async ({\n    query,\n    verifiablePresentation,\n    sender,\n    challenge,\n    pubSignals,\n    opts,\n    params\n  }: VerifyContext): Promise<BaseConfig> => {\n    let v3PubSignals = new AtomicQueryV3PubSignals();\n    v3PubSignals = v3PubSignals.pubSignalsUnmarshal(byteEncoder.encode(JSON.stringify(pubSignals)));\n\n    this.userId = v3PubSignals.userID;\n    this.challenge = v3PubSignals.requestID;\n\n    // verify query\n    const outs: ClaimOutputs = {\n      issuerId: v3PubSignals.issuerID,\n      schemaHash: v3PubSignals.claimSchema,\n      slotIndex: v3PubSignals.slotIndex,\n      operator: v3PubSignals.operator,\n      value: v3PubSignals.value,\n      timestamp: v3PubSignals.timestamp,\n      merklized: v3PubSignals.merklized,\n      claimPathKey: v3PubSignals.claimPathKey,\n      valueArraySize: v3PubSignals.getValueArrSize(),\n      operatorOutput: v3PubSignals.operatorOutput,\n      isRevocationChecked: v3PubSignals.isRevocationChecked\n    };\n\n    if (!query.type) {\n      throw new Error(`proof query type is undefined`);\n    }\n\n    const loader = this._documentLoader ?? getDocumentLoader();\n\n    // validate schema\n    let context: JsonLd;\n    try {\n      context = (await loader(query.context ?? '')).document;\n    } catch (e) {\n      throw new Error(`can't load schema for request query`);\n    }\n\n    const queriesMetadata = await parseQueriesMetadata(\n      query.type,\n      JSON.stringify(context),\n      query.credentialSubject as JsonDocumentObject,\n      {\n        documentLoader: loader\n      }\n    );\n\n    const circuitId = CircuitId.AtomicQueryV3;\n    await checkQueryRequest(\n      query,\n      queriesMetadata,\n      context,\n      outs,\n      circuitId,\n      this._documentLoader,\n      opts\n    );\n\n    const queryMetadata = queriesMetadata[0]; // only one query is supported\n\n    checkCircuitOperator(circuitId, outs.operator);\n    // validate selective disclosure\n    if (queryMetadata.operator === Operators.SD) {\n      try {\n        await validateDisclosureNativeSDSupport(\n          queryMetadata,\n          outs,\n          verifiablePresentation,\n          loader\n        );\n      } catch (e) {\n        throw new Error(`failed to validate selective disclosure: ${(e as Error).message}`);\n      }\n    } else if (!queryMetadata.fieldName && queryMetadata.operator == Operators.NOOP) {\n      try {\n        await validateEmptyCredentialSubjectNoopNativeSupport(outs);\n      } catch (e: unknown) {\n        throw new Error(`failed to validate operators: ${(e as Error).message}`);\n      }\n    } else {\n      try {\n        await validateOperators(queryMetadata, outs);\n      } catch (e) {\n        throw new Error(`failed to validate operators: ${(e as Error).message}`);\n      }\n    }\n\n    // verify field inclusion / non-inclusion\n\n    verifyFieldValueInclusionNativeExistsSupport(outs, queryMetadata);\n\n    const { proofType, verifierID, nullifier, nullifierSessionID, linkID } = v3PubSignals;\n\n    switch (query.proofType) {\n      case ProofType.BJJSignature:\n        if (proofType !== 1) {\n          throw new Error('wrong proof type for BJJSignature');\n        }\n        break;\n      case ProofType.Iden3SparseMerkleTreeProof:\n        if (proofType !== 2) {\n          throw new Error('wrong proof type for Iden3SparseMerkleTreeProof');\n        }\n        break;\n      default:\n        throw new Error('invalid proof type');\n    }\n\n    const nSessionId = BigInt((params?.nullifierSessionId as string) ?? 0);\n\n    if (nSessionId !== 0n) {\n      if (BigInt(nullifier ?? 0) === 0n) {\n        throw new Error('nullifier should be provided for nullification and should not be 0');\n      }\n      // verify nullifier information\n      const verifierDIDParam = params?.verifierDid;\n      if (!verifierDIDParam) {\n        throw new Error('verifierDid is required');\n      }\n\n      const id = DID.idFromDID(verifierDIDParam as DID);\n\n      if (verifierID.bigInt() != id.bigInt()) {\n        throw new Error('wrong verifier is used for nullification');\n      }\n\n      if (nullifierSessionID !== nSessionId) {\n        throw new Error(\n          `wrong verifier session id is used for nullification, expected ${nSessionId}, got ${nullifierSessionID}`\n        );\n      }\n    } else if (nullifierSessionID !== 0n) {\n      throw new Error(`Nullifier id is generated but wasn't requested`);\n    }\n\n    if (!query.groupId && linkID !== 0n) {\n      throw new Error(`proof contains link id, but group id is not provided`);\n    }\n\n    if (query.groupId && linkID === 0n) {\n      throw new Error(\"proof doesn't contain link id, but group id is provided\");\n    }\n\n    // verify state\n    await this.checkStateExistenceForId(v3PubSignals.issuerID, v3PubSignals.issuerState);\n\n    if (v3PubSignals.isRevocationChecked !== 0) {\n      await this.checkRevocationState(\n        v3PubSignals.issuerID,\n        v3PubSignals.issuerClaimNonRevState,\n        opts\n      );\n    }\n\n    this.verifyIdOwnership(sender, challenge);\n\n    return v3PubSignals;\n  };\n\n  private authV2Verify = async ({\n    sender,\n    challenge,\n    pubSignals,\n    opts\n  }: VerifyContext): Promise<BaseConfig> => {\n    let authV2PubSignals = new AuthV2PubSignals();\n    authV2PubSignals = authV2PubSignals.pubSignalsUnmarshal(\n      byteEncoder.encode(JSON.stringify(pubSignals))\n    );\n\n    this.userId = authV2PubSignals.userID;\n    this.challenge = authV2PubSignals.challenge;\n\n    // no query verification\n    // verify state\n    const gist = await this.checkGlobalState(authV2PubSignals.GISTRoot, this.userId);\n\n    let acceptedStateTransitionDelay = PROTOCOL_CONSTANTS.DEFAULT_AUTH_VERIFY_DELAY;\n    if (opts?.acceptedStateTransitionDelay) {\n      acceptedStateTransitionDelay = opts.acceptedStateTransitionDelay;\n    }\n\n    if (!gist.latest) {\n      const timeDiff =\n        Date.now() - getDateFromUnixTimestamp(Number(gist.transitionTimestamp)).getTime();\n      if (timeDiff > acceptedStateTransitionDelay) {\n        throw new Error('global state is outdated');\n      }\n    }\n\n    // verify Id ownership\n    this.verifyIdOwnership(sender, challenge);\n    return new BaseConfig();\n  };\n\n  private linkedMultiQuery10Verify = async ({\n    query,\n    verifiablePresentation,\n    pubSignals\n  }: VerifyContext): Promise<BaseConfig> => {\n    let multiQueryPubSignals = new LinkedMultiQueryPubSignals();\n\n    multiQueryPubSignals = multiQueryPubSignals.pubSignalsUnmarshal(\n      byteEncoder.encode(JSON.stringify(pubSignals))\n    );\n\n    // verify query\n    let schema: JsonDocumentObject;\n    const ldOpts = { documentLoader: this._documentLoader };\n    try {\n      schema = (await ldOpts.documentLoader(query.context || '')).document as JsonDocumentObject;\n    } catch (e) {\n      throw new Error(`can't load schema for request query`);\n    }\n    const ldContextJSON = JSON.stringify(schema);\n    const credentialSubject = query.credentialSubject as JsonDocumentObject;\n    const schemaId: string = await Path.getTypeIDFromContext(\n      ldContextJSON,\n      query.type || '',\n      ldOpts\n    );\n    const schemaHash = calculateCoreSchemaHash(byteEncoder.encode(schemaId));\n\n    const queriesMetadata = await parseQueriesMetadata(\n      query.type || '',\n      ldContextJSON,\n      credentialSubject,\n      ldOpts\n    );\n\n    const request: { queryHash: bigint; queryMeta: QueryMetadata }[] = [];\n    const merklized = queriesMetadata[0]?.merklizedSchema ? 1 : 0;\n    for (let i = 0; i < LinkedMultiQueryInputs.queryCount; i++) {\n      const queryMeta = queriesMetadata[i];\n      const values = queryMeta?.values ?? [];\n      const valArrSize = values.length;\n\n      const queryHash = calculateQueryHashV3(\n        values,\n        schemaHash,\n        queryMeta?.slotIndex ?? 0,\n        queryMeta?.operator ?? 0,\n        queryMeta?.claimPathKey.toString() ?? 0,\n        valArrSize,\n        merklized,\n        0,\n        0,\n        0\n      );\n      request.push({ queryHash, queryMeta });\n    }\n\n    const queryHashCompare = (a: { queryHash: bigint }, b: { queryHash: bigint }): number => {\n      if (a.queryHash < b.queryHash) return -1;\n      if (a.queryHash > b.queryHash) return 1;\n      return 0;\n    };\n\n    const pubSignalsMeta = multiQueryPubSignals.circuitQueryHash.map((queryHash, index) => ({\n      queryHash,\n      operatorOutput: multiQueryPubSignals.operatorOutput[index]\n    }));\n\n    pubSignalsMeta.sort(queryHashCompare);\n    request.sort(queryHashCompare);\n\n    for (let i = 0; i < LinkedMultiQueryInputs.queryCount; i++) {\n      if (request[i].queryHash != pubSignalsMeta[i].queryHash) {\n        throw new Error('query hashes do not match');\n      }\n\n      if (request[i].queryMeta?.operator === Operators.SD) {\n        const disclosedValue = await fieldValueFromVerifiablePresentation(\n          request[i].queryMeta.fieldName,\n          verifiablePresentation,\n          this._documentLoader\n        );\n        if (disclosedValue != pubSignalsMeta[i].operatorOutput) {\n          throw new Error('disclosed value is not in the proof outputs');\n        }\n      }\n    }\n\n    return multiQueryPubSignals as unknown as BaseConfig;\n  };\n\n  private verifyIdOwnership = (sender: string, challenge: bigint): void => {\n    const senderId = DID.idFromDID(DID.parse(sender));\n    if (senderId.string() !== this.userId.string()) {\n      throw new Error(\n        `sender id is not used for proof creation, expected ${sender}, user from public signals: ${this.userId.string()}`\n      );\n    }\n    if (challenge !== this.challenge) {\n      throw new Error(\n        `challenge is not used for proof creation, expected ${challenge}, challenge from public signals: ${this.challenge}  `\n      );\n    }\n  };\n\n  private async checkQueryV2Circuits(\n    circuitId: CircuitId.AtomicQueryMTPV2 | CircuitId.AtomicQuerySigV2,\n    query: ProofQuery,\n    outs: ClaimOutputs,\n    opts: VerifyOpts | undefined,\n    verifiablePresentation: VerifiablePresentation | undefined\n  ) {\n    if (!query.type) {\n      throw new Error(`proof query type is undefined`);\n    }\n\n    const loader = this._documentLoader ?? getDocumentLoader();\n\n    // validate schema\n    let context: JsonLd;\n    try {\n      context = (await loader(query.context ?? '')).document;\n    } catch (e) {\n      throw new Error(`can't load schema for request query`);\n    }\n\n    const queriesMetadata = await parseQueriesMetadata(\n      query.type,\n      JSON.stringify(context),\n      query.credentialSubject as JsonDocumentObject,\n      {\n        documentLoader: loader\n      }\n    );\n\n    await checkQueryRequest(\n      query,\n      queriesMetadata,\n      context,\n      outs,\n      circuitId,\n      this._documentLoader,\n      opts\n    );\n\n    const queryMetadata = queriesMetadata[0]; // only one query is supported\n\n    checkCircuitOperator(circuitId, outs.operator);\n\n    // validate selective disclosure\n    if (queryMetadata.operator === Operators.SD) {\n      try {\n        await validateDisclosureV2Circuit(queryMetadata, outs, verifiablePresentation, loader);\n      } catch (e) {\n        throw new Error(`failed to validate selective disclosure: ${(e as Error).message}`);\n      }\n    } else if (!queryMetadata.fieldName && queryMetadata.operator == Operators.NOOP) {\n      try {\n        await validateEmptyCredentialSubjectV2Circuit(queryMetadata, outs);\n      } catch (e: unknown) {\n        throw new Error(`failed to validate operators: ${(e as Error).message}`);\n      }\n    } else {\n      try {\n        await validateOperators(queryMetadata, outs);\n      } catch (e) {\n        throw new Error(`failed to validate operators: ${(e as Error).message}`);\n      }\n    }\n\n    // verify field inclusion\n    verifyFieldValueInclusionV2(outs, queryMetadata);\n  }\n\n  private async resolve(\n    id: Id,\n    state: bigint\n  ): Promise<{\n    latest: boolean;\n    transitionTimestamp: number | string;\n  }> {\n    const idBigInt = id.bigInt();\n    const did = DID.parseFromId(id);\n    // check if id is genesis\n    const isGenesis = isGenesisState(did, state);\n    let contractState: StateInfo;\n    try {\n      contractState = await this._stateStorage.getStateInfoByIdAndState(idBigInt, state);\n    } catch (e) {\n      const stateNotExistErr = ((e as unknown as { errorArgs: string[] })?.errorArgs ?? [])[0];\n      const errMsg = stateNotExistErr || (e as unknown as Error).message;\n      if (errMsg.includes('State does not exist')) {\n        if (isGenesis) {\n          return {\n            latest: true,\n            transitionTimestamp: 0\n          };\n        }\n        throw new Error('State is not genesis and not registered in the smart contract');\n      }\n      throw e;\n    }\n\n    if (!contractState.id || contractState.id.toString() !== idBigInt.toString()) {\n      throw new Error(`state was recorded for another identity`);\n    }\n\n    if (!contractState.state || contractState.state.toString() !== state.toString()) {\n      if (\n        !contractState.replacedAtTimestamp ||\n        contractState.replacedAtTimestamp.toString() === zeroInt.toString()\n      ) {\n        throw new Error(`no information about state transition`);\n      }\n      return {\n        latest: false,\n        transitionTimestamp: contractState.replacedAtTimestamp.toString()\n      };\n    }\n\n    return {\n      latest:\n        !contractState.replacedAtTimestamp ||\n        contractState.replacedAtTimestamp.toString() === zeroInt.toString(),\n      transitionTimestamp: contractState.replacedAtTimestamp?.toString() ?? 0\n    };\n  }\n\n  private async rootResolve(\n    state: bigint,\n    id: bigint\n  ): Promise<{\n    latest: boolean;\n    transitionTimestamp: number | string;\n  }> {\n    let globalStateInfo: RootInfo;\n    try {\n      globalStateInfo = await this._stateStorage.getGISTRootInfo(state, id);\n    } catch (e: unknown) {\n      if ((e as { errorArgs: string[] }).errorArgs[0] === 'Root does not exist') {\n        throw new Error('GIST root does not exist in the smart contract');\n      }\n      throw e;\n    }\n\n    if (globalStateInfo.root.toString() !== state.toString()) {\n      throw new Error(`gist info contains invalid state`);\n    }\n\n    if (globalStateInfo.replacedByRoot.toString() !== zeroInt.toString()) {\n      if (globalStateInfo.replacedAtTimestamp.toString() === zeroInt.toString()) {\n        throw new Error(`state was replaced, but replaced time unknown`);\n      }\n      return {\n        latest: false,\n        transitionTimestamp: globalStateInfo.replacedAtTimestamp.toString()\n      };\n    }\n\n    return {\n      latest: true,\n      transitionTimestamp: 0\n    };\n  }\n\n  private checkStateExistenceForId = async (userId: Id, userState: Hash): Promise<void> => {\n    await this.resolve(userId, userState.bigInt());\n  };\n\n  private checkGlobalState = async (\n    state: Hash,\n    id: Id\n  ): Promise<{\n    latest: boolean;\n    transitionTimestamp: number | string;\n  }> => {\n    return this.rootResolve(state.bigInt(), id.bigInt());\n  };\n\n  private checkRevocationStateForId = async (\n    issuerId: Id,\n    issuerClaimNonRevState: Hash\n  ): Promise<{\n    latest: boolean;\n    transitionTimestamp: number | string;\n  }> => {\n    const issuerNonRevStateResolved = await this.resolve(issuerId, issuerClaimNonRevState.bigInt());\n    return issuerNonRevStateResolved;\n  };\n\n  private checkRevocationState = async (\n    issuerID: Id,\n    issuerClaimNonRevState: Hash,\n    opts: VerifyOpts | undefined\n  ) => {\n    const issuerNonRevStateResolved = await this.checkRevocationStateForId(\n      issuerID,\n      issuerClaimNonRevState\n    );\n\n    const acceptedStateTransitionDelay =\n      opts?.acceptedStateTransitionDelay ?? PROTOCOL_CONSTANTS.DEFAULT_PROOF_VERIFY_DELAY;\n\n    if (!issuerNonRevStateResolved.latest) {\n      const timeDiff =\n        Date.now() -\n        getDateFromUnixTimestamp(Number(issuerNonRevStateResolved.transitionTimestamp)).getTime();\n      if (timeDiff > acceptedStateTransitionDelay) {\n        throw new Error('issuer state is outdated');\n      }\n    }\n  };\n}\n","import { DID, getDateFromUnixTimestamp, Id, SchemaHash } from '@iden3/js-iden3-core';\nimport { DocumentLoader, Merklizer, MtValue, Path } from '@iden3/js-jsonld-merklization';\nimport { Proof } from '@iden3/js-merkletree';\nimport { byteEncoder } from '../../utils';\nimport { getOperatorNameByValue, Operators, QueryOperators } from '../../circuits/comparer';\nimport { CircuitId } from '../../circuits/models';\nimport { calculateCoreSchemaHash, ProofQuery, VerifiableConstants } from '../../verifiable';\nimport { QueryMetadata } from '../common';\nimport { circuitValidator } from '../provers';\nimport { JsonLd } from 'jsonld/jsonld-spec';\nimport { VerifiablePresentation } from '../../iden3comm';\nimport { ethers } from 'ethers';\n\n/**\n * Options to verify state\n */\nexport type VerifyOpts = {\n  // acceptedStateTransitionDelay is the period of time in milliseconds that a revoked state remains valid.\n  acceptedStateTransitionDelay?: number;\n  // acceptedProofGenerationDelay is the period of time in milliseconds that a generated proof remains valid.\n  acceptedProofGenerationDelay?: number;\n};\n\nconst defaultProofGenerationDelayOpts = 24 * 60 * 60 * 1000; // 24 hours\n\n// ClaimOutputs fields that are used in proof generation\nexport interface ClaimOutputs {\n  issuerId: Id;\n  schemaHash: SchemaHash;\n  slotIndex?: number;\n  operator: number;\n  operatorOutput?: bigint;\n  value: bigint[];\n  timestamp: number;\n  merklized: number;\n  claimPathKey?: bigint;\n  claimPathNotExists?: number;\n  valueArraySize: number;\n  isRevocationChecked: number;\n}\n\nexport async function checkQueryRequest(\n  query: ProofQuery,\n  queriesMetadata: QueryMetadata[],\n  ldContext: JsonLd,\n  outputs: ClaimOutputs,\n  circuitId: CircuitId,\n  schemaLoader?: DocumentLoader,\n  opts?: VerifyOpts\n): Promise<void> {\n  // validate issuer\n  const userDID = DID.parseFromId(outputs.issuerId);\n  const issuerAllowed =\n    !query.allowedIssuers ||\n    query.allowedIssuers?.some((issuer) => issuer === '*' || issuer === userDID.string());\n  if (!issuerAllowed) {\n    throw new Error('issuer is not in allowed list');\n  }\n  if (!query.type) {\n    throw new Error('query type is missing');\n  }\n\n  const schemaId: string = await Path.getTypeIDFromContext(JSON.stringify(ldContext), query.type, {\n    documentLoader: schemaLoader\n  });\n  const schemaHash = calculateCoreSchemaHash(byteEncoder.encode(schemaId));\n\n  if (schemaHash.bigInt() !== outputs.schemaHash.bigInt()) {\n    throw new Error(`schema that was used is not equal to requested in query`);\n  }\n\n  if (!query.skipClaimRevocationCheck && outputs.isRevocationChecked === 0) {\n    throw new Error(`check revocation is required`);\n  }\n\n  checkCircuitQueriesLength(circuitId, queriesMetadata);\n\n  // verify timestamp\n  let acceptedProofGenerationDelay = defaultProofGenerationDelayOpts;\n  if (opts?.acceptedProofGenerationDelay) {\n    acceptedProofGenerationDelay = opts.acceptedProofGenerationDelay;\n  }\n\n  const timeDiff = Date.now() - getDateFromUnixTimestamp(Number(outputs.timestamp)).getTime();\n  if (timeDiff > acceptedProofGenerationDelay) {\n    throw new Error('generated proof is outdated');\n  }\n\n  return;\n}\n\nexport function checkCircuitQueriesLength(circuitId: CircuitId, queriesMetadata: QueryMetadata[]) {\n  const circuitValidationData = circuitValidator[circuitId];\n\n  if (queriesMetadata.length > circuitValidationData.maxQueriesCount) {\n    throw new Error(\n      `circuit ${circuitId} supports only ${\n        circuitValidator[circuitId as CircuitId].maxQueriesCount\n      } queries`\n    );\n  }\n}\n\nexport function checkCircuitOperator(circuitId: CircuitId, operator: number) {\n  const circuitValidationData = circuitValidator[circuitId];\n\n  if (!circuitValidationData.supportedOperations.includes(operator)) {\n    throw new Error(\n      `circuit ${circuitId} not support ${getOperatorNameByValue(operator)} operator`\n    );\n  }\n}\n\nexport function verifyFieldValueInclusionV2(outputs: ClaimOutputs, metadata: QueryMetadata) {\n  if (outputs.operator == QueryOperators.$noop) {\n    return;\n  }\n  if (outputs.merklized === 1) {\n    if (outputs.claimPathNotExists === 1) {\n      throw new Error(`proof doesn't contains target query key`);\n    }\n\n    if (outputs.claimPathKey !== metadata.claimPathKey) {\n      throw new Error(`proof was generated for another path`);\n    }\n  } else {\n    if (outputs.slotIndex !== metadata.slotIndex) {\n      throw new Error(`wrong claim slot was used in claim`);\n    }\n  }\n}\nexport function verifyFieldValueInclusionNativeExistsSupport(\n  outputs: ClaimOutputs,\n  metadata: QueryMetadata\n) {\n  if (outputs.operator == Operators.NOOP) {\n    return;\n  }\n  if (outputs.operator === Operators.EXISTS && !outputs.merklized) {\n    throw new Error('$exists operator is not supported for non-merklized credential');\n  }\n  if (outputs.merklized === 1) {\n    if (outputs.claimPathKey !== metadata.claimPathKey) {\n      throw new Error(`proof was generated for another path`);\n    }\n  } else {\n    if (outputs.slotIndex !== metadata.slotIndex) {\n      throw new Error(`wrong claim slot was used in claim`);\n    }\n  }\n}\n\nexport async function validateEmptyCredentialSubjectV2Circuit(\n  cq: QueryMetadata,\n  outputs: ClaimOutputs\n) {\n  if (outputs.operator !== Operators.EQ) {\n    throw new Error('empty credentialSubject request available only for equal operation');\n  }\n  for (let index = 1; index < outputs.value.length; index++) {\n    if (outputs.value[index] !== 0n) {\n      throw new Error(`empty credentialSubject request not available for array of values`);\n    }\n  }\n  const path = Path.newPath([VerifiableConstants.CREDENTIAL_SUBJECT_PATH]);\n  const subjectEntry = await path.mtEntry();\n  if (outputs.claimPathKey !== subjectEntry) {\n    throw new Error(`proof doesn't contain credentialSubject in claimPathKey`);\n  }\n  return;\n}\nexport async function validateOperators(cq: QueryMetadata, outputs: ClaimOutputs) {\n  if (outputs.operator !== cq.operator) {\n    throw new Error(`operator that was used is not equal to request`);\n  }\n  if (outputs.operator === Operators.NOOP) {\n    // for noop operator slot and value are not used in this case\n    return;\n  }\n\n  for (let index = 0; index < outputs.value.length; index++) {\n    if (outputs.value[index] !== cq.values[index]) {\n      if (outputs.value[index] === 0n && cq.values[index] === undefined) {\n        continue;\n      }\n      throw new Error(`comparison value that was used is not equal to requested in query`);\n    }\n  }\n}\n\nexport async function validateDisclosureV2Circuit(\n  cq: QueryMetadata,\n  outputs: ClaimOutputs,\n  verifiablePresentation?: VerifiablePresentation,\n  ldLoader?: DocumentLoader\n) {\n  const bi = await fieldValueFromVerifiablePresentation(\n    cq.fieldName,\n    verifiablePresentation,\n    ldLoader\n  );\n  if (bi !== outputs.value[0]) {\n    throw new Error(`value that was used is not equal to requested in query`);\n  }\n\n  if (outputs.operator !== Operators.EQ) {\n    throw new Error(`operator for selective disclosure must be $eq`);\n  }\n\n  for (let index = 1; index < outputs.value.length; index++) {\n    if (outputs.value[index] !== 0n) {\n      throw new Error(`selective disclosure not available for array of values`);\n    }\n  }\n}\n\nexport async function validateDisclosureNativeSDSupport(\n  cq: QueryMetadata,\n  outputs: ClaimOutputs,\n  verifiablePresentation?: VerifiablePresentation,\n  ldLoader?: DocumentLoader\n) {\n  const bi = await fieldValueFromVerifiablePresentation(\n    cq.fieldName,\n    verifiablePresentation,\n    ldLoader\n  );\n  if (bi !== outputs.operatorOutput) {\n    throw new Error(`operator output should be equal to disclosed value`);\n  }\n\n  if (outputs.operator !== Operators.SD) {\n    throw new Error(`operator for selective disclosure must be $sd`);\n  }\n\n  for (let index = 0; index < outputs.value.length; index++) {\n    if (outputs.value[index] !== 0n) {\n      throw new Error(`public signal values must be zero`);\n    }\n  }\n}\nexport async function validateEmptyCredentialSubjectNoopNativeSupport(outputs: ClaimOutputs) {\n  if (outputs.operator !== Operators.NOOP) {\n    throw new Error('empty credentialSubject request available only for $noop operation');\n  }\n  for (let index = 1; index < outputs.value.length; index++) {\n    if (outputs.value[index] !== 0n) {\n      throw new Error(`empty credentialSubject request not available for array of values`);\n    }\n  }\n}\n\nexport const fieldValueFromVerifiablePresentation = async (\n  fieldName: string,\n  verifiablePresentation?: VerifiablePresentation,\n  ldLoader?: DocumentLoader\n): Promise<bigint> => {\n  if (!verifiablePresentation) {\n    throw new Error(`verifiablePresentation is required for selective disclosure request`);\n  }\n\n  let mz: Merklizer;\n  const strVerifiablePresentation: string = JSON.stringify(verifiablePresentation);\n  try {\n    mz = await Merklizer.merklizeJSONLD(strVerifiablePresentation, {\n      documentLoader: ldLoader\n    });\n  } catch (e) {\n    throw new Error(`can't merklize verifiablePresentation`);\n  }\n\n  let merklizedPath: Path;\n  try {\n    const p = `verifiableCredential.credentialSubject.${fieldName}`;\n    merklizedPath = await Path.fromDocument(null, strVerifiablePresentation, p, {\n      documentLoader: ldLoader\n    });\n  } catch (e) {\n    throw new Error(`can't build path to '${fieldName}' key`);\n  }\n\n  let proof: Proof;\n  let value: MtValue | undefined;\n  try {\n    ({ proof, value } = await mz.proof(merklizedPath));\n  } catch (e) {\n    throw new Error(`can't get value by path '${fieldName}'`);\n  }\n  if (!value) {\n    throw new Error(`can't get merkle value for field '${fieldName}'`);\n  }\n\n  if (!proof.existence) {\n    throw new Error(\n      `path [${merklizedPath.parts}] doesn't exist in verifiablePresentation document`\n    );\n  }\n\n  return await value.mtEntry();\n};\n\nexport function calculateGroupId(requestIds: bigint[]): bigint {\n  const types = Array(requestIds.length).fill('uint256');\n\n  const groupID =\n    BigInt(ethers.keccak256(ethers.solidityPacked(types, requestIds))) &\n    // It should fit in a field number in the circuit (max 253 bits). With this we truncate to 252 bits for the group ID\n    BigInt('0x0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF');\n\n  return groupID;\n}\n\nexport function calculateRequestId(requestParams: string, creatorAddress: string): bigint {\n  // 0x0000000000000000FFFF...FF. Reserved first 8 bytes for the request Id type and future use\n  // 0x00010000000000000000...00. First 2 bytes for the request Id type\n  //    - 0x0000... for old request Ids with uint64\n  //    - 0x0001... for new request Ids with uint256\n  const requestId =\n    (BigInt(\n      ethers.keccak256(ethers.solidityPacked(['bytes', 'address'], [requestParams, creatorAddress]))\n    ) &\n      BigInt('0x0000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF')) +\n    BigInt('0x0001000000000000000000000000000000000000000000000000000000000000');\n  return requestId;\n}\n\nexport function calculateMultiRequestId(\n  requestIds: bigint[],\n  groupIds: bigint[],\n  creatorAddress: string\n): bigint {\n  return BigInt(\n    ethers.keccak256(\n      ethers.solidityPacked(\n        ['uint256[]', 'uint256[]', 'address'],\n        [requestIds, groupIds, creatorAddress]\n      )\n    )\n  );\n}\n","import { poseidon } from '@iden3/js-crypto';\nimport { SchemaHash } from '@iden3/js-iden3-core';\nimport { defaultValueArraySize, prepareCircuitArrayValues } from '../../circuits';\n\nexport function calculateQueryHashV2(\n  values: bigint[],\n  schema: SchemaHash,\n  slotIndex: string | number,\n  operator: string | number,\n  claimPathKey: string | number,\n  claimPathNotExists: string | number\n): bigint {\n  const expValue = prepareCircuitArrayValues(values, 64);\n  const valueHash = poseidon.spongeHashX(expValue, 6);\n  return poseidon.hash([\n    schema.bigInt(),\n    BigInt(slotIndex),\n    BigInt(operator),\n    BigInt(claimPathKey),\n    BigInt(claimPathNotExists),\n    valueHash\n  ]);\n}\n\nexport function calculateQueryHashV3(\n  values: bigint[],\n  schema: SchemaHash,\n  slotIndex: string | number,\n  operator: string | number,\n  claimPathKey: string | number,\n  valueArraySize: string | number,\n  merklized: string | number,\n  isRevocationChecked: string | number,\n  verifierID: string | number,\n  nullifierSessionID: string | number\n): bigint {\n  const expValue = prepareCircuitArrayValues(values, defaultValueArraySize);\n  const valueHash = poseidon.spongeHashX(expValue, 6);\n  const firstPartQueryHash = poseidon.hash([\n    schema.bigInt(),\n    BigInt(slotIndex),\n    BigInt(operator),\n    BigInt(claimPathKey),\n    BigInt(merklized),\n    valueHash\n  ]);\n\n  const queryHash = poseidon.hash([\n    firstPartQueryHash,\n    BigInt(valueArraySize),\n    BigInt(isRevocationChecked),\n    BigInt(verifierID),\n    BigInt(nullifierSessionID),\n    0n\n  ]);\n  return queryHash;\n}\n","export * from './identity';\nexport * from './credentials';\nexport * from './kms';\nexport * from './storage';\nexport * from './verifiable';\nexport * from './schema-processor';\nexport * from './proof';\nexport * from './iden3comm';\nexport * from './circuits';\nexport * from './iden3comm';\nexport * from './utils';\nexport * from './blockchain';\nimport * as core from '@iden3/js-iden3-core';\nimport * as jsonLDMerklizer from '@iden3/js-jsonld-merklization';\nexport { core };\nexport { jsonLDMerklizer };\n"],"mappings":"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","names":["Hex","KmsKeyType","Hex","DIDDocumentSignature","Hex","Hex","hexToBytes","buildDIDType","BytesHelper","Claim","ClaimOptions","DID","getUnixTimestamp","Id","SchemaHash","poseidon","PublicKey","sha256","Signature","Hex","getRandomBytes","hashElems","ZERO_HASH","DID","Id","IdPosition","MerklizedRootPosition","Hash","ProofType","CredentialStatusType","ProofPurpose","MerklizedRootPosition","SubjectPosition","RefreshServiceType","PaymentRequestDataType","PaymentType","SupportedPaymentProofType","SupportedCurrencies","PaymentFeatures","DisplayMethodType","Hex","Signature","DID","Hash","Claim","DID","Hash","Merklizer","PublicKey","DID","PublicKey","DID","PublicKey","BytesHelper","keccak256","BytesHelper","jsonld","DID","Merklizer","Claim","PublicKey","Hash","Path","IdPosition","MerklizedRootPosition","DID","Id","uuid","BytesHelper","checkBigIntInField","BytesHelper","checkBigIntInField","credentialSubjectKey","jsonld","jsonld","Contract","JsonRpcProvider","Hex","Hash","swapEndianness","Proof","XSDNS","Operators","CircuitId","CircuitError","Proof","Id","SchemaHash","Hash","values","Id","Hash","SchemaHash","Id","Hash","values","Id","Hash","Id","SchemaHash","Hash","values","Id","Hash","SchemaHash","Claim","Id","SchemaHash","Hash","Proof","ZERO_HASH","Proof","ZERO_HASH","Claim","values","Id","Hash","SchemaHash","Claim","Id","Hash","Proof","ZERO_HASH","zero","Proof","ZERO_HASH","Claim","values","Id","Hash","Id","Hash","values","Id","Hash","Hash","Id","Id","Hash","Id","Hash","Id","Hash","Proof","valuesArr","Proof","DID","getChainId","Id","MerkleTreeType","base64","header","base64","Token","BytesHelper","DID","MediaType","ProtocolVersion","AcceptAuthCircuits","AcceptJwzAlgorithms","AcceptJwsAlgorithms","Token","DID","BytesHelper","vm","CredentialOfferStatus","AuthMethod","DiscoverFeatureQueryType","DiscoveryProtocolFeatureType","DID","getUnixTimestamp","proving","uuid","ethers","credWithRevStatus","ethers","proving","proving","getUnixTimestamp","DID","proving","Proof","Hash","Hash","Proof","DID","Hash","DID","buildDIDType","BytesHelper","DID","Id","Hash","Proof","ZERO_HASH","Proof","ZERO_HASH","Hash","e","DID","Hash","Proof","BytesHelper","buildDIDType","Id","uuid","DID","uuid","DID","Hash","testBit","Hash","testBit","proving","DID","uuid","DID","proving","DID","getUnixTimestamp","BytesHelper","DID","BytesHelper","zkpResponses","getUnixTimestamp","proving","ProvingMethodAlg","DID","uuid","DID","ProvingMethodAlg","proving","DID","uuid","proving","DID","proving","DID","getUnixTimestamp","uuid","proving","getUnixTimestamp","DID","proving","DID","getUnixTimestamp","uuid","proving","ethers","getUnixTimestamp","ethers","DID","proving","uuid","getUnixTimestamp","getUnixTimestamp","uuid","JsonRpcProvider","Contract","Id","getChainId","DID","JsonRpcProvider","Contract","ethers","BytesHelper","DID","Id","Hash","FunctionSignatures","JsonRpcProvider","Contract","Id","DID","Hash","ethers","BytesHelper","DID","Id","chainIDfromDID","Contract","ethers","Claim","DID","Id","Merklizer","Path","Hash","Proof","ethers","ethers","Id","DID","Claim","Path","Hash","Proof","Merklizer","DID","chainIDfromDID","ethers","Id","Contract","Hash","DID","Id","JsonRpcProvider","Hash","Contract","Contract","SearchError","SupportedDataFormat","a","b","acc","Merkletree","str2Bytes","uuid","treesMeta","Merkletree","str2Bytes","set","get","createStore","createStore","get","set","del","Merkletree","str2Bytes","uuid","createStore","get","set","Merkletree","str2Bytes","del","keyPath","BytesHelper","DID","MerklizedRootPosition","getDateFromUnixTimestamp","Hash","Proof","ZERO_HASH","Merklizer","Path","poseidon","Proof","Hash","ZERO_HASH","entries","Path","values","Merklizer","code","res","a","getDocumentLoader","DID","getUnixTimestamp","allOperations","DID","getUnixTimestamp","DID","getDateFromUnixTimestamp","getDocumentLoader","Path","DID","getDateFromUnixTimestamp","Merklizer","Path","ethers","DID","Path","getDateFromUnixTimestamp","Merklizer","poseidon","values","poseidon","getDocumentLoader","DID","getDateFromUnixTimestamp","Path","values","DID","MerklizedRootPosition","BytesHelper","getDocumentLoader","getDateFromUnixTimestamp","PublicKey","SchemaHash","Claim","ClaimOptions","getUnixTimestamp","Hex","sha256","getRandomBytes","hashElems","ZERO_HASH","buildDIDType","Id","DID","poseidon","BytesHelper","Signature"]}